// node_modules/@alova/shared/dist/alova-shared.esm.js
var undefStr = "undefined";
var PromiseCls = Promise;
var promiseResolve = (value) => PromiseCls.resolve(value);
var promiseReject = (value) => PromiseCls.reject(value);
var ObjectCls = Object;
var RegExpCls = RegExp;
var undefinedValue = void 0;
var nullValue = null;
var trueValue = true;
var falseValue = false;
var promiseThen = (promise, onFulfilled, onrejected) => promise.then(onFulfilled, onrejected);
var promiseCatch = (promise, onrejected) => promise.catch(onrejected);
var promiseFinally = (promise, onfinally) => promise.finally(onfinally);
var JSONStringify = (value, replacer, space) => JSON.stringify(value, replacer, space);
var JSONParse = (value) => JSON.parse(value);
var setTimeoutFn = (fn, delay = 0) => setTimeout(fn, delay);
var clearTimeoutTimer = (timer) => clearTimeout(timer);
var objectKeys = (obj) => ObjectCls.keys(obj);
var objectValues = (obj) => ObjectCls.values(obj);
var forEach = (ary, fn) => ary.forEach(fn);
var pushItem = (ary, ...item) => ary.push(...item);
var mapItem = (ary, callbackfn) => ary.map(callbackfn);
var filterItem = (ary, predicate) => ary.filter(predicate);
var shift = (ary) => ary.shift();
var splice = (ary, start, deleteCount = 0, ...items) => ary.splice(start, deleteCount, ...items);
var len = (data) => data.length;
var isArray = (arg) => Array.isArray(arg);
var deleteAttr = (arg, attr) => delete arg[attr];
var typeOf = (arg) => typeof arg;
var regexpTest = (reg, str) => reg.test(`${str}`);
var includes = (ary, target) => ary.includes(target);
var valueObject = (value, writable = falseValue) => ({ value, writable });
var defineProperty = (o, key2, value, isDescriptor = falseValue) => ObjectCls.defineProperty(o, key2, isDescriptor ? value : valueObject(value, falseValue));
var isSSR = typeof window === undefStr && (typeof process !== undefStr ? typeof process.cwd === "function" : typeof Deno !== undefStr);
var MEMORY = "memory";
var STORAGE_RESTORE = "restore";
var noop = () => {
};
var $self = (arg) => arg;
var isFn = (arg) => typeOf(arg) === "function";
var isNumber = (arg) => typeOf(arg) === "number" && !Number.isNaN(arg);
var isString = (arg) => typeOf(arg) === "string";
var isObject = (arg) => arg !== nullValue && typeOf(arg) === "object";
var globalToString = (arg) => ObjectCls.prototype.toString.call(arg);
var isPlainObject = (arg) => globalToString(arg) === "[object Object]";
var instanceOf = (arg, cls) => arg instanceof cls;
var getTime = (date) => date ? date.getTime() : Date.now();
var getContext = (methodInstance) => methodInstance.context;
var getConfig = (methodInstance) => methodInstance.config;
var getContextOptions = (alovaInstance) => alovaInstance.options;
var getOptions = (methodInstance) => getContextOptions(getContext(methodInstance));
var key = (methodInstance) => {
  const { params, headers } = getConfig(methodInstance);
  return JSONStringify([methodInstance.type, methodInstance.url, params, methodInstance.data, headers]);
};
var uuid = () => {
  const timestamp = (/* @__PURE__ */ new Date()).getTime();
  return Math.floor(Math.random() * timestamp).toString(36);
};
var getMethodInternalKey = (methodInstance) => methodInstance.key;
var getHandlerMethod = (methodHandler, assert, args = []) => {
  const methodInstance = isFn(methodHandler) ? methodHandler(...args) : methodHandler;
  assert(!!methodInstance.key, "hook handler must be a method instance or a function that returns method instance");
  return methodInstance;
};
var isSpecialRequestBody = (data) => {
  const dataTypeString = globalToString(data);
  return /^\[object (Blob|FormData|ReadableStream|URLSearchParams)\]$/i.test(dataTypeString) || instanceOf(data, ArrayBuffer);
};
var objAssign = (target, ...sources) => ObjectCls.assign(target, ...sources);
var omit = (obj, ...keys) => {
  const result = {};
  for (const key2 in obj) {
    if (!keys.includes(key2)) {
      result[key2] = obj[key2];
    }
  }
  return result;
};
function usePromise() {
  let retResolve;
  let retReject;
  const promise = new Promise((resolve, reject) => {
    retResolve = resolve;
    retReject = reject;
  });
  return { promise, resolve: retResolve, reject: retReject };
}
var getLocalCacheConfigParam = (methodInstance) => {
  const { cacheFor } = getConfig(methodInstance);
  const getCacheExpireTs = (cacheExpire) => isNumber(cacheExpire) ? getTime() + cacheExpire : getTime(cacheExpire || undefinedValue);
  let cacheMode = MEMORY;
  let expire = () => 0;
  let store = falseValue;
  let tag = undefinedValue;
  const controlled = isFn(cacheFor);
  if (!controlled) {
    let expireColumn = cacheFor;
    if (isPlainObject(cacheFor)) {
      const { mode = MEMORY, expire: expire2, tag: configTag } = cacheFor || {};
      cacheMode = mode;
      store = mode === STORAGE_RESTORE;
      tag = configTag ? configTag.toString() : undefinedValue;
      expireColumn = expire2;
    }
    expire = (mode) => getCacheExpireTs(isFn(expireColumn) ? expireColumn({ method: methodInstance, mode }) : expireColumn);
  }
  return {
    f: cacheFor,
    c: controlled,
    e: expire,
    m: cacheMode,
    s: store,
    t: tag
  };
};
var newInstance = (Cls, ...args) => new Cls(...args);
var sloughConfig = (config, args = []) => isFn(config) ? config(...args) : config;
var sloughFunction = (arg, defaultFn) => isFn(arg) ? arg : ![falseValue, nullValue].includes(arg) ? defaultFn : noop;
var createSyncOnceRunner = (delay = 0) => {
  let timer = undefinedValue;
  return (fn) => {
    if (timer) {
      clearTimeout(timer);
    }
    timer = setTimeoutFn(fn, delay);
  };
};
var createAsyncQueue = (catchError = falseValue) => {
  const queue = [];
  let completedHandler = undefinedValue;
  let executing = false;
  const executeQueue = async () => {
    executing = true;
    while (len(queue) > 0) {
      const asyncFunc = shift(queue);
      if (asyncFunc) {
        await asyncFunc();
      }
    }
    completedHandler && completedHandler();
    executing = false;
  };
  const addQueue = (asyncFunc) => newInstance(PromiseCls, (resolve, reject) => {
    const wrappedFunc = () => promiseThen(asyncFunc(), resolve, (err) => {
      catchError ? resolve(undefinedValue) : reject(err);
    });
    pushItem(queue, wrappedFunc);
    if (!executing) {
      executeQueue();
    }
  });
  const onComplete = (fn) => {
    completedHandler = fn;
  };
  return {
    addQueue,
    onComplete
  };
};
var walkObject = (target, callback, preorder = trueValue, key2, parent) => {
  const callCallback = () => {
    if (parent && key2) {
      target = callback(target, key2, parent);
      if (target !== parent[key2]) {
        parent[key2] = target;
      }
    }
  };
  preorder && callCallback();
  if (isObject(target)) {
    for (const i in target) {
      if (!instanceOf(target, String)) {
        walkObject(target[i], callback, preorder, i, target);
      }
    }
  }
  !preorder && callCallback();
  return target;
};
var cacheKeyPrefix = "$a.";
var buildNamespacedCacheKey = (namespace, key2) => cacheKeyPrefix + namespace + key2;
var delayWithBackoff = (backoff, retryTimes) => {
  let { startQuiver, endQuiver } = backoff;
  const { delay, multiplier = 1 } = backoff;
  let retryDelayFinally = (delay || 0) * multiplier ** (retryTimes - 1);
  if (startQuiver || endQuiver) {
    startQuiver = startQuiver || 0;
    endQuiver = endQuiver || 1;
    retryDelayFinally += retryDelayFinally * startQuiver + Math.random() * retryDelayFinally * (endQuiver - startQuiver);
    retryDelayFinally = Math.floor(retryDelayFinally);
  }
  return retryDelayFinally;
};
var buildCompletedURL = (baseURL, url, params) => {
  baseURL = baseURL.endsWith("/") ? baseURL.slice(0, -1) : baseURL;
  if (url !== "") {
    url = url.match(/^(\/|https?:\/\/)/) ? url : `/${url}`;
  }
  const completeURL = baseURL + url;
  const paramsStr = mapItem(filterItem(objectKeys(params), (key2) => params[key2] !== undefinedValue), (key2) => `${key2}=${params[key2]}`).join("&");
  return paramsStr ? +completeURL.includes("?") ? `${completeURL}&${paramsStr}` : `${completeURL}?${paramsStr}` : completeURL;
};
var AlovaError = class extends Error {
  constructor(prefix, message, errorCode) {
    super(message + (errorCode ? `

For detailed: https://alova.js.org/error#${errorCode}` : ""));
    this.name = `[alova${prefix ? `/${prefix}` : ""}]`;
  }
};
var createAssert = (prefix = "") => (expression, message, errorCode) => {
  if (!expression) {
    throw newInstance(AlovaError, prefix, message, errorCode);
  }
};
var createEventManager = () => {
  const eventMap = {};
  return {
    eventMap,
    on(type, handler) {
      const eventTypeItem = eventMap[type] = eventMap[type] || [];
      pushItem(eventTypeItem, handler);
      return () => {
        eventMap[type] = filterItem(eventTypeItem, (item) => item !== handler);
      };
    },
    off(type, handler) {
      const handlers = eventMap[type];
      if (!handlers) {
        return;
      }
      if (handler) {
        const index = handlers.indexOf(handler);
        index > -1 && handlers.splice(index, 1);
      } else {
        delete eventMap[type];
      }
    },
    emit(type, event) {
      const handlers = eventMap[type] || [];
      return mapItem(handlers, (handler) => handler(event));
    }
  };
};
var decorateEvent = (onEvent, decoratedHandler) => {
  const emitter = createEventManager();
  const eventType = uuid();
  const eventReturn = onEvent((event) => emitter.emit(eventType, event));
  return (handler) => {
    emitter.on(eventType, (event) => {
      decoratedHandler(handler, event);
    });
    return eventReturn;
  };
};
var FrameworkReadableState = class {
  constructor(state, key2, dehydrate, exportState) {
    this.s = state;
    this.k = key2;
    this.$dhy = dehydrate;
    this.$exp = exportState;
  }
  get v() {
    return this.$dhy(this.s);
  }
  get e() {
    return this.$exp(this.s);
  }
};
var FrameworkState = class extends FrameworkReadableState {
  constructor(state, key2, dehydrate, exportState, update) {
    super(state, key2, dehydrate, exportState);
    this.$upd = update;
  }
  set v(newValue) {
    this.$upd(this.s, newValue);
  }
  get v() {
    return super.v;
  }
};

export {
  PromiseCls,
  promiseResolve,
  promiseReject,
  ObjectCls,
  RegExpCls,
  undefinedValue,
  nullValue,
  trueValue,
  falseValue,
  promiseThen,
  promiseCatch,
  promiseFinally,
  JSONStringify,
  JSONParse,
  setTimeoutFn,
  clearTimeoutTimer,
  objectKeys,
  objectValues,
  forEach,
  pushItem,
  mapItem,
  filterItem,
  shift,
  splice,
  len,
  isArray,
  deleteAttr,
  regexpTest,
  includes,
  valueObject,
  defineProperty,
  isSSR,
  MEMORY,
  STORAGE_RESTORE,
  noop,
  $self,
  isFn,
  isNumber,
  isString,
  isObject,
  globalToString,
  isPlainObject,
  instanceOf,
  getTime,
  getContext,
  getConfig,
  getContextOptions,
  getOptions,
  key,
  uuid,
  getMethodInternalKey,
  getHandlerMethod,
  isSpecialRequestBody,
  objAssign,
  omit,
  usePromise,
  getLocalCacheConfigParam,
  newInstance,
  sloughConfig,
  sloughFunction,
  createSyncOnceRunner,
  createAsyncQueue,
  walkObject,
  buildNamespacedCacheKey,
  delayWithBackoff,
  buildCompletedURL,
  AlovaError,
  createAssert,
  createEventManager,
  decorateEvent,
  FrameworkReadableState,
  FrameworkState
};
//# sourceMappingURL=chunk-5IKTR5MP.js.map
