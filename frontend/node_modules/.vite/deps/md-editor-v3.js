import {
  markdown
} from "./chunk-S4TWUJCZ.js";
import "./chunk-AVCWWZDE.js";
import "./chunk-UZMH4UWW.js";
import "./chunk-2YS6VLTH.js";
import {
  autocompletion,
  closeBrackets,
  closeBracketsKeymap,
  completionKeymap
} from "./chunk-Z4S5SNRW.js";
import {
  Annotation,
  ChangeDesc,
  ChangeSet,
  CharCategory,
  Compartment,
  Decoration,
  Direction,
  EditorSelection,
  EditorState,
  EditorView,
  Facet,
  GutterMarker,
  HighlightStyle,
  IndentContext,
  LanguageDescription,
  LanguageSupport,
  NodeProp,
  Prec,
  RangeSet,
  RangeSetBuilder,
  StateEffect,
  StateField,
  StreamLanguage,
  Text,
  Transaction,
  ViewPlugin,
  WidgetType,
  bracketMatching,
  codePointAt,
  codePointSize,
  combineConfig,
  countColumn,
  crosshairCursor,
  defaultHighlightStyle,
  drawSelection,
  dropCursor,
  findClusterBreak,
  foldGutter,
  foldKeymap,
  fromCodePoint,
  getIndentUnit,
  getIndentation,
  getPanel,
  gutter,
  highlightActiveLine,
  highlightActiveLineGutter,
  highlightSpecialChars,
  hoverTooltip,
  indentOnInput,
  indentString,
  indentUnit,
  keymap,
  lineNumbers,
  logException,
  matchBrackets,
  placeholder,
  rectangularSelection,
  runScopeHandlers,
  showPanel,
  showTooltip,
  syntaxHighlighting,
  syntaxTree,
  tags
} from "./chunk-IZS5XX5M.js";
import {
  lib_default
} from "./chunk-7FCYYZCM.js";
import {
  Fragment,
  Teleport,
  cloneVNode,
  computed,
  createVNode,
  defineComponent,
  h,
  inject,
  isVNode,
  nextTick,
  onBeforeUnmount,
  onMounted,
  provide,
  reactive,
  ref,
  shallowRef,
  toRef,
  watch
} from "./chunk-TF6X5W6F.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection2 = document.getSelection();
      if (!selection2.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i2 = 0; i2 < selection2.rangeCount; i2++) {
        ranges.push(selection2.getRangeAt(i2));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection2.removeAllRanges();
      return function() {
        selection2.type === "Caret" && selection2.removeAllRanges();
        if (!selection2.rangeCount) {
          ranges.forEach(function(range) {
            selection2.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy2(text, options) {
      var debug, message, reselectPrevious, range, selection2, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection2 = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection2.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection2) {
          if (typeof selection2.removeRange == "function") {
            selection2.removeRange(range);
          } else {
            selection2.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy2;
  }
});

// node_modules/@vavt/util/lib/es/index.mjs
var T = (e2) => {
  const n2 = typeof e2;
  return n2 !== "function" && n2 !== "object" || e2 === null;
};
var E = (e2) => {
  const n2 = e2.flags === "" ? void 0 : e2.flags;
  return new RegExp(e2.source, n2);
};
var u = (e2, n2 = /* @__PURE__ */ new WeakMap()) => {
  if (e2 === null || T(e2))
    return e2;
  if (n2.has(e2))
    return n2.get(e2);
  if (e2 instanceof RegExp)
    return E(e2);
  if (e2 instanceof Date)
    return new Date(e2.getTime());
  if (e2 instanceof Function)
    return e2;
  if (e2 instanceof Map) {
    const r2 = /* @__PURE__ */ new Map();
    return n2.set(e2, r2), e2.forEach((o, s) => {
      r2.set(s, u(o, n2));
    }), r2;
  }
  if (e2 instanceof Set) {
    const r2 = /* @__PURE__ */ new Set();
    n2.set(e2, r2);
    for (const o of e2)
      r2.add(u(o, n2));
    return r2;
  }
  if (Array.isArray(e2)) {
    const r2 = [];
    return n2.set(e2, r2), e2.forEach((o) => {
      r2.push(u(o, n2));
    }), r2;
  }
  const t2 = {};
  n2.set(e2, t2);
  for (const r2 in e2)
    Object.prototype.hasOwnProperty.call(e2, r2) && (t2[r2] = u(e2[r2], n2));
  return t2;
};
var k = (e2, n2 = 200) => {
  let t2 = 0;
  return (...r2) => new Promise((o) => {
    t2 && (clearTimeout(t2), o("cancel")), t2 = window.setTimeout(() => {
      e2.apply(void 0, r2), t2 = 0, o("done");
    }, n2);
  });
};
var C = (e2, n2 = {
  _blank: true,
  nofollow: true
}) => {
  const t2 = document.createElement("a");
  t2.href = e2, n2._blank && (t2.target = "_blank"), n2.nofollow && (t2.rel = "noopener noreferrer"), t2.click();
};
var x = () => {
  let e2 = -1;
  return (t2, r2, o, s = 100) => {
    const c = () => {
      o && (typeof s == "number" ? setTimeout(o, s) : o());
    };
    e2 !== -1 && (cancelAnimationFrame(e2), c());
    let i2 = t2.scrollTop;
    const l = () => {
      e2 = -1;
      const a = r2 - i2;
      i2 = i2 + a / 5, Math.abs(a) < 1 ? (t2.scrollTo(0, r2), c()) : (t2.scrollTo(0, i2), e2 = requestAnimationFrame(l));
    };
    e2 = requestAnimationFrame(l);
  };
};
var R = x();
var $ = (e2, n2 = 200) => {
  let t2 = 0, r2 = null;
  const o = (s) => {
    t2 === 0 && (t2 = s), s - t2 >= n2 ? (e2.apply(void 0, r2), r2 = null, t2 = 0) : window.requestAnimationFrame(o);
  };
  return (...s) => {
    r2 === null && window.requestAnimationFrame(o), r2 = s;
  };
};
var I = (e2) => {
  const n2 = (t2) => {
    const { scrollHeight: r2, scrollWidth: o, offsetHeight: s, offsetWidth: c, scrollLeft: i2, scrollTop: l } = e2, a = t2.x, h2 = t2.y, p = (g) => {
      const f = l + h2 - g.y, d = i2 + a - g.x, S = r2 - s, A = o - c, m = {};
      d >= 0 && d <= A && (m.left = d), f >= 0 && f <= S && (m.top = f), e2.scroll(m);
    };
    document.addEventListener("mousemove", p);
    const w = () => {
      document.removeEventListener("mousemove", p), document.removeEventListener("mouseup", w);
    };
    document.addEventListener("mouseup", w);
  };
  return e2.addEventListener("mousedown", n2), () => {
    e2.removeEventListener("mousedown", n2);
  };
};
var U = () => `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`;
var y = (e2) => e2 !== null && typeof e2 == "object" && !Array.isArray(e2);
var M = (e2, n2, t2 = {}) => {
  const { excludeKeys: r2 } = t2;
  for (const o in n2)
    r2 && r2(o) ? e2[o] = n2[o] : y(n2[o]) && y(e2[o]) ? e2[o] = M(
      e2[o],
      n2[o],
      t2
    ) : e2[o] = n2[o];
  return e2;
};

// node_modules/md-editor-v3/lib/es/chunks/config.mjs
var prefix = "md-editor";
var iconfontSvgUrl = "https://at.alicdn.com/t/c/font_2605852_cmafimm6hot.js";
var iconfontClassUrl = "https://at.alicdn.com/t/c/font_2605852_cmafimm6hot.css";
var cdnBase = "https://unpkg.com";
var highlightUrl = `${cdnBase}/@highlightjs/cdn-assets@11.10.0/highlight.min.js`;
var prettierUrl = {
  main: `${cdnBase}/prettier@3.3.3/standalone.js`,
  markdown: `${cdnBase}/prettier@3.3.3/plugins/markdown.js`
};
var cropperUrl = {
  css: `${cdnBase}/cropperjs@1.6.2/dist/cropper.min.css`,
  js: `${cdnBase}/cropperjs@1.6.2/dist/cropper.min.js`
};
var screenfullUrl = `${cdnBase}/screenfull@5.2.0/dist/screenfull.js`;
var mermaidUrl = `${cdnBase}/mermaid@11.3.0/dist/mermaid.min.js`;
var katexUrl = {
  js: `${cdnBase}/katex@0.16.11/dist/katex.min.js`,
  css: `${cdnBase}/katex@0.16.11/dist/katex.min.css`
};
var codeCss = {
  a11y: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/a11y-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/a11y-dark.min.css`
  },
  atom: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/atom-one-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/atom-one-dark.min.css`
  },
  github: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/github.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/github-dark.min.css`
  },
  gradient: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/gradient-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/gradient-dark.min.css`
  },
  kimbie: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/kimbie-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/kimbie-dark.min.css`
  },
  paraiso: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/paraiso-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/paraiso-dark.min.css`
  },
  qtcreator: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/qtcreator-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/qtcreator-dark.min.css`
  },
  stackoverflow: {
    light: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/stackoverflow-light.min.css`,
    dark: `${cdnBase}/@highlightjs/cdn-assets@11.10.0/styles/stackoverflow-dark.min.css`
  }
};
var editorExtensionsAttrs = {
  highlight: {
    js: {
      integrity: "sha384-GdEWAbCjn+ghjX0gLx7/N1hyTVmPAjdC2OvoAA0RyNcAOhqwtT8qnbCxWle2+uJX",
      crossOrigin: "anonymous"
    },
    css: {
      a11y: {
        light: {
          integrity: "sha384-qdZDAN3jffvh670RHw1wxLekabidEFaNRninYgIzBvMbL6WlHdXeHS/Bt+vx33lN",
          crossOrigin: "anonymous"
        },
        dark: {
          integrity: "sha384-2QAAjX8pqaM5azX68KWI2wExF6Q13kY4kEiQFY4b/1zPe6rpgmTByNpDEllH3sb+",
          crossOrigin: "anonymous"
        }
      },
      atom: {
        light: {
          integrity: "sha384-w6Ujm1VWa9HYFqGc89oAPn/DWDi2gUamjNrq9DRvEYm2X3ClItg9Y9xs1ViVo5b5",
          crossOrigin: "anonymous"
        },
        dark: {
          integrity: "sha384-oaMLBGEzBOJx3UHwac0cVndtX5fxGQIfnAeFZ35RTgqPcYlbprH9o9PUV/F8Le07",
          crossOrigin: "anonymous"
        }
      },
      github: {
        light: {
          integrity: "sha384-eFTL69TLRZTkNfYZOLM+G04821K1qZao/4QLJbet1pP4tcF+fdXq/9CdqAbWRl/L",
          crossOrigin: "anonymous"
        },
        dark: {
          integrity: "sha384-wH75j6z1lH97ZOpMOInqhgKzFkAInZPPSPlZpYKYTOqsaizPvhQZmAtLcPKXpLyH",
          crossOrigin: "anonymous"
        }
      },
      gradient: {
        light: {
          integrity: "sha384-yErHBR8aEZPxRl3XmR8dGSRAclMlnSRRw8sXQLcmPWzWUvb56BzQmBw3EWHl7QGI",
          crossOrigin: "anonymous"
        },
        dark: {
          integrity: "sha384-lUCvtSOdvDbp5hLWKgwz/taFu1HxlpqES2OVP5UG2JMTfnU481gXcBhGF9lAGoSr",
          crossOrigin: "anonymous"
        }
      },
      kimbie: {
        light: {
          integrity: "sha384-tloeSLUPczAvoZ48TUz+OxRie0oYLCRwlkadUXovGzzJEIbNQB2TkfUuvJ6SW5Mi",
          crossOrigin: "anonymous"
        },
        dark: {
          integrity: "sha384-o5F1vUaMNOmou1sQrsWiFo4/QUGSV0svqNZW+EesmKxWC8MpFJcveBhAyfvTHbGb",
          crossOrigin: "anonymous"
        }
      },
      paraiso: {
        light: {
          integrity: "sha384-5j6QHU2Hwg1ehtlIQNDebhETDB8bga3/88hzBFsMRaGmgQHCftqIN7GZNDNw0vTL",
          crossOrigin: "anonymous"
        },
        dark: {
          integrity: "sha384-I5vnnMQu0LWDQnHpT61xyoMwKarAB8jpZkB2ioFOlmzUFnIFaV4QbUwlBBOMKhTH",
          crossOrigin: "anonymous"
        }
      },
      qtcreator: {
        light: {
          integrity: "sha384-iEBgHrwi8Hv4dSZBz+MOGvS05rF7I7fGKM2fASQyE9jn2Istg9Qd5dSoK18WyRTB",
          crossOrigin: "anonymous"
        },
        dark: {
          integrity: "sha384-D6LXJGWNR4QV7gnpuP3ccbvOYoR02td3cU0y7lESABPg/tzCSC4m+y+M2TtrmpHc",
          crossOrigin: "anonymous"
        }
      },
      stackoverflow: {
        light: {
          integrity: "sha384-FMwt7cTGo4aLxZnno5k0xTj0W4gmi48Kwept+y/oQmE6cFk36Kr+QJZOKNOQwORe",
          crossOrigin: "anonymous"
        },
        dark: {
          integrity: "sha384-iL+x+BroCyHm/p2c6sMA9umXhdCWp2cKe4QUjPeMzHgwXAk+ZxHyIGP3NZTZensU",
          crossOrigin: "anonymous"
        }
      }
    }
  },
  prettier: {
    standaloneJs: {
      integrity: "sha384-92h6ALm8/lHpNGn6MfGlgZ+I8c/4yn/nSN8dV9ZmDxqbP9L93gk/Jj2i0LtV+AVd",
      crossOrigin: "anonymous"
    },
    parserMarkdownJs: {
      integrity: "sha384-5ufuUgoSsr/2oihBZ5d+c+yt0qaUmzLtUz41VZNJ4txtyJ6mBve3ZwuKoq/IygYX",
      crossOrigin: "anonymous"
    }
  },
  cropper: {
    js: {
      integrity: "sha384-jrOgQzBlDeUNdmQn3rUt/PZD+pdcRBdWd/HWRqRo+n2OR2QtGyjSaJC0GiCeH+ir",
      crossOrigin: "anonymous"
    },
    css: {
      integrity: "sha384-6LFfkTKLRlzFtgx8xsWyBdKGpcMMQTkv+dB7rAbugeJAu1Ym2q1Aji1cjHBG12Xh",
      crossOrigin: "anonymous"
    }
  },
  screenfull: {
    js: {
      integrity: "sha384-Qfbv8upMDu/ikv42M0Jnym2hahbDQ77Nm8PGU0G+iA6UIwt1+scE6P1qKXA0anWU",
      crossOrigin: "anonymous"
    }
  },
  mermaid: {
    js: {
      integrity: "sha384-B2tp/GqmE6VfDRB3JPTsesr0+SXypThjLSvQEQH7iv3f3/PYKCm5Q4+SGPcitStz",
      crossOrigin: "anonymous"
    }
  },
  katex: {
    js: {
      integrity: "sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg",
      crossOrigin: "anonymous"
    },
    css: {
      integrity: "sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+",
      crossOrigin: "anonymous"
    }
  }
};
var allToolbar = [
  "bold",
  "underline",
  "italic",
  "strikeThrough",
  "-",
  "title",
  "sub",
  "sup",
  "quote",
  "unorderedList",
  "orderedList",
  "task",
  "-",
  "codeRow",
  "code",
  "link",
  "image",
  "table",
  "mermaid",
  "katex",
  "-",
  "revoke",
  "next",
  "save",
  "=",
  "prettier",
  "pageFullscreen",
  "fullscreen",
  "preview",
  "previewOnly",
  "htmlPreview",
  "catalog",
  "github"
];
var allFooter = ["markdownTotal", "=", "scrollSwitch"];
var staticTextDefault = {
  "zh-CN": {
    toolbarTips: {
      bold: "加粗",
      underline: "下划线",
      italic: "斜体",
      strikeThrough: "删除线",
      title: "标题",
      sub: "下标",
      sup: "上标",
      quote: "引用",
      unorderedList: "无序列表",
      orderedList: "有序列表",
      task: "任务列表",
      codeRow: "行内代码",
      code: "块级代码",
      link: "链接",
      image: "图片",
      table: "表格",
      mermaid: "mermaid图",
      katex: "katex公式",
      revoke: "后退",
      next: "前进",
      save: "保存",
      prettier: "美化",
      pageFullscreen: "浏览器全屏",
      fullscreen: "屏幕全屏",
      preview: "预览",
      previewOnly: "仅预览",
      htmlPreview: "html代码预览",
      catalog: "目录",
      github: "源码地址"
    },
    titleItem: {
      h1: "一级标题",
      h2: "二级标题",
      h3: "三级标题",
      h4: "四级标题",
      h5: "五级标题",
      h6: "六级标题"
    },
    imgTitleItem: {
      link: "添加链接",
      upload: "上传图片",
      clip2upload: "裁剪上传"
    },
    linkModalTips: {
      linkTitle: "添加链接",
      imageTitle: "添加图片",
      descLabel: "链接描述：",
      descLabelPlaceHolder: "请输入描述...",
      urlLabel: "链接地址：",
      urlLabelPlaceHolder: "请输入链接...",
      buttonOK: "确定"
    },
    clipModalTips: {
      title: "裁剪图片上传",
      buttonUpload: "上传"
    },
    copyCode: {
      text: "复制代码",
      successTips: "已复制！",
      failTips: "复制失败！"
    },
    mermaid: {
      flow: "流程图",
      sequence: "时序图",
      gantt: "甘特图",
      class: "类图",
      state: "状态图",
      pie: "饼图",
      relationship: "关系图",
      journey: "旅程图"
    },
    katex: {
      inline: "行内公式",
      block: "块级公式"
    },
    footer: {
      markdownTotal: "字数",
      scrollAuto: "同步滚动"
    }
  },
  "en-US": {
    toolbarTips: {
      bold: "bold",
      underline: "underline",
      italic: "italic",
      strikeThrough: "strikeThrough",
      title: "title",
      sub: "subscript",
      sup: "superscript",
      quote: "quote",
      unorderedList: "unordered list",
      orderedList: "ordered list",
      task: "task list",
      codeRow: "inline code",
      code: "block-level code",
      link: "link",
      image: "image",
      table: "table",
      mermaid: "mermaid",
      katex: "formula",
      revoke: "revoke",
      next: "undo revoke",
      save: "save",
      prettier: "prettier",
      pageFullscreen: "fullscreen in page",
      fullscreen: "fullscreen",
      preview: "preview",
      previewOnly: "preview only",
      htmlPreview: "html preview",
      catalog: "catalog",
      github: "source code"
    },
    titleItem: {
      h1: "Lv1 Heading",
      h2: "Lv2 Heading",
      h3: "Lv3 Heading",
      h4: "Lv4 Heading",
      h5: "Lv5 Heading",
      h6: "Lv6 Heading"
    },
    imgTitleItem: {
      link: "Add Image Link",
      upload: "Upload Images",
      clip2upload: "Clip Upload"
    },
    linkModalTips: {
      linkTitle: "Add Link",
      imageTitle: "Add Image",
      descLabel: "Desc:",
      descLabelPlaceHolder: "Enter a description...",
      urlLabel: "Link:",
      urlLabelPlaceHolder: "Enter a link...",
      buttonOK: "OK"
    },
    clipModalTips: {
      title: "Crop Image",
      buttonUpload: "Upload"
    },
    copyCode: {
      text: "Copy",
      successTips: "Copied!",
      failTips: "Copy failed!"
    },
    mermaid: {
      flow: "flow",
      sequence: "sequence",
      gantt: "gantt",
      class: "class",
      state: "state",
      pie: "pie",
      relationship: "relationship",
      journey: "journey"
    },
    katex: {
      inline: "inline",
      block: "block"
    },
    footer: {
      markdownTotal: "Character Count",
      scrollAuto: "Scroll Auto"
    }
  }
};
var configOption = {
  editorExtensions: {
    highlight: {
      js: highlightUrl,
      css: codeCss
    },
    prettier: {
      standaloneJs: prettierUrl.main,
      parserMarkdownJs: prettierUrl.markdown
    },
    cropper: {
      ...cropperUrl
    },
    iconfont: iconfontSvgUrl,
    iconfontClass: iconfontClassUrl,
    screenfull: {
      js: screenfullUrl
    },
    mermaid: {
      js: mermaidUrl
    },
    katex: {
      ...katexUrl
    }
  },
  editorExtensionsAttrs: {},
  editorConfig: {
    languageUserDefined: {},
    mermaidTemplate: {},
    renderDelay: 500,
    zIndex: 2e4
  },
  codeMirrorExtensions: (_theme, innerExtensions) => innerExtensions,
  markdownItConfig: () => {
  },
  markdownItPlugins: (s) => s,
  iconfontType: "svg",
  mermaidConfig: (c) => c,
  katexConfig: (c) => c
};
var config = (option) => {
  return M(configOption, option, {
    excludeKeys(key) {
      return /[iI]{1}nstance/.test(key);
    }
  });
};
var MinInputBoxWidth = 170;

// node_modules/md-editor-v3/lib/es/chunks/vue-tsx.mjs
var getSlot = ({
  instance,
  ctx,
  props: props8 = {}
}, name = "default") => {
  const targetSlot = (instance == null ? void 0 : instance.$slots[name]) || (ctx == null ? void 0 : ctx.slots[name]);
  return (targetSlot ? targetSlot(instance) : "") || props8[name];
};

// node_modules/md-editor-v3/lib/es/chunks/index2.mjs
var props$1 = {
  overlay: {
    type: [String, Object],
    default: ""
  },
  visible: {
    type: Boolean,
    default: false
  },
  onChange: {
    type: Function,
    default: () => {
    }
  },
  // 相对滚动的元素选择器
  relative: {
    type: String,
    default: "html"
  }
};
var Dropdown = defineComponent({
  props: props$1,
  setup(props22, ctx) {
    const HIDDEN_CLASS = `${prefix}-dropdown-hidden`;
    const ctl = reactive({
      overlayClass: [HIDDEN_CLASS],
      overlayStyle: {},
      triggerHover: false,
      overlayHover: false
    });
    const triggerRef = ref();
    const overlayRef = ref();
    const triggerHandler = () => {
      var _a3, _b2;
      ctl.triggerHover = true;
      const triggerEle = triggerRef.value;
      const overlayEle = overlayRef.value;
      if (!triggerEle || !overlayEle) {
        return;
      }
      const triggerInfo = triggerEle.getBoundingClientRect();
      const triggerTop = triggerEle.offsetTop;
      const triggerLeft = triggerEle.offsetLeft;
      const triggerHeight = triggerInfo.height;
      const triggerWidth = triggerInfo.width;
      const rootNode = triggerEle.getRootNode();
      const relativecrollLeft = ((_a3 = rootNode.querySelector(props22.relative)) == null ? void 0 : _a3.scrollLeft) || 0;
      const relativeWidth = ((_b2 = rootNode.querySelector(props22.relative)) == null ? void 0 : _b2.clientWidth) || 0;
      let left = triggerLeft - overlayEle.offsetWidth / 2 + triggerWidth / 2 - relativecrollLeft;
      if (left + overlayEle.offsetWidth > relativecrollLeft + relativeWidth) {
        left = relativecrollLeft + relativeWidth - overlayEle.offsetWidth;
      }
      if (left < 0) {
        left = 0;
      }
      ctl.overlayStyle = {
        ...ctl.overlayStyle,
        top: triggerTop + triggerHeight + "px",
        left: left + "px"
      };
      props22.onChange(true);
    };
    const overlayHandler = () => {
      ctl.overlayHover = true;
    };
    watch(() => props22.visible, (newV) => {
      if (newV) {
        ctl.overlayClass = ctl.overlayClass.filter((classItem) => classItem !== HIDDEN_CLASS);
      } else {
        ctl.overlayClass.push(HIDDEN_CLASS);
      }
    });
    let hiddenTimer = -1;
    const leaveHidden = (e2) => {
      if (triggerRef.value === e2.target) {
        ctl.triggerHover = false;
      } else {
        ctl.overlayHover = false;
      }
      clearTimeout(hiddenTimer);
      hiddenTimer = window.setTimeout(() => {
        if (!ctl.overlayHover && !ctl.triggerHover) {
          props22.onChange(false);
        }
      }, 10);
    };
    onMounted(() => {
      triggerRef.value.addEventListener("mouseenter", triggerHandler);
      triggerRef.value.addEventListener("mouseleave", leaveHidden);
      overlayRef.value.addEventListener("mouseenter", overlayHandler);
      overlayRef.value.addEventListener("mouseleave", leaveHidden);
    });
    onBeforeUnmount(() => {
      triggerRef.value.removeEventListener("mouseenter", triggerHandler);
      triggerRef.value.removeEventListener("mouseleave", leaveHidden);
      overlayRef.value.removeEventListener("mouseenter", overlayHandler);
      overlayRef.value.removeEventListener("mouseleave", leaveHidden);
    });
    return () => {
      const slotDefault = getSlot({
        ctx
      });
      const slotOverlay = getSlot({
        props: props22,
        ctx
      }, "overlay");
      const trigger = cloneVNode(slotDefault instanceof Array ? slotDefault[0] : slotDefault, {
        ref: triggerRef,
        key: "cloned-dropdown-trigger"
      });
      const overlay = createVNode("div", {
        "class": [`${prefix}-dropdown`, ctl.overlayClass],
        "style": ctl.overlayStyle,
        "ref": overlayRef
      }, [createVNode("div", {
        "class": `${prefix}-dropdown-overlay`
      }, [slotOverlay instanceof Array ? slotOverlay[0] : slotOverlay])]);
      return [trigger, overlay];
    };
  }
});
var props = {
  title: {
    type: String,
    default: ""
  },
  visible: {
    type: Boolean,
    default: void 0
  },
  // 展示在工具栏的内容，通常是个图标
  trigger: {
    type: [String, Object],
    default: void 0
  },
  onChange: {
    type: Function,
    default: void 0
  },
  // 下拉框中的内容
  overlay: {
    type: [String, Object],
    default: void 0
  },
  /**
   * ==没有意义，仅用于规避克隆组件自动嵌入insert方法时，传入的是该组件而产生的waring
   */
  insert: {
    type: Function,
    default: void 0
  },
  language: {
    type: String,
    default: void 0
  },
  theme: {
    type: String,
    default: void 0
  },
  previewTheme: {
    type: String,
    default: void 0
  },
  codeTheme: {
    type: String,
    default: void 0
  },
  /**
   * ==结束
   */
  default: {
    type: [String, Object],
    default: void 0
  }
};
var DropdownToolbar = defineComponent({
  name: "DropdownToolbar",
  props,
  emits: ["onChange"],
  setup(props22, ctx) {
    const editorId = inject("editorId");
    return () => {
      const Trigger = getSlot({
        props: props22,
        ctx
      }, "trigger");
      const Overlay = getSlot({
        props: props22,
        ctx
      }, "overlay");
      const Default = getSlot({
        props: props22,
        ctx
      });
      return createVNode(Dropdown, {
        "relative": `#${editorId}-toolbar-wrapper`,
        "visible": props22.visible,
        "onChange": (v) => {
          if (props22.onChange instanceof Function) {
            props22.onChange(v);
          } else {
            ctx.emit("onChange", v);
          }
        },
        "overlay": Overlay
      }, {
        default: () => [createVNode("div", {
          "class": `${prefix}-toolbar-item`,
          "title": props22.title || ""
        }, [Trigger, Default])]
      });
    };
  }
});
DropdownToolbar.install = (app) => {
  app.component(DropdownToolbar.name, DropdownToolbar);
  return app;
};

// node_modules/md-editor-v3/lib/es/chunks/event-name.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var Bus = class {
  constructor() {
    __publicField2(this, "pools", {});
  }
  // 移除事件监听
  remove(race, name, func) {
    const targetRace = this.pools[race];
    const events = targetRace && this.pools[race][name];
    if (events) {
      this.pools[race][name] = events.filter((item) => item !== func);
    }
  }
  // 清空全部事件，由于单一实例，多次注册会被共享内容
  clear(race) {
    this.pools[race] = {};
  }
  // 注册事件监听
  on(race, event) {
    if (!this.pools[race]) {
      this.pools[race] = {};
    }
    if (!this.pools[race][event.name]) {
      this.pools[race][event.name] = [];
    }
    this.pools[race][event.name].push(event.callback);
    return this.pools[race][event.name].includes(event.callback);
  }
  // 触发事件
  emit(race, name, ...params) {
    if (!this.pools[race]) {
      this.pools[race] = {};
    }
    const targetRace = this.pools[race];
    const events = targetRace[name];
    if (events) {
      events.forEach((item) => {
        try {
          item(...params);
        } catch (error) {
          console.error(`${name} monitor event exception！`, error);
        }
      });
    }
  }
};
var bus = new Bus();
var ON_SAVE = "onSave";
var CHANGE_CATALOG_VISIBLE = "changeCatalogVisible";
var CHANGE_FULL_SCREEN = "changeFullscreen";
var PAGE_FULL_SCREEN_CHANGED = "pageFullscreenChanged";
var FULL_SCREEN_CHANGED = "fullscreenChanged";
var PREVIEW_CHANGED = "previewChanged";
var PREVIEW_ONLY_CHANGED = "previewOnlyChanged";
var HTML_PREVIEW_CHANGED = "htmlPreviewChanged";
var CATALOG_VISIBLE_CHANGED = "catalogVisibleChanged";
var BUILD_FINISHED = "buildFinished";
var ERROR_CATCHER = "errorCatcher";
var REPLACE = "replace";
var UPLOAD_IMAGE = "uploadImage";
var OPEN_MODALS = "openModals";
var CTRL_Z = "ctrlZ";
var CTRL_SHIFT_Z = "ctrlShiftZ";
var CATALOG_CHANGED = "catalogChanged";
var PUSH_CATALOG = "pushCatalog";
var RERENDER = "rerender";
var EVENT_LISTENER = "eventListener";
var TASK_STATE_CHANGED = "taskStateChanged";

// node_modules/md-editor-v3/lib/es/chunks/dom.mjs
var keyMove = (trigger, moveHandler) => {
  const triggerMouseDown = (mdown) => {
    const parent = trigger.parentElement || document.body;
    const width = parent.offsetWidth;
    const height = parent.offsetHeight;
    const { clientWidth, clientHeight } = document.documentElement;
    const x2 = mdown.offsetX;
    const y2 = mdown.offsetY;
    const mouseMoveHandler = (e2) => {
      let tx = e2.x + document.body.scrollLeft - document.body.clientLeft - x2;
      let ty = e2.y + document.body.scrollTop - document.body.clientTop - y2;
      tx = tx < 1 ? 1 : tx < clientWidth - width - 1 ? tx : clientWidth - width - 1;
      ty = ty < 1 ? 1 : ty < clientHeight - height - 1 ? ty : clientHeight - height - 1;
      if (moveHandler) {
        moveHandler(tx, ty);
      } else {
        parent.style.left = `${tx}px`;
        parent.style.top = `${ty}px`;
      }
    };
    document.addEventListener("mousemove", mouseMoveHandler);
    const mouseUpHandler = () => {
      document.removeEventListener("mousemove", mouseMoveHandler);
      document.removeEventListener("mouseup", mouseUpHandler);
    };
    document.addEventListener("mouseup", mouseUpHandler);
  };
  trigger.addEventListener("mousedown", triggerMouseDown);
  return () => {
    trigger.removeEventListener("mousedown", triggerMouseDown);
  };
};
var appendHandler = (tagName, attributes, checkKey = "") => {
  var _a3;
  const insertedEle = document.getElementById(attributes.id);
  if (!insertedEle) {
    const attrsCopy = { ...attributes };
    attrsCopy.onload = null;
    const ele = createHTMLElement(tagName, attrsCopy);
    attributes.onload && ele.addEventListener("load", attributes.onload);
    document.head.appendChild(ele);
  } else if (checkKey !== "") {
    if (Reflect.get(window, checkKey)) {
      (_a3 = attributes.onload) == null ? void 0 : _a3.call(insertedEle, new Event("load"));
    } else {
      attributes.onload && insertedEle.addEventListener("load", attributes.onload);
    }
  }
};
var updateHandler = (tagName, attributes) => {
  const insertedEle = document.getElementById(attributes.id);
  insertedEle == null ? void 0 : insertedEle.remove();
  appendHandler(tagName, attributes);
};
var createHTMLElement = (tagName, attributes) => {
  const element = document.createElement(tagName);
  Object.keys(attributes).forEach((key) => {
    if (attributes[key] !== void 0) {
      element[key] = attributes[key];
    }
  });
  return element;
};
var zoomMermaid = /* @__PURE__ */ (() => {
  const addEvent = (container) => {
    if (!container) {
      return;
    }
    const content = container.firstChild;
    let scale = 1;
    let posX = 0;
    let posY = 0;
    let isDragging = false;
    let startX, startY;
    let initialDistance;
    let initialScale = 1;
    const updateTransform = () => {
      content.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    };
    container.addEventListener(
      "touchstart",
      (event) => {
        if (event.touches.length === 1) {
          isDragging = true;
          startX = event.touches[0].clientX - posX;
          startY = event.touches[0].clientY - posY;
        } else if (event.touches.length === 2) {
          initialDistance = Math.hypot(
            event.touches[0].clientX - event.touches[1].clientX,
            event.touches[0].clientY - event.touches[1].clientY
          );
          initialScale = scale;
        }
      },
      { passive: false }
    );
    container.addEventListener(
      "touchmove",
      (event) => {
        event.preventDefault();
        if (isDragging && event.touches.length === 1) {
          posX = event.touches[0].clientX - startX;
          posY = event.touches[0].clientY - startY;
          updateTransform();
        } else if (event.touches.length === 2) {
          const newDistance = Math.hypot(
            event.touches[0].clientX - event.touches[1].clientX,
            event.touches[0].clientY - event.touches[1].clientY
          );
          const scaleChange = newDistance / initialDistance;
          const previousScale = scale;
          scale = initialScale * (1 + (scaleChange - 1));
          const centerX = (event.touches[0].clientX + event.touches[1].clientX) / 2;
          const centerY = (event.touches[0].clientY + event.touches[1].clientY) / 2;
          const rect = content.getBoundingClientRect();
          const relativeX = (centerX - rect.left) / previousScale;
          const relativeY = (centerY - rect.top) / previousScale;
          posX -= relativeX * (scale - previousScale);
          posY -= relativeY * (scale - previousScale);
          updateTransform();
        }
      },
      { passive: false }
    );
    container.addEventListener("touchend", () => {
      isDragging = false;
    });
    container.addEventListener(
      "wheel",
      (event) => {
        event.preventDefault();
        const scaleAmount = 0.02;
        const previousScale = scale;
        if (event.deltaY < 0) {
          scale += scaleAmount;
        } else {
          scale = Math.max(0.1, scale - scaleAmount);
        }
        const rect = content.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        posX -= mouseX / previousScale * (scale - previousScale);
        posY -= mouseY / previousScale * (scale - previousScale);
        updateTransform();
      },
      { passive: false }
    );
    container.addEventListener("mousedown", (event) => {
      isDragging = true;
      startX = event.clientX - posX;
      startY = event.clientY - posY;
    });
    container.addEventListener("mousemove", (event) => {
      if (isDragging) {
        posX = event.clientX - startX;
        posY = event.clientY - startY;
        updateTransform();
      }
    });
    container.addEventListener("mouseup", () => {
      isDragging = false;
    });
    container.addEventListener("mouseleave", () => {
      isDragging = false;
    });
  };
  const handler = (containers) => {
    containers.forEach((mm) => {
      addEvent(mm);
    });
  };
  return handler;
})();

// node_modules/md-editor-v3/lib/es/chunks/index5.mjs
var base642File = (base64, fileName = "image.png") => {
  const arr = base64.split(",");
  const regResult = arr[0].match(/:(.*?);/);
  if (regResult) {
    const mime = regResult[1];
    const bstr = atob(arr[1]);
    let n2 = bstr.length;
    const u8arr = new Uint8Array(n2);
    while (n2--) {
      u8arr[n2] = bstr.charCodeAt(n2);
    }
    return new File([u8arr], fileName, { type: mime });
  }
  return null;
};
var generateCodeRowNumber = (code, source) => {
  if (!code) {
    return code;
  }
  const list = source.split("\n");
  const rowNumberList = ['<span rn-wrapper aria-hidden="true">'];
  list.forEach(() => {
    rowNumberList.push("<span></span>");
  });
  rowNumberList.push("</span>");
  return `<span class="${prefix}-code-block">${code}</span>${rowNumberList.join("")}`;
};
var getRelativeTop = (element, container) => {
  if (!element || !container) {
    return 0;
  }
  const eleRect = element == null ? void 0 : element.getBoundingClientRect();
  if (container === document.documentElement) {
    return eleRect.top - container.clientTop;
  }
  const conRect = container == null ? void 0 : container.getBoundingClientRect();
  return eleRect.top - conRect.top;
};
var getNextId = /* @__PURE__ */ (() => {
  let count = 0;
  return (prefix2) => {
    return prefix2 + ++count;
  };
})();
var getZIndexIncrement = /* @__PURE__ */ (() => {
  let startIndex = 0;
  return () => {
    return ++startIndex;
  };
})();

// node_modules/md-editor-v3/lib/es/chunks/index4.mjs
var Icon$1 = defineComponent({
  props: {
    name: {
      type: String,
      default: ""
    }
  },
  setup(props22) {
    return () => {
      return configOption.iconfontType === "svg" ? createVNode("svg", {
        "class": `${prefix}-icon`,
        "aria-hidden": "true"
      }, [createVNode("use", {
        "xlink:href": `#${prefix}-icon-${props22.name}`
      }, null)]) : createVNode("i", {
        "class": `${prefix}-iconfont ${prefix}-icon-${props22.name}`
      }, null);
    };
  }
});
var Icon = defineComponent({
  props: {
    name: {
      type: String,
      default: ""
    }
  },
  setup(props22) {
    const customIcon = inject("customIcon");
    return () => {
      const item = customIcon.value[props22.name];
      if (typeof item === "object") {
        return typeof item.component === "object" ? h(item.component, item.props) : createVNode("span", {
          "innerHTML": item.component
        }, null);
      }
      return createVNode(Icon$1, {
        "name": props22.name
      }, null);
    };
  }
});
var props2 = {
  title: {
    type: String,
    default: ""
  },
  visible: {
    type: Boolean,
    default: false
  },
  width: {
    type: String,
    default: "auto"
  },
  height: {
    type: String,
    default: "auto"
  },
  onClose: {
    type: Function
  },
  showAdjust: {
    type: Boolean,
    default: false
  },
  isFullscreen: {
    type: Boolean,
    default: false
  },
  onAdjust: {
    type: Function,
    default: () => {
    }
  },
  class: {
    type: String
  },
  style: {
    type: [Object, String],
    default: () => ({})
  },
  showMask: {
    type: Boolean,
    default: true
  }
};
var MdModal = defineComponent({
  name: "MdModal",
  props: props2,
  emits: ["onClose"],
  setup(props22, ctx) {
    const themeRef = inject("theme");
    const rootRef = inject("rootRef");
    const modalVisible = ref(props22.visible);
    const modalClass = ref([`${prefix}-modal`]);
    const modalRef = ref();
    const modalHeaderRef = ref();
    const bodyRef = ref();
    const containerRef = shallowRef();
    let keyMoveClear = () => {
    };
    const state = reactive({
      maskStyle: {
        zIndex: -1
      },
      modalStyle: {
        zIndex: -1
      },
      initPos: {
        left: "0px",
        top: "0px"
      },
      historyPos: {
        left: "0px",
        top: "0px"
      }
    });
    const innerSize = computed(() => {
      if (props22.isFullscreen) {
        return {
          width: "100%",
          height: "100%"
        };
      } else {
        return {
          width: props22.width,
          height: props22.height
        };
      }
    });
    watch(() => props22.isFullscreen, (nVal) => {
      if (nVal) {
        keyMoveClear();
      } else {
        nextTick(() => {
          keyMoveClear = keyMove(modalHeaderRef.value, (left, top) => {
            state.initPos.left = left + "px";
            state.initPos.top = top + "px";
          });
        });
      }
    });
    watch(() => props22.visible, (nVal) => {
      if (nVal) {
        state.maskStyle.zIndex = configOption.editorConfig.zIndex + getZIndexIncrement();
        state.modalStyle.zIndex = configOption.editorConfig.zIndex + getZIndexIncrement();
        modalClass.value.push("zoom-in");
        modalVisible.value = nVal;
        nextTick(() => {
          const halfWidth = modalRef.value.offsetWidth / 2;
          const halfHeight = modalRef.value.offsetHeight / 2;
          const halfClientWidth = document.documentElement.clientWidth / 2;
          const halfClientHeight = document.documentElement.clientHeight / 2;
          state.initPos.left = halfClientWidth - halfWidth + "px";
          state.initPos.top = halfClientHeight - halfHeight + "px";
          if (!props22.isFullscreen) {
            keyMoveClear = keyMove(modalHeaderRef.value, (left, top) => {
              state.initPos.left = left + "px";
              state.initPos.top = top + "px";
            });
          }
        });
        setTimeout(() => {
          modalClass.value = modalClass.value.filter((item) => item !== "zoom-in");
        }, 140);
      } else {
        modalClass.value.push("zoom-out");
        keyMoveClear();
        setTimeout(() => {
          modalClass.value = modalClass.value.filter((item) => item !== "zoom-out");
          modalVisible.value = nVal;
        }, 130);
      }
    });
    const internalStyle = computed(() => ({
      display: modalVisible.value ? "block" : "none"
    }));
    const combinedStyle = computed(() => {
      if (typeof props22.style === "string") {
        return [props22.style, internalStyle.value].join("; ");
      } else if (props22.style instanceof Object) {
        return {
          ...internalStyle.value,
          ...props22.style
        };
      } else {
        return internalStyle.value;
      }
    });
    onMounted(() => {
      var _a3;
      const rootNode = (_a3 = rootRef.value) == null ? void 0 : _a3.getRootNode();
      bodyRef.value = rootNode instanceof Document ? document.body : rootNode;
    });
    return () => {
      const slotDefault = getSlot({
        ctx
      });
      const slotTitle = getSlot({
        props: props22,
        ctx
      }, "title");
      return bodyRef.value ? createVNode(Teleport, {
        "to": bodyRef.value
      }, {
        default: () => [createVNode("div", {
          "ref": containerRef,
          "class": `${prefix}-modal-container`,
          "data-theme": themeRef.value
        }, [createVNode("div", {
          "class": props22.class,
          "style": combinedStyle.value
        }, [props22.showMask && createVNode("div", {
          "class": `${prefix}-modal-mask`,
          "style": state.maskStyle,
          "onClick": () => {
            if (props22.onClose) {
              props22.onClose();
            } else {
              ctx.emit("onClose");
            }
          }
        }, null), createVNode("div", {
          "class": modalClass.value,
          "style": {
            ...state.modalStyle,
            ...state.initPos,
            ...innerSize.value
          },
          "ref": modalRef
        }, [createVNode("div", {
          "class": `${prefix}-modal-header`,
          "ref": modalHeaderRef
        }, [slotTitle || ""]), createVNode("div", {
          "class": `${prefix}-modal-body`
        }, [slotDefault]), createVNode("div", {
          "class": `${prefix}-modal-func`
        }, [props22.showAdjust && createVNode("div", {
          "class": `${prefix}-modal-adjust`,
          "onClick": (e2) => {
            e2.stopPropagation();
            if (!props22.isFullscreen) {
              state.historyPos = state.initPos;
              state.initPos = {
                left: "0",
                top: "0"
              };
            } else {
              state.initPos = state.historyPos;
            }
            props22.onAdjust(!props22.isFullscreen);
          }
        }, [createVNode(Icon, {
          "name": props22.isFullscreen ? "suoxiao" : "fangda"
        }, null)]), createVNode("div", {
          "class": `${prefix}-modal-close`,
          "onClick": (e2) => {
            e2.stopPropagation();
            if (props22.onClose) {
              props22.onClose();
            } else {
              ctx.emit("onClose");
            }
          }
        }, [createVNode(Icon, {
          "name": "close"
        }, null)])])])])])]
      }) : "";
    };
  }
});
MdModal.install = (app) => {
  app.component(MdModal.name, MdModal);
  return app;
};

// node_modules/md-editor-v3/lib/es/chunks/index3.mjs
var DATA_LINE_SELECTOR = `.${prefix}-preview > [data-line]`;
var getComputedStyleNum = (ele, key) => {
  return +getComputedStyle(ele).getPropertyValue(key).replace("px", "");
};
var scrollAutoWithScale = (pEle, cEle) => {
  const addEvent = k(() => {
    pEle.removeEventListener("scroll", scrollHandler);
    pEle.addEventListener("scroll", scrollHandler);
    cEle.removeEventListener("scroll", scrollHandler);
    cEle.addEventListener("scroll", scrollHandler);
  }, 50);
  const scrollHandler = (e2) => {
    const pHeight = pEle.clientHeight;
    const cHeight = cEle.clientHeight;
    const pScrollHeight = pEle.scrollHeight;
    const cScrollHeight = cEle.scrollHeight;
    const scale = (pScrollHeight - pHeight) / (cScrollHeight - cHeight);
    if (e2.target === pEle) {
      cEle.removeEventListener("scroll", scrollHandler);
      cEle.scrollTo({
        top: pEle.scrollTop / scale
        // behavior: 'smooth'
      });
      addEvent();
    } else {
      pEle.removeEventListener("scroll", scrollHandler);
      pEle.scrollTo({
        top: cEle.scrollTop * scale
        // behavior: 'smooth'
      });
      addEvent();
    }
  };
  return [
    () => {
      addEvent().finally(() => {
        pEle.dispatchEvent(new Event("scroll"));
      });
    },
    () => {
      pEle.removeEventListener("scroll", scrollHandler);
      cEle.removeEventListener("scroll", scrollHandler);
    }
  ];
};
var scrollAuto = (pEle, cEle, codeMirrorUt) => {
  const { view } = codeMirrorUt;
  const smoothScroll = x();
  const getTopByLine = (line) => {
    return view.lineBlockAt(view.state.doc.line(line + 1).from).top;
  };
  const getBottomByLine = (line) => {
    return view.lineBlockAt(view.state.doc.line(line + 1).from).bottom;
  };
  let blockMap = [];
  let elesHasLineNumber = [];
  let startLines = [];
  const buildMap = () => {
    blockMap = [];
    elesHasLineNumber = Array.from(
      cEle.querySelectorAll(DATA_LINE_SELECTOR)
    );
    startLines = elesHasLineNumber.map((item) => Number(item.dataset.line));
    const tempStartLines = [...startLines];
    const { lines } = view.state.doc;
    let start = tempStartLines.shift() || 0;
    let end = tempStartLines.shift() || lines;
    for (let i2 = 0; i2 < lines; i2++) {
      if (i2 === end) {
        start = i2;
        end = tempStartLines.shift() || lines;
      }
      blockMap.push({
        start,
        end: end - 1
      });
    }
  };
  const getLineNumber = (pMaxScrollLength, cMaxScrollLength) => {
    let lineNumer = 1;
    for (let i2 = elesHasLineNumber.length - 1; i2 - 1 >= 0; i2--) {
      const curr = elesHasLineNumber[i2];
      const sibling = elesHasLineNumber[i2 - 1];
      if (curr.offsetTop + curr.offsetHeight > cMaxScrollLength && sibling.offsetTop < cMaxScrollLength) {
        lineNumer = Number(sibling.dataset.line);
        break;
      }
    }
    for (let i2 = blockMap.length - 1; i2 >= 0; i2--) {
      const itemBottom = getBottomByLine(blockMap[i2].end);
      const itemTop = getTopByLine(blockMap[i2].start);
      if (itemBottom > pMaxScrollLength && itemTop <= pMaxScrollLength) {
        lineNumer = lineNumer < blockMap[i2].start ? lineNumer : blockMap[i2].start;
        break;
      }
    }
    return lineNumer;
  };
  let pLock = 0;
  let cLock = 0;
  const pEleHandler = () => {
    var _a3, _b2, _c;
    if (cLock !== 0) {
      return false;
    }
    pLock++;
    const { scrollDOM, contentHeight } = view;
    let cElePaddingTop = getComputedStyleNum(cEle, "padding-top");
    const blockInfo = view.lineBlockAtHeight(scrollDOM.scrollTop);
    const { number: currLine } = view.state.doc.lineAt(blockInfo.from);
    const blockData = blockMap[currLine - 1];
    if (!blockData) {
      return false;
    }
    let scale = 1;
    const startEle = cEle.querySelector(`[data-line="${blockData.start}"]`) || ((_a3 = cEle.firstElementChild) == null ? void 0 : _a3.firstElementChild);
    const endEle = cEle.querySelector(`[data-line="${blockData.end + 1}"]`) || ((_b2 = cEle.lastElementChild) == null ? void 0 : _b2.lastElementChild);
    const pMaxScrollLength = scrollDOM.scrollHeight - scrollDOM.clientHeight;
    const cMaxScrollLength = cEle.scrollHeight - cEle.clientHeight;
    let startTop = getTopByLine(blockData.start);
    let endBottom = getBottomByLine(blockData.end);
    let startEleOffetTop = startEle.offsetTop;
    let blockHeight = endEle.offsetTop - startEleOffetTop;
    if (startTop === 0) {
      startEleOffetTop = 0;
      if (startEle === endEle) {
        cElePaddingTop = 0;
        endBottom = contentHeight - scrollDOM.offsetHeight;
        blockHeight = cMaxScrollLength;
      } else {
        blockHeight = endEle.offsetTop;
      }
    }
    scale = (scrollDOM.scrollTop - startTop) / (endBottom - startTop);
    const endElePos = endEle == ((_c = cEle.lastElementChild) == null ? void 0 : _c.lastElementChild) ? endEle.offsetTop + endEle.clientHeight : endEle.offsetTop;
    if (endBottom >= pMaxScrollLength || endElePos > cMaxScrollLength) {
      const lineNumer = getLineNumber(pMaxScrollLength, cMaxScrollLength);
      startTop = getTopByLine(lineNumer);
      scale = (scrollDOM.scrollTop - startTop) / (pMaxScrollLength - startTop);
      const _startEle = cEle.querySelector(`[data-line="${lineNumer}"]`);
      if (startTop > 0 && _startEle) {
        startEleOffetTop = _startEle.offsetTop;
      }
      blockHeight = cMaxScrollLength - startEleOffetTop + getComputedStyleNum(cEle, "padding-top");
    }
    const scrollToTop = startEleOffetTop - cElePaddingTop + blockHeight * scale;
    smoothScroll(cEle, scrollToTop, () => {
      pLock--;
    });
  };
  const cEleHandler = () => {
    var _a3, _b2, _c, _d, _e, _f;
    if (pLock !== 0) {
      return;
    }
    cLock++;
    const { scrollDOM } = view;
    const cScrollTop = cEle.scrollTop;
    const cScrollHeight = cEle.scrollHeight;
    const pMaxScrollLength = scrollDOM.scrollHeight - scrollDOM.clientHeight;
    const cMaxScrollLength = cEle.scrollHeight - cEle.clientHeight;
    let realEleStart = (_a3 = cEle.firstElementChild) == null ? void 0 : _a3.firstElementChild;
    let realEleEnd = (_b2 = cEle.firstElementChild) == null ? void 0 : _b2.lastElementChild;
    if (startLines.length > 0) {
      let virtualLine = Math.ceil(
        startLines[startLines.length - 1] * (cScrollTop / cScrollHeight)
      );
      let startLineIndex = startLines.findLastIndex((value) => value <= virtualLine);
      startLineIndex = startLineIndex === -1 ? 0 : startLineIndex;
      virtualLine = startLines[startLineIndex];
      for (let i2 = startLineIndex; i2 >= 0 && i2 < startLines.length; ) {
        const currentElementTop = elesHasLineNumber[i2].offsetTop;
        if (currentElementTop > cScrollTop) {
          if (i2 - 1 >= 0) {
            i2--;
            continue;
          }
          virtualLine = -1;
          startLineIndex = i2;
          break;
        } else {
          if (i2 + 1 < startLines.length && elesHasLineNumber[i2 + 1].offsetTop < cScrollTop) {
            i2++;
            continue;
          }
          virtualLine = startLines[i2];
          startLineIndex = i2;
          break;
        }
      }
      switch (startLineIndex) {
        case -1: {
          realEleStart = (_c = cEle.firstElementChild) == null ? void 0 : _c.firstElementChild;
          realEleEnd = elesHasLineNumber[startLineIndex];
          break;
        }
        case startLines.length - 1: {
          realEleStart = elesHasLineNumber[startLineIndex];
          realEleEnd = (_d = cEle.firstElementChild) == null ? void 0 : _d.lastElementChild;
          break;
        }
        default: {
          realEleStart = elesHasLineNumber[startLineIndex];
          realEleEnd = elesHasLineNumber[startLineIndex + 1 === elesHasLineNumber.length ? startLineIndex : startLineIndex + 1];
        }
      }
    }
    let eleStartOffsetTop = realEleStart === ((_e = cEle.firstElementChild) == null ? void 0 : _e.firstElementChild) ? 0 : realEleStart.offsetTop - getComputedStyleNum(realEleStart, "margin-top");
    let eleEndOffsetTop = realEleEnd.offsetTop;
    let scale = 0;
    const { start, end } = blockMap[Number(realEleStart.dataset.line || 0)];
    let firstLineScrollTop = getTopByLine(start);
    const endLineScrollTop = getTopByLine(
      end + 1 === view.state.doc.lines ? end : end + 1
    );
    let blockHeight = 0;
    if (endLineScrollTop > pMaxScrollLength || realEleEnd.offsetTop + realEleEnd.offsetHeight > cMaxScrollLength) {
      const lineNumer = getLineNumber(pMaxScrollLength, cMaxScrollLength);
      const _startEle = cEle.querySelector(`[data-line="${lineNumer}"]`);
      eleStartOffsetTop = _startEle ? _startEle.offsetTop - getComputedStyleNum(_startEle, "margin-top") : eleStartOffsetTop;
      firstLineScrollTop = getTopByLine(lineNumer);
      scale = (cScrollTop - eleStartOffsetTop) / (cMaxScrollLength - eleStartOffsetTop);
      blockHeight = pMaxScrollLength - firstLineScrollTop;
    } else if (realEleStart === ((_f = cEle.firstElementChild) == null ? void 0 : _f.firstElementChild)) {
      if (realEleStart === realEleEnd) {
        eleEndOffsetTop = realEleEnd.offsetTop + realEleEnd.offsetHeight + +getComputedStyle(realEleEnd).marginBottom.replace("px", "");
        blockHeight = endLineScrollTop;
      } else {
        blockHeight = endLineScrollTop;
      }
      scale = Math.max(cScrollTop / eleEndOffsetTop, 0);
    } else {
      scale = Math.max(
        (cScrollTop - eleStartOffsetTop) / (eleEndOffsetTop - eleStartOffsetTop),
        0
      );
      blockHeight = endLineScrollTop - firstLineScrollTop;
    }
    smoothScroll(pEle, firstLineScrollTop + blockHeight * scale, () => {
      cLock--;
    });
  };
  const scrollHandler = (e2) => {
    var _a3;
    const { scrollDOM, contentHeight } = view;
    const scrollDomHeight = scrollDOM.clientHeight;
    if (contentHeight <= scrollDomHeight || cEle.firstElementChild.clientHeight <= cEle.clientHeight) {
      return false;
    }
    if (view.state.doc.lines <= ((_a3 = blockMap[blockMap.length - 1]) == null ? void 0 : _a3.end)) {
      return false;
    }
    if (e2.target === pEle) {
      pEleHandler();
    } else {
      cEleHandler();
    }
  };
  return [
    () => {
      buildMap();
      pEle.addEventListener("scroll", scrollHandler);
      cEle.addEventListener("scroll", scrollHandler);
      pEle.dispatchEvent(new Event("scroll"));
    },
    () => {
      pEle.removeEventListener("scroll", scrollHandler);
      cEle.removeEventListener("scroll", scrollHandler);
    }
  ];
};
var props$12 = {
  tocItem: {
    type: Object,
    default: () => ({})
  },
  mdHeadingId: {
    type: Function,
    default: () => {
    }
  },
  onClick: {
    type: Function,
    default: () => {
    }
  },
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  }
};
var CatalogLink = defineComponent({
  props: props$12,
  setup(props22) {
    const scrollElementRef = inject("scrollElementRef");
    const rootNodeRef = inject("roorNodeRef");
    return () => {
      const {
        tocItem,
        mdHeadingId: mdHeadingId2,
        onClick,
        scrollElementOffsetTop
      } = props22;
      return createVNode("div", {
        "class": [`${prefix}-catalog-link`, tocItem.active && `${prefix}-catalog-active`],
        "onClick": (e2) => {
          onClick(e2, tocItem);
          e2.stopPropagation();
          const id = mdHeadingId2(tocItem.text, tocItem.level, tocItem.index);
          const targetHeadEle = rootNodeRef.value.getElementById(id);
          const scrollContainer = scrollElementRef.value;
          if (targetHeadEle && scrollContainer) {
            let par = targetHeadEle.offsetParent;
            let offsetTop = targetHeadEle.offsetTop;
            if (scrollContainer.contains(par)) {
              while (par && scrollContainer != par) {
                offsetTop += par == null ? void 0 : par.offsetTop;
                par = par == null ? void 0 : par.offsetParent;
              }
            }
            const pel = targetHeadEle.previousElementSibling;
            let currMarginTop = 0;
            if (!pel) {
              currMarginTop = getComputedStyleNum(targetHeadEle, "margin-top");
            }
            scrollContainer == null ? void 0 : scrollContainer.scrollTo({
              top: offsetTop - scrollElementOffsetTop - currMarginTop,
              behavior: "smooth"
            });
          }
        }
      }, [createVNode("span", {
        "title": tocItem.text
      }, [tocItem.text]), createVNode("div", {
        "class": `${prefix}-catalog-wrapper`
      }, [tocItem.children && tocItem.children.map((item) => createVNode(CatalogLink, {
        "mdHeadingId": mdHeadingId2,
        "key": `${tocItem.text}-link-${item.level}-${item.text}`,
        "tocItem": item,
        "onClick": onClick,
        "scrollElementOffsetTop": scrollElementOffsetTop
      }, null))])]);
    };
  }
});
var props3 = {
  /**
   * 编辑器的Id，务必与需要绑定的编辑器Id相同
   */
  editorId: {
    type: String,
    default: void 0
  },
  class: {
    type: String,
    default: ""
  },
  mdHeadingId: {
    type: Function,
    default: (text) => text
  },
  /**
   * 指定滚动的容器，选择器需带上对应的符号，默认预览框
   * 元素必须定位！！！！！！
   *
   * 默认：#md-editor-preview-wrapper
   */
  scrollElement: {
    type: [String, Object],
    default: void 0
  },
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 高亮标题相对滚动容器顶部偏移量，即距离该值时，高亮当前目录菜单项
   *
   * 默认：20px
   */
  offsetTop: {
    type: Number,
    default: 20
  },
  /**
   * 滚动区域的固定顶部高度
   *
   * 默认：0
   */
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Function,
    default: void 0
  },
  onActive: {
    type: Function,
    default: void 0
  },
  /**
   * 滚动容器是否在web component中，默认不在
   *
   * 在其中的话通过document查询不到
   */
  isScrollElementInShadow: {
    type: Boolean,
    default: false
  }
};
var MdCatalog = defineComponent({
  name: "MdCatalog",
  props: props3,
  emits: ["onClick", "onActive"],
  setup(props22, ctx) {
    const editorId = props22.editorId;
    const defaultScrollElement = `#${editorId}-preview-wrapper`;
    const state = reactive({
      list: [],
      show: false,
      scrollElement: props22.scrollElement || defaultScrollElement
    });
    const activeItem = shallowRef();
    const catalogRef = ref();
    const scrollElementRef = ref();
    const scrollContainerRef = ref();
    const rootNodeRef = ref();
    provide("scrollElementRef", scrollElementRef);
    provide("roorNodeRef", rootNodeRef);
    const catalogs = computed(() => {
      const tocItems = [];
      state.list.forEach((listItem, index2) => {
        const {
          text,
          level
        } = listItem;
        const item = {
          level,
          text,
          index: index2 + 1,
          active: activeItem.value === listItem
        };
        if (tocItems.length === 0) {
          tocItems.push(item);
        } else {
          let lastItem = tocItems[tocItems.length - 1];
          if (item.level > lastItem.level) {
            for (let i2 = lastItem.level + 1; i2 <= 6; i2++) {
              const {
                children
              } = lastItem;
              if (!children) {
                lastItem.children = [item];
                break;
              }
              lastItem = children[children.length - 1];
              if (item.level <= lastItem.level) {
                children.push(item);
                break;
              }
            }
          } else {
            tocItems.push(item);
          }
        }
      });
      return tocItems;
    });
    const getScrollElement = () => {
      var _a3;
      if (state.scrollElement instanceof HTMLElement) {
        return state.scrollElement;
      }
      let scrollRoot = document;
      if (state.scrollElement === defaultScrollElement || props22.isScrollElementInShadow) {
        scrollRoot = (_a3 = catalogRef.value) == null ? void 0 : _a3.getRootNode();
      }
      return scrollRoot.querySelector(state.scrollElement);
    };
    const findActiveHeading = (list) => {
      if (list.length === 0) {
        state.list = [];
        return false;
      }
      const {
        activeHead
      } = list.reduce((activeData, link, index2) => {
        var _a3;
        const linkEle = (_a3 = rootNodeRef.value) == null ? void 0 : _a3.getElementById(props22.mdHeadingId(link.text, link.level, index2 + 1));
        if (linkEle instanceof HTMLElement) {
          const relativeTop = getRelativeTop(linkEle, scrollElementRef.value);
          if (relativeTop < props22.offsetTop && relativeTop > activeData.minTop) {
            return {
              activeHead: link,
              minTop: relativeTop
            };
          }
        }
        return activeData;
      }, {
        activeHead: list[0],
        minTop: Number.MIN_SAFE_INTEGER
      });
      activeItem.value = activeHead;
      state.list = list;
    };
    const scrollHandler = () => {
      findActiveHeading(state.list);
    };
    const catalogChangedHandler = (_list) => {
      var _a3, _b2;
      const scrollElement = getScrollElement();
      scrollElementRef.value = scrollElement;
      scrollContainerRef.value = scrollElement === document.documentElement ? document : scrollElement;
      (_a3 = scrollContainerRef.value) == null ? void 0 : _a3.removeEventListener("scroll", scrollHandler);
      findActiveHeading(_list);
      (_b2 = scrollContainerRef.value) == null ? void 0 : _b2.addEventListener("scroll", scrollHandler);
    };
    watch(() => activeItem.value, (nVal) => {
      const activeHeading = nVal ? {
        ...nVal
      } : void 0;
      if (props22.onActive) {
        props22.onActive(activeHeading);
      } else {
        ctx.emit("onActive", activeHeading);
      }
    });
    onMounted(() => {
      rootNodeRef.value = catalogRef.value.getRootNode();
      bus.on(editorId, {
        name: CATALOG_CHANGED,
        callback: catalogChangedHandler
      });
      bus.emit(editorId, PUSH_CATALOG);
    });
    onBeforeUnmount(() => {
      var _a3;
      bus.remove(editorId, CATALOG_CHANGED, catalogChangedHandler);
      (_a3 = scrollContainerRef.value) == null ? void 0 : _a3.removeEventListener("scroll", scrollHandler);
    });
    return () => createVNode("div", {
      "class": [`${prefix}-catalog`, props22.theme === "dark" && `${prefix}-catalog-dark`, props22.class || ""],
      "ref": catalogRef
    }, [catalogs.value.map((item) => {
      return createVNode(CatalogLink, {
        "mdHeadingId": props22.mdHeadingId,
        "tocItem": item,
        "key": `link-${item.level}-${item.text}`,
        "onClick": (e2, t2) => {
          if (props22.onClick) {
            props22.onClick(e2, t2);
          } else {
            ctx.emit("onClick", e2, t2);
          }
        },
        "scrollElementOffsetTop": props22.scrollElementOffsetTop
      }, null);
    })]);
  }
});
MdCatalog.install = (app) => {
  app.component(MdCatalog.name, MdCatalog);
  return app;
};

// node_modules/@codemirror/commands/dist/index.js
var toggleComment = (target) => {
  let { state } = target, line = state.doc.lineAt(state.selection.main.from), config2 = getConfig(target.state, line.from);
  return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let tr = f(option, state);
    if (!tr)
      return false;
    dispatch(state.update(tr));
    return true;
  };
}
var toggleLineComment = command(
  changeLineComment,
  0
  /* CommentOption.Toggle */
);
var lineComment = command(
  changeLineComment,
  1
  /* CommentOption.Comment */
);
var lineUncomment = command(
  changeLineComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockComment = command(
  changeBlockComment,
  0
  /* CommentOption.Toggle */
);
var blockComment = command(
  changeBlockComment,
  1
  /* CommentOption.Comment */
);
var blockUncomment = command(
  changeBlockComment,
  2
  /* CommentOption.Uncomment */
);
var toggleBlockCommentByLine = command(
  (o, s) => changeBlockComment(o, s, selectedLineRanges(s)),
  0
  /* CommentOption.Toggle */
);
function getConfig(state, pos) {
  let data = state.languageDataAt("commentTokens", pos);
  return data.length ? data[0] : {};
}
var SearchMargin = 50;
function findBlockComment(state, { open, close }, from, to) {
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (let r2 of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r2.from);
    let toLine = r2.to <= fromLine.to ? fromLine : state.doc.lineAt(r2.to);
    if (toLine.from > fromLine.from && toLine.from == r2.to)
      toLine = r2.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r2.to - 1);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from)
      ranges[last].to = toLine.to;
    else
      ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges = state.selection.ranges) {
  let tokens = ranges.map((r2) => getConfig(state, r2.from).block);
  if (!tokens.every((c) => c))
    return null;
  let comments = ranges.map((r2, i2) => findBlockComment(state, tokens[i2], r2.from, r2.to));
  if (option != 2 && !comments.every((c) => c)) {
    return { changes: state.changes(ranges.map((range, i2) => {
      if (comments[i2])
        return [];
      return [{ from: range.from, insert: tokens[i2].open + " " }, { from: range.to, insert: " " + tokens[i2].close }];
    })) };
  } else if (option != 1 && comments.some((c) => c)) {
    let changes = [];
    for (let i2 = 0, comment; i2 < comments.length; i2++)
      if (comment = comments[i2]) {
        let token = tokens[i2], { open, close } = comment;
        changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from, to } of ranges) {
    let startI = lines.length, minIndent = 1e9;
    let token = getConfig(state, from).line;
    if (!token)
      continue;
    for (let pos = from; pos <= to; ) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty2 = indent == line.length;
        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line, comment, token, indent, empty: empty2, single: false });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i2 = startI; i2 < lines.length; i2++)
        if (lines[i2].indent < lines[i2].line.text.length)
          lines[i2].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (let { line, token, indent, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line.from + indent, insert: token + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
    let changes = [];
    for (let { line, comment, token } of lines)
      if (comment >= 0) {
        let from = line.from + comment, to = from + token.length;
        if (line.text[to - line.from] == " ")
          to++;
        changes.push({ from, to });
      }
    return { changes };
  }
  return null;
}
var fromHistory = Annotation.define();
var isolateHistory = Annotation.define();
var invertedEffects = Facet.define();
var historyConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t, isAdjacent2) => isAdjacent2
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
    });
  }
});
var historyField_ = StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config2 = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config2.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event)
      state = state.addChanges(event, time, userEvent, config2, tr);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e2) => e2.toJSON()), undone: value.undone.map((e2) => e2.toJSON()) };
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function history(config2 = {}) {
  return [
    historyField_,
    historyConfig.of(config2),
    EditorView.domEventHandlers({
      beforeinput(e2, view) {
        let command2 = e2.inputType == "historyUndo" ? undo : e2.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e2.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection2) {
  return function({ state, dispatch }) {
    if (!selection2 && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection2);
    if (!tr)
      return false;
    dispatch(tr);
    return true;
  };
}
var undo = cmd(0, false);
var redo = cmd(1, false);
var undoSelection = cmd(0, true);
var redoSelection = cmd(1, true);
function depth(side) {
  return function(state) {
    let histState = state.field(historyField_, false);
    if (!histState)
      return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
var undoDepth = depth(
  0
  /* BranchName.Done */
);
var redoDepth = depth(
  1
  /* BranchName.Undone */
);
var HistEvent = class _HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new _HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a3, _b2, _c;
    return {
      changes: (_a3 = this.changes) === null || _a3 === void 0 ? void 0 : _a3.toJSON(),
      mapped: (_b2 = this.mapped) === null || _b2 === void 0 ? void 0 : _b2.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
    };
  }
  static fromJSON(json) {
    return new _HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(tr, selection2) {
    let effects = none;
    for (let invert of tr.startState.facet(invertedEffects)) {
      let result = invert(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new _HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none);
  }
  static selection(selections) {
    return new _HistEvent(void 0, none, void 0, void 0, selections);
  }
};
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a, b) {
  let ranges = [], isAdjacent2 = false;
  a.iterChangedRanges((f, t2) => ranges.push(f, t2));
  b.iterChangedRanges((_f, _t, f, t2) => {
    for (let i2 = 0; i2 < ranges.length; ) {
      let from = ranges[i2++], to = ranges[i2++];
      if (t2 >= from && f <= to)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a, b) {
  return a.ranges.length == b.ranges.length && a.ranges.filter((r2, i2) => r2.empty != b.ranges[i2].empty).length === 0;
}
function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b);
}
var none = [];
var MaxSelectionsPerEvent = 200;
function addSelection(branch, selection2) {
  if (!branch.length) {
    return [HistEvent.selection([selection2])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection2))
      return branch;
    sels.push(selection2);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length)
    return branch;
  let length = branch.length, selections = none;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none, extraSelections);
  if (!event.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
var joinableUserEvent = /^(input\.type|delete)($|\.)/;
var HistoryState = class _HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new _HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config2, tr) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config2.newGroupDelay && config2.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || // For compose (but not compose.start) events, always join with previous event
    userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config2.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(StateEffect.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
    } else {
      done = updateBranch(done, done.length, config2.minDepth, event);
    }
    return new _HistoryState(done, none, time, userEvent);
  }
  addSelection(selection2, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection2))
      return this;
    return new _HistoryState(addSelection(this.done, selection2), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new _HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0)
      return null;
    let event = branch[branch.length - 1], selection2 = event.selectionsAfter[0] || state.selection;
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch), selection: selection2 }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
      if (event.mapped)
        rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({ side, rest, selection: selection2 }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
};
HistoryState.empty = new HistoryState(none, none);
var historyKeymap = [
  { key: "Mod-z", run: undo, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection2) {
  return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
  let selection2 = updateSel(state.selection, how);
  if (selection2.eq(state.selection, true))
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
function rangeEnd(range, forward) {
  return EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
function cursorByGroup(view, forward) {
  return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
var segmenter = typeof Intl != "undefined" && Intl.Segmenter ? new Intl.Segmenter(void 0, { granularity: "word" }) : null;
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp))
    return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = syntaxTree(state).resolveInner(start.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start.head; ; ) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next)
      break;
    if (interestingNode(state, next, bracketProp))
      pos = next;
    else
      at = forward ? next.to : next.from;
  }
  let bracket = pos.type.prop(bracketProp), match, newPos;
  if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range) => {
    if (!range.empty)
      return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
var cursorLineUp = (view) => cursorByLine(view, false);
var cursorLineDown = (view) => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0, marginBottom = 0, height;
  if (selfScroll) {
    for (let source of view.state.facet(EditorView.scrollMargins)) {
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top)
        marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom)
        marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let { state } = view, selection2 = updateSel(state.selection, (range) => {
    return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
  });
  if (selection2.eq(state.selection))
    return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
      effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollTop });
  }
  view.dispatch(setSel(state, selection2), { effects: effect });
  return true;
}
var cursorPageUp = (view) => cursorByPage(view, false);
var cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
    moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start.head != line.from + space)
      moved = EditorSelection.cursor(line.from + space);
  }
  return moved;
}
var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
var cursorLineBoundaryLeft = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var cursorLineBoundaryRight = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
  let found = false, selection2 = updateSel(state.selection, (range) => {
    let matching = matchBrackets(state, range.head, -1) || matchBrackets(state, range.head, 1) || range.head > 0 && matchBrackets(state, range.head - 1, 1) || range.head < state.doc.length && matchBrackets(state, range.head + 1, -1);
    if (!matching || !matching.end)
      return range;
    found = true;
    let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
    return extend ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
  });
  if (!found)
    return false;
  dispatch(setSel(state, selection2));
  return true;
}
var cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
function extendSel(target, how) {
  let selection2 = updateSel(target.state.selection, (range) => {
    let head = how(range);
    return EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || void 0);
  });
  if (selection2.eq(target.state.selection))
    return false;
  target.dispatch(setSel(target.state, selection2));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range) => view.moveByChar(range, forward));
}
var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range) => view.moveByGroup(range, forward));
}
var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward));
}
var selectLineUp = (view) => selectByLine(view, false);
var selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range) => view.moveVertically(range, forward, pageInfo(view).height));
}
var selectPageUp = (view) => selectByPage(view, false);
var selectPageDown = (view) => selectByPage(view, true);
var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
var selectLineBoundaryLeft = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, !ltrAtCursor(view)));
var selectLineBoundaryRight = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, ltrAtCursor(view)));
var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
var cursorDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: 0 }));
  return true;
};
var cursorDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.doc.length }));
  return true;
};
var selectDocStart = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
var selectDocEnd = ({ state, dispatch }) => {
  dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
var selectAll = ({ state, dispatch }) => {
  dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
var selectLine = ({ state, dispatch }) => {
  let ranges = selectedLineBlocks(state).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
  dispatch(state.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
  return true;
};
var selectParentSyntax = ({ state, dispatch }) => {
  let selection2 = updateSel(state.selection, (range) => {
    let tree = syntaxTree(state), stack = tree.resolveStack(range.from, 1);
    if (range.empty) {
      let stackBefore = tree.resolveStack(range.from, -1);
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to)
        stack = stackBefore;
    }
    for (let cur = stack; cur; cur = cur.next) {
      let { node } = cur;
      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur.next)
        return EditorSelection.range(node.to, node.from);
    }
    return range;
  });
  if (selection2.eq(state.selection))
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
var simplifySelection = ({ state, dispatch }) => {
  let cur = state.selection, selection2 = null;
  if (cur.ranges.length > 1)
    selection2 = EditorSelection.create([cur.main]);
  else if (!cur.main.empty)
    selection2 = EditorSelection.create([EditorSelection.cursor(cur.main.head)]);
  if (!selection2)
    return false;
  dispatch(setSel(state, selection2));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event = "delete.selection", { state } = target;
  let changes = state.changeByRange((range) => {
    let { from, to } = range;
    if (from == to) {
      let towards = by(range);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    } else {
      from = skipAtomic(target, from, false);
      to = skipAtomic(target, to, true);
    }
    return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from, from < range.head ? -1 : 1) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos)
          pos = forward ? to : from;
      });
  return pos;
}
var deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, (range) => {
  let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i2 = 0; i2 < drop && before[before.length - 1 - i2] == " "; i2++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
    else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
      targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
var deleteCharBackward = (view) => deleteByChar(view, false, true);
var deleteCharForward = (view) => deleteByChar(view, true, false);
var deleteByGroup = (target, forward) => deleteBy(target, (range) => {
  let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar != " " || pos != range.head)
      cat = nextCat;
    pos = next;
  }
  return pos;
});
var deleteGroupBackward = (target) => deleteByGroup(target, false);
var deleteGroupForward = (target) => deleteByGroup(target, true);
var deleteToLineEnd = (view) => deleteBy(view, (range) => {
  let lineEnd = view.lineBlockAt(range.head).to;
  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
var deleteLineBoundaryBackward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
var deleteLineBoundaryForward = (view) => deleteBy(view, (range) => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
var splitLine = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    return {
      changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range.from)
    };
  });
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
var transposeChars = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range) => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length)
      return { range };
    let pos = range.from, line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
    return {
      changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
      range: EditorSelection.cursor(to)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range of state.selection.ranges) {
    let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from)
      endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r2 of block.ranges)
        ranges.push(EditorSelection.range(Math.min(state.doc.length, r2.anchor + size), Math.min(state.doc.length, r2.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r2 of block.ranges)
        ranges.push(EditorSelection.range(r2.anchor - size, r2.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
var moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
var moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
var copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
var copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
var deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
    if (from > 0)
      from--;
    else if (to < state.doc.length)
      to++;
    return { from, to };
  }));
  let selection2 = updateSel(state.selection, (range) => {
    let dist = void 0;
    if (view.lineWrapping) {
      let block = view.lineBlockAt(range.head), pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (pos)
        dist = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
    }
    return view.moveVertically(range, true, dist);
  }).map(changes);
  view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from)))
    return { from: before.to, to: after.from };
  return null;
}
var insertNewlineAndIndent = newlineAndIndent(false);
var insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range) => {
      let { from, to } = range, line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof)
        from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx, from);
      if (indent == null)
        indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to < line.to && /\s/.test(line.text[to - line.from]))
        to++;
      if (explode)
        ({ from, to } = explode);
      else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
        from = line.from;
      let insert = ["", indentString(state, indent)];
      if (explode)
        insert.push(indentString(state, cx.lineIndent(line.from, -1)));
      return {
        changes: { from, to, insert: Text.of(insert) },
        range: EditorSelection.cursor(from + 1 + insert[1].length)
      };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange((range) => {
    let changes = [];
    for (let pos = range.from; pos <= range.to; ) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
var indentSelection = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start) => {
    let found = updated[start];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line, changes2, range) => {
    let indent = getIndentation(context, line.from);
    if (indent == null)
      return;
    if (!/\S/.test(line.text))
      indent = 0;
    let cur = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur != norm || range.from < line.from + cur.length) {
      updated[line.from] = indent;
      changes2.push({ from: line.from, to: line.from + cur.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch(state.update(changes, { userEvent: "indent" }));
  return true;
};
var indentMore = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({ from: line.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
var indentLess = ({ state, dispatch }) => {
  if (state.readOnly)
    return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space)
      return;
    let col = countColumn(space, state.tabSize), keep = 0;
    let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
      keep++;
    changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
var toggleTabFocusMode = (view) => {
  view.setTabFocusMode();
  return true;
};
var emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
var standardKeymap = [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent, shift: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
  { mac: "Mod-Delete", run: deleteLineBoundaryForward }
].concat(emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
var defaultKeymap = [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment },
  { key: "Ctrl-m", mac: "Shift-Alt-m", run: toggleTabFocusMode }
].concat(standardKeymap);
var indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };

// node_modules/crelt/index.js
function crelt() {
  var elt = arguments[0];
  if (typeof elt == "string") elt = document.createElement(elt);
  var i2 = 1, next = arguments[1];
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
      var value = next[name];
      if (typeof value == "string") elt.setAttribute(name, value);
      else if (value != null) elt[name] = value;
    }
    i2++;
  }
  for (; i2 < arguments.length; i2++) add(elt, arguments[i2]);
  return elt;
}
function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child));
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child);
  } else if (Array.isArray(child)) {
    for (var i2 = 0; i2 < child.length; i2++) add(elt, child[i2]);
  } else {
    throw new RangeError("Unsupported child node: " + child);
  }
}

// node_modules/@codemirror/search/dist/index.js
var basicNormalize = typeof String.prototype.normalize == "function" ? (x2) => x2.normalize("NFKD") : (x2) => x2;
var SearchCursor = class {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(text, query, from = 0, to = text.length, normalize, test) {
    this.test = test;
    this.value = { from: 0, to: 0 };
    this.done = false;
    this.matches = [];
    this.buffer = "";
    this.bufferPos = 0;
    this.iter = text.iterRange(from, to);
    this.bufferStart = from;
    this.normalize = normalize ? (x2) => normalize(basicNormalize(x2)) : basicNormalize;
    this.query = this.normalize(query);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      this.bufferStart += this.buffer.length;
      this.iter.next();
      if (this.iter.done)
        return -1;
      this.bufferPos = 0;
      this.buffer = this.iter.value;
    }
    return codePointAt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    while (this.matches.length)
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let next = this.peek();
      if (next < 0) {
        this.done = true;
        return this;
      }
      let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
      this.bufferPos += codePointSize(next);
      let norm = this.normalize(str);
      if (norm.length)
        for (let i2 = 0, pos = start; ; i2++) {
          let code = norm.charCodeAt(i2);
          let match = this.match(code, pos, this.bufferPos + this.bufferStart);
          if (i2 == norm.length - 1) {
            if (match) {
              this.value = match;
              return this;
            }
            break;
          }
          if (pos == start && i2 < str.length && str.charCodeAt(i2) == code)
            pos++;
        }
    }
  }
  match(code, pos, end) {
    let match = null;
    for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
      let index2 = this.matches[i2], keep = false;
      if (this.query.charCodeAt(index2) == code) {
        if (index2 == this.query.length - 1) {
          match = { from: this.matches[i2 + 1], to: end };
        } else {
          this.matches[i2]++;
          keep = true;
        }
      }
      if (!keep) {
        this.matches.splice(i2, 2);
        i2 -= 2;
      }
    }
    if (this.query.charCodeAt(0) == code) {
      if (this.query.length == 1)
        match = { from: pos, to: end };
      else
        this.matches.push(1, pos);
    }
    if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
      match = null;
    return match;
  }
};
if (typeof Symbol != "undefined")
  SearchCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
var empty = { from: -1, to: -1, match: /.*/.exec("") };
var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
var RegExpCursor = class {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(text, query, options, from = 0, to = text.length) {
    this.text = text;
    this.to = to;
    this.curLine = "";
    this.done = false;
    this.value = empty;
    if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
      return new MultilineRegExpCursor(text, query, options, from, to);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.iter = text.iter();
    let startLine = text.lineAt(from);
    this.curLineStart = startLine.from;
    this.matchPos = toCharEnd(text, from);
    this.getLine(this.curLineStart);
  }
  getLine(skip) {
    this.iter.next(skip);
    if (this.iter.lineBreak) {
      this.curLine = "";
    } else {
      this.curLine = this.iter.value;
      if (this.curLineStart + this.curLine.length > this.to)
        this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
      this.iter.next();
    }
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1;
    if (this.curLineStart > this.to)
      this.curLine = "";
    else
      this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let off = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = off;
      let match = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (match) {
        let from = this.curLineStart + match.index, to = from + match[0].length;
        this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
        if (from == this.curLineStart + this.curLine.length)
          this.nextLine();
        if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          return this;
        }
        off = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to) {
        this.nextLine();
        off = 0;
      } else {
        this.done = true;
        return this;
      }
    }
  }
};
var flattened = /* @__PURE__ */ new WeakMap();
var FlattenedDoc = class _FlattenedDoc {
  constructor(from, text) {
    this.from = from;
    this.text = text;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(doc, from, to) {
    let cached = flattened.get(doc);
    if (!cached || cached.from >= to || cached.to <= from) {
      let flat = new _FlattenedDoc(from, doc.sliceString(from, to));
      flattened.set(doc, flat);
      return flat;
    }
    if (cached.from == from && cached.to == to)
      return cached;
    let { text, from: cachedFrom } = cached;
    if (cachedFrom > from) {
      text = doc.sliceString(from, cachedFrom) + text;
      cachedFrom = from;
    }
    if (cached.to < to)
      text += doc.sliceString(cached.to, to);
    flattened.set(doc, new _FlattenedDoc(cachedFrom, text));
    return new _FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
  }
};
var MultilineRegExpCursor = class {
  constructor(text, query, options, from, to) {
    this.text = text;
    this.to = to;
    this.done = false;
    this.value = empty;
    this.matchPos = toCharEnd(text, from);
    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
    this.test = options === null || options === void 0 ? void 0 : options.test;
    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(
      from + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(pos) {
    return pos >= this.to ? this.to : this.text.lineAt(pos).to;
  }
  next() {
    for (; ; ) {
      let off = this.re.lastIndex = this.matchPos - this.flat.from;
      let match = this.re.exec(this.flat.text);
      if (match && !match[0] && match.index == off) {
        this.re.lastIndex = off + 1;
        match = this.re.exec(this.flat.text);
      }
      if (match) {
        let from = this.flat.from + match.index, to = from + match[0].length;
        if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) && (!this.test || this.test(from, to, match))) {
          this.value = { from, to, match };
          this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
          return this;
        }
      }
      if (this.flat.to == this.to) {
        this.done = true;
        return this;
      }
      this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
};
if (typeof Symbol != "undefined") {
  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a3) {
    return false;
  }
}
function toCharEnd(text, pos) {
  if (pos >= text.length)
    return pos;
  let line = text.lineAt(pos), next;
  while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 56320 && next < 57344)
    pos++;
  return pos;
}
function createLineDialog(view) {
  let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
  let input = crelt("input", { class: "cm-textfield", name: "line", value: line });
  let dom = crelt("form", {
    class: "cm-gotoLine",
    onkeydown: (event) => {
      if (event.keyCode == 27) {
        event.preventDefault();
        view.dispatch({ effects: dialogEffect.of(false) });
        view.focus();
      } else if (event.keyCode == 13) {
        event.preventDefault();
        go();
      }
    },
    onsubmit: (event) => {
      event.preventDefault();
      go();
    }
  }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
  function go() {
    let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
    if (!match)
      return;
    let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
    let [, sign, ln, cl, percent] = match;
    let col = cl ? +cl.slice(1) : 0;
    let line2 = ln ? +ln : startLine.number;
    if (ln && percent) {
      let pc = line2 / 100;
      if (sign)
        pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state.doc.lines;
      line2 = Math.round(state.doc.lines * pc);
    } else if (ln && sign) {
      line2 = line2 * (sign == "-" ? -1 : 1) + startLine.number;
    }
    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line2)));
    let selection2 = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
    view.dispatch({
      effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection2.from, { y: "center" })],
      selection: selection2
    });
    view.focus();
  }
  return { dom };
}
var dialogEffect = StateEffect.define();
var dialogField = StateField.define({
  create() {
    return true;
  },
  update(value, tr) {
    for (let e2 of tr.effects)
      if (e2.is(dialogEffect))
        value = e2.value;
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
});
var gotoLine = (view) => {
  let panel = getPanel(view, createLineDialog);
  if (!panel) {
    let effects = [dialogEffect.of(true)];
    if (view.state.field(dialogField, false) == null)
      effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));
    view.dispatch({ effects });
    panel = getPanel(view, createLineDialog);
  }
  if (panel)
    panel.dom.querySelector("input").select();
  return true;
};
var baseTheme$1 = EditorView.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
});
var defaultHighlightOptions = {
  highlightWordAroundCursor: false,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: false
};
var highlightConfig = Facet.define({
  combine(options) {
    return combineConfig(options, defaultHighlightOptions, {
      highlightWordAroundCursor: (a, b) => a || b,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function highlightSelectionMatches(options) {
  let ext = [defaultTheme, matchHighlighter];
  if (options)
    ext.push(highlightConfig.of(options));
  return ext;
}
var matchDeco = Decoration.mark({ class: "cm-selectionMatch" });
var mainMatchDeco = Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function insideWordBoundaries(check, state, from, to) {
  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);
}
function insideWord(check, state, from, to) {
  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;
}
var matchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.selectionSet || update.docChanged || update.viewportChanged)
      this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let conf = view.state.facet(highlightConfig);
    let { state } = view, sel = state.selection;
    if (sel.ranges.length > 1)
      return Decoration.none;
    let range = sel.main, query, check = null;
    if (range.empty) {
      if (!conf.highlightWordAroundCursor)
        return Decoration.none;
      let word = state.wordAt(range.head);
      if (!word)
        return Decoration.none;
      check = state.charCategorizer(range.head);
      query = state.sliceDoc(word.from, word.to);
    } else {
      let len = range.to - range.from;
      if (len < conf.minSelectionLength || len > 200)
        return Decoration.none;
      if (conf.wholeWords) {
        query = state.sliceDoc(range.from, range.to);
        check = state.charCategorizer(range.head);
        if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to)))
          return Decoration.none;
      } else {
        query = state.sliceDoc(range.from, range.to);
        if (!query)
          return Decoration.none;
      }
    }
    let deco = [];
    for (let part of view.visibleRanges) {
      let cursor2 = new SearchCursor(state.doc, query, part.from, part.to);
      while (!cursor2.next().done) {
        let { from, to } = cursor2.value;
        if (!check || insideWordBoundaries(check, state, from, to)) {
          if (range.empty && from <= range.from && to >= range.to)
            deco.push(mainMatchDeco.range(from, to));
          else if (from >= range.to || to <= range.from)
            deco.push(matchDeco.range(from, to));
          if (deco.length > conf.maxMatches)
            return Decoration.none;
        }
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: (v) => v.decorations
});
var defaultTheme = EditorView.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
var selectWord = ({ state, dispatch }) => {
  let { selection: selection2 } = state;
  let newSel = EditorSelection.create(selection2.ranges.map((range) => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection2.mainIndex);
  if (newSel.eq(selection2))
    return false;
  dispatch(state.update({ selection: newSel }));
  return true;
};
function findNextOccurrence(state, query) {
  let { main, ranges } = state.selection;
  let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
  for (let cycled = false, cursor2 = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to); ; ) {
    cursor2.next();
    if (cursor2.done) {
      if (cycled)
        return null;
      cursor2 = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
      cycled = true;
    } else {
      if (cycled && ranges.some((r2) => r2.from == cursor2.value.from))
        continue;
      if (fullWord) {
        let word2 = state.wordAt(cursor2.value.from);
        if (!word2 || word2.from != cursor2.value.from || word2.to != cursor2.value.to)
          continue;
      }
      return cursor2.value;
    }
  }
}
var selectNextOccurrence = ({ state, dispatch }) => {
  let { ranges } = state.selection;
  if (ranges.some((sel) => sel.from === sel.to))
    return selectWord({ state, dispatch });
  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
  if (state.selection.ranges.some((r2) => state.sliceDoc(r2.from, r2.to) != searchedText))
    return false;
  let range = findNextOccurrence(state, searchedText);
  if (!range)
    return false;
  dispatch(state.update({
    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),
    effects: EditorView.scrollIntoView(range.to)
  }));
  return true;
};
var searchConfigFacet = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      top: false,
      caseSensitive: false,
      literal: false,
      regexp: false,
      wholeWord: false,
      createPanel: (view) => new SearchPanel(view),
      scrollToMatch: (range) => EditorView.scrollIntoView(range)
    });
  }
});
var SearchQuery = class {
  /**
  Create a query object.
  */
  constructor(config2) {
    this.search = config2.search;
    this.caseSensitive = !!config2.caseSensitive;
    this.literal = !!config2.literal;
    this.regexp = !!config2.regexp;
    this.replace = config2.replace || "";
    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
    this.unquoted = this.unquote(this.search);
    this.wholeWord = !!config2.wholeWord;
  }
  /**
  @internal
  */
  unquote(text) {
    return this.literal ? text : text.replace(/\\([nrt\\])/g, (_2, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(state, from = 0, to) {
    let st = state.doc ? state : EditorState.create({ doc: state });
    if (to == null)
      to = st.doc.length;
    return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
  }
};
var QueryType = class {
  constructor(spec) {
    this.spec = spec;
  }
};
function stringCursor(spec, state, from, to) {
  return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x2) => x2.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : void 0);
}
function stringWordTest(doc, categorizer) {
  return (from, to, buf, bufPos) => {
    if (bufPos > from || bufPos + buf.length < to) {
      bufPos = Math.max(0, from - 2);
      buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));
    }
    return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word || categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) && (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word || categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);
  };
}
var StringQuery = class extends QueryType {
  constructor(spec) {
    super(spec);
  }
  nextMatch(state, curFrom, curTo) {
    let cursor2 = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
    if (cursor2.done) {
      let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);
      cursor2 = stringCursor(this.spec, state, 0, end).nextOverlapping();
    }
    return cursor2.done || cursor2.value.from == curFrom && cursor2.value.to == curTo ? null : cursor2.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(state, from, to) {
    for (let pos = to; ; ) {
      let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
      let cursor2 = stringCursor(this.spec, state, start, pos), range = null;
      while (!cursor2.nextOverlapping().done)
        range = cursor2.value;
      if (range)
        return range;
      if (start == from)
        return null;
      pos -= 1e4;
    }
  }
  prevMatch(state, curFrom, curTo) {
    let found = this.prevMatchInRange(state, 0, curFrom);
    if (!found)
      found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);
    return found && (found.from != curFrom || found.to != curTo) ? found : null;
  }
  getReplacement(_result) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(state, limit) {
    let cursor2 = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from, to, add2) {
    let cursor2 = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
    while (!cursor2.next().done)
      add2(cursor2.value.from, cursor2.value.to);
  }
};
function regexpCursor(spec, state, from, to) {
  return new RegExpCursor(state.doc, spec.search, {
    ignoreCase: !spec.caseSensitive,
    test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : void 0
  }, from, to);
}
function charBefore(str, index2) {
  return str.slice(findClusterBreak(str, index2, false), index2);
}
function charAfter(str, index2) {
  return str.slice(index2, findClusterBreak(str, index2));
}
function regexpWordTest(categorizer) {
  return (_from, _to, match) => !match[0].length || (categorizer(charBefore(match.input, match.index)) != CharCategory.Word || categorizer(charAfter(match.input, match.index)) != CharCategory.Word) && (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word || categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);
}
var RegExpQuery = class extends QueryType {
  nextMatch(state, curFrom, curTo) {
    let cursor2 = regexpCursor(this.spec, state, curTo, state.doc.length).next();
    if (cursor2.done)
      cursor2 = regexpCursor(this.spec, state, 0, curFrom).next();
    return cursor2.done ? null : cursor2.value;
  }
  prevMatchInRange(state, from, to) {
    for (let size = 1; ; size++) {
      let start = Math.max(
        from,
        to - size * 1e4
        /* FindPrev.ChunkSize */
      );
      let cursor2 = regexpCursor(this.spec, state, start, to), range = null;
      while (!cursor2.next().done)
        range = cursor2.value;
      if (range && (start == from || range.from > start + 10))
        return range;
      if (start == from)
        return null;
    }
  }
  prevMatch(state, curFrom, curTo) {
    return this.prevMatchInRange(state, 0, curFrom) || this.prevMatchInRange(state, curTo, state.doc.length);
  }
  getReplacement(result) {
    return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (m, i2) => i2 == "$" ? "$" : i2 == "&" ? result.match[0] : i2 != "0" && +i2 < result.match.length ? result.match[i2] : m);
  }
  matchAll(state, limit) {
    let cursor2 = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
    while (!cursor2.next().done) {
      if (ranges.length >= limit)
        return null;
      ranges.push(cursor2.value);
    }
    return ranges;
  }
  highlight(state, from, to, add2) {
    let cursor2 = regexpCursor(this.spec, state, Math.max(
      0,
      from - 250
      /* RegExp.HighlightMargin */
    ), Math.min(to + 250, state.doc.length));
    while (!cursor2.next().done)
      add2(cursor2.value.from, cursor2.value.to);
  }
};
var setSearchQuery = StateEffect.define();
var togglePanel = StateEffect.define();
var searchState = StateField.define({
  create(state) {
    return new SearchState(defaultQuery(state).create(), null);
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setSearchQuery))
        value = new SearchState(effect.value.create(), value.panel);
      else if (effect.is(togglePanel))
        value = new SearchState(value.query, effect.value ? createSearchPanel : null);
    }
    return value;
  },
  provide: (f) => showPanel.from(f, (val) => val.panel)
});
var SearchState = class {
  constructor(query, panel) {
    this.query = query;
    this.panel = panel;
  }
};
var matchMark = Decoration.mark({ class: "cm-searchMatch" });
var selectedMatchMark = Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
var searchHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.decorations = this.highlight(view.state.field(searchState));
  }
  update(update) {
    let state = update.state.field(searchState);
    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
      this.decorations = this.highlight(state);
  }
  highlight({ query, panel }) {
    if (!panel || !query.spec.valid)
      return Decoration.none;
    let { view } = this;
    let builder = new RangeSetBuilder();
    for (let i2 = 0, ranges = view.visibleRanges, l = ranges.length; i2 < l; i2++) {
      let { from, to } = ranges[i2];
      while (i2 < l - 1 && to > ranges[i2 + 1].from - 2 * 250)
        to = ranges[++i2].to;
      query.highlight(view.state, from, to, (from2, to2) => {
        let selected = view.state.selection.ranges.some((r2) => r2.from == from2 && r2.to == to2);
        builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
      });
    }
    return builder.finish();
  }
}, {
  decorations: (v) => v.decorations
});
function searchCommand(f) {
  return (view) => {
    let state = view.state.field(searchState, false);
    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
  };
}
var findNext = searchCommand((view, { query }) => {
  let { to } = view.state.selection.main;
  let next = query.nextMatch(view.state, to, to);
  if (!next)
    return false;
  let selection2 = EditorSelection.single(next.from, next.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection: selection2,
    effects: [announceMatch(view, next), config2.scrollToMatch(selection2.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var findPrevious = searchCommand((view, { query }) => {
  let { state } = view, { from } = state.selection.main;
  let prev = query.prevMatch(state, from, from);
  if (!prev)
    return false;
  let selection2 = EditorSelection.single(prev.from, prev.to);
  let config2 = view.state.facet(searchConfigFacet);
  view.dispatch({
    selection: selection2,
    effects: [announceMatch(view, prev), config2.scrollToMatch(selection2.main, view)],
    userEvent: "select.search"
  });
  selectSearchInput(view);
  return true;
});
var selectMatches = searchCommand((view, { query }) => {
  let ranges = query.matchAll(view.state, 1e3);
  if (!ranges || !ranges.length)
    return false;
  view.dispatch({
    selection: EditorSelection.create(ranges.map((r2) => EditorSelection.range(r2.from, r2.to))),
    userEvent: "select.search.matches"
  });
  return true;
});
var selectSelectionMatches = ({ state, dispatch }) => {
  let sel = state.selection;
  if (sel.ranges.length > 1 || sel.main.empty)
    return false;
  let { from, to } = sel.main;
  let ranges = [], main = 0;
  for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done; ) {
    if (ranges.length > 1e3)
      return false;
    if (cur.value.from == from)
      main = ranges.length;
    ranges.push(EditorSelection.range(cur.value.from, cur.value.to));
  }
  dispatch(state.update({
    selection: EditorSelection.create(ranges, main),
    userEvent: "select.search.matches"
  }));
  return true;
};
var replaceNext = searchCommand((view, { query }) => {
  let { state } = view, { from, to } = state.selection.main;
  if (state.readOnly)
    return false;
  let next = query.nextMatch(state, from, from);
  if (!next)
    return false;
  let changes = [], selection2, replacement;
  let effects = [];
  if (next.from == from && next.to == to) {
    replacement = state.toText(query.getReplacement(next));
    changes.push({ from: next.from, to: next.to, insert: replacement });
    next = query.nextMatch(state, next.from, next.to);
    effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
  }
  if (next) {
    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
    selection2 = EditorSelection.single(next.from - off, next.to - off);
    effects.push(announceMatch(view, next));
    effects.push(state.facet(searchConfigFacet).scrollToMatch(selection2.main, view));
  }
  view.dispatch({
    changes,
    selection: selection2,
    effects,
    userEvent: "input.replace"
  });
  return true;
});
var replaceAll = searchCommand((view, { query }) => {
  if (view.state.readOnly)
    return false;
  let changes = query.matchAll(view.state, 1e9).map((match) => {
    let { from, to } = match;
    return { from, to, insert: query.getReplacement(match) };
  });
  if (!changes.length)
    return false;
  let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
  view.dispatch({
    changes,
    effects: EditorView.announce.of(announceText),
    userEvent: "input.replace.all"
  });
  return true;
});
function createSearchPanel(view) {
  return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
  var _a3, _b2, _c, _d, _e;
  let sel = state.selection.main;
  let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
  if (fallback && !selText)
    return fallback;
  let config2 = state.facet(searchConfigFacet);
  return new SearchQuery({
    search: ((_a3 = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a3 !== void 0 ? _a3 : config2.literal) ? selText : selText.replace(/\n/g, "\\n"),
    caseSensitive: (_b2 = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b2 !== void 0 ? _b2 : config2.caseSensitive,
    literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config2.literal,
    regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config2.regexp,
    wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config2.wholeWord
  });
}
function getSearchInput(view) {
  let panel = getPanel(view, createSearchPanel);
  return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
  let input = getSearchInput(view);
  if (input && input == view.root.activeElement)
    input.select();
}
var openSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (state && state.panel) {
    let searchInput = getSearchInput(view);
    if (searchInput && searchInput != view.root.activeElement) {
      let query = defaultQuery(view.state, state.query.spec);
      if (query.valid)
        view.dispatch({ effects: setSearchQuery.of(query) });
      searchInput.focus();
      searchInput.select();
    }
  } else {
    view.dispatch({ effects: [
      togglePanel.of(true),
      state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
    ] });
  }
  return true;
};
var closeSearchPanel = (view) => {
  let state = view.state.field(searchState, false);
  if (!state || !state.panel)
    return false;
  let panel = getPanel(view, createSearchPanel);
  if (panel && panel.dom.contains(view.root.activeElement))
    view.focus();
  view.dispatch({ effects: togglePanel.of(false) });
  return true;
};
var searchKeymap = [
  { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
  { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
  { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: selectSelectionMatches },
  { key: "Mod-Alt-g", run: gotoLine },
  { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
];
var SearchPanel = class {
  constructor(view) {
    this.view = view;
    let query = this.query = view.state.field(searchState).query.spec;
    this.commit = this.commit.bind(this);
    this.searchField = crelt("input", {
      value: query.search,
      placeholder: phrase(view, "Find"),
      "aria-label": phrase(view, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.replaceField = crelt("input", {
      value: query.replace,
      placeholder: phrase(view, "Replace"),
      "aria-label": phrase(view, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    });
    this.caseField = crelt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: query.caseSensitive,
      onchange: this.commit
    });
    this.reField = crelt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: query.regexp,
      onchange: this.commit
    });
    this.wordField = crelt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: query.wholeWord,
      onchange: this.commit
    });
    function button(name, onclick, content) {
      return crelt("button", { class: "cm-button", name, onclick, type: "button" }, content);
    }
    this.dom = crelt("div", { onkeydown: (e2) => this.keydown(e2), class: "cm-search" }, [
      this.searchField,
      button("next", () => findNext(view), [phrase(view, "next")]),
      button("prev", () => findPrevious(view), [phrase(view, "previous")]),
      button("select", () => selectMatches(view), [phrase(view, "all")]),
      crelt("label", null, [this.caseField, phrase(view, "match case")]),
      crelt("label", null, [this.reField, phrase(view, "regexp")]),
      crelt("label", null, [this.wordField, phrase(view, "by word")]),
      ...view.state.readOnly ? [] : [
        crelt("br"),
        this.replaceField,
        button("replace", () => replaceNext(view), [phrase(view, "replace")]),
        button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
      ],
      crelt("button", {
        name: "close",
        onclick: () => closeSearchPanel(view),
        "aria-label": phrase(view, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let query = new SearchQuery({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    if (!query.eq(this.query)) {
      this.query = query;
      this.view.dispatch({ effects: setSearchQuery.of(query) });
    }
  }
  keydown(e2) {
    if (runScopeHandlers(this.view, e2, "search-panel")) {
      e2.preventDefault();
    } else if (e2.keyCode == 13 && e2.target == this.searchField) {
      e2.preventDefault();
      (e2.shiftKey ? findPrevious : findNext)(this.view);
    } else if (e2.keyCode == 13 && e2.target == this.replaceField) {
      e2.preventDefault();
      replaceNext(this.view);
    }
  }
  update(update) {
    for (let tr of update.transactions)
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
          this.setQuery(effect.value);
      }
  }
  setQuery(query) {
    this.query = query;
    this.searchField.value = query.search;
    this.replaceField.value = query.replace;
    this.caseField.checked = query.caseSensitive;
    this.reField.checked = query.regexp;
    this.wordField.checked = query.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(searchConfigFacet).top;
  }
};
function phrase(view, phrase2) {
  return view.state.phrase(phrase2);
}
var AnnounceMargin = 30;
var Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
  let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
  let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
  let text = view.state.sliceDoc(start, end);
  if (start != line.from) {
    for (let i2 = 0; i2 < AnnounceMargin; i2++)
      if (!Break.test(text[i2 + 1]) && Break.test(text[i2])) {
        text = text.slice(i2);
        break;
      }
  }
  if (end != lineEnd) {
    for (let i2 = text.length - 1; i2 > text.length - AnnounceMargin; i2--)
      if (!Break.test(text[i2 - 1]) && Break.test(text[i2])) {
        text = text.slice(0, i2);
        break;
      }
  }
  return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
var baseTheme = EditorView.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
var searchExtensions = [
  searchState,
  Prec.low(searchHighlighter),
  baseTheme
];

// node_modules/@codemirror/lint/dist/index.js
var SelectedDiagnostic = class {
  constructor(from, to, diagnostic) {
    this.from = from;
    this.to = to;
    this.diagnostic = diagnostic;
  }
};
var LintState = class _LintState {
  constructor(diagnostics, panel, selected) {
    this.diagnostics = diagnostics;
    this.panel = panel;
    this.selected = selected;
  }
  static init(diagnostics, panel, state) {
    let markedDiagnostics = diagnostics;
    let diagnosticFilter = state.facet(lintConfig).markerFilter;
    if (diagnosticFilter)
      markedDiagnostics = diagnosticFilter(markedDiagnostics, state);
    let ranges = Decoration.set(markedDiagnostics.map((d) => {
      return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({
        widget: new DiagnosticWidget(d),
        diagnostic: d
      }).range(d.from) : Decoration.mark({
        attributes: { class: "cm-lintRange cm-lintRange-" + d.severity + (d.markClass ? " " + d.markClass : "") },
        diagnostic: d
      }).range(d.from, d.to);
    }), true);
    return new _LintState(ranges, panel, findDiagnostic(ranges));
  }
};
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
  let found = null;
  diagnostics.between(after, 1e9, (from, to, { spec }) => {
    if (diagnostic && spec.diagnostic != diagnostic)
      return;
    found = new SelectedDiagnostic(from, to, spec.diagnostic);
    return false;
  });
  return found;
}
function hideTooltip(tr, tooltip) {
  let from = tooltip.pos, to = tooltip.end || from;
  let result = tr.state.facet(lintConfig).hideOn(tr, from, to);
  if (result != null)
    return result;
  let line = tr.startState.doc.lineAt(tooltip.pos);
  return !!(tr.effects.some((e2) => e2.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, Math.max(line.to, to)));
}
function maybeEnableLint(state, effects) {
  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
function setDiagnostics(state, diagnostics) {
  return {
    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
  };
}
var setDiagnosticsEffect = StateEffect.define();
var togglePanel2 = StateEffect.define();
var movePanelSelection = StateEffect.define();
var lintState = StateField.define({
  create() {
    return new LintState(Decoration.none, null, null);
  },
  update(value, tr) {
    if (tr.docChanged && value.diagnostics.size) {
      let mapped = value.diagnostics.map(tr.changes), selected = null, panel = value.panel;
      if (value.selected) {
        let selPos = tr.changes.mapPos(value.selected.from, 1);
        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
      }
      if (!mapped.size && panel && tr.state.facet(lintConfig).autoPanel)
        panel = null;
      value = new LintState(mapped, panel, selected);
    }
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let panel = !tr.state.facet(lintConfig).autoPanel ? value.panel : effect.value.length ? LintPanel.open : null;
        value = LintState.init(effect.value, panel, tr.state);
      } else if (effect.is(togglePanel2)) {
        value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
      } else if (effect.is(movePanelSelection)) {
        value = new LintState(value.diagnostics, value.panel, effect.value);
      }
    }
    return value;
  },
  provide: (f) => [
    showPanel.from(f, (val) => val.panel),
    EditorView.decorations.from(f, (s) => s.diagnostics)
  ]
});
var activeMark = Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
  let { diagnostics } = view.state.field(lintState);
  let found = [], stackStart = 2e8, stackEnd = 0;
  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
      found.push(spec.diagnostic);
      stackStart = Math.min(from, stackStart);
      stackEnd = Math.max(to, stackEnd);
    }
  });
  let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
  if (diagnosticFilter)
    found = diagnosticFilter(found, view.state);
  if (!found.length)
    return null;
  return {
    pos: stackStart,
    end: stackEnd,
    above: view.state.doc.lineAt(stackStart).to < stackEnd,
    create() {
      return { dom: diagnosticsTooltip(view, found) };
    }
  };
}
function diagnosticsTooltip(view, diagnostics) {
  return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d) => renderDiagnostic(view, d, false)));
}
var openLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel2.of(true)]) });
  let panel = getPanel(view, LintPanel.open);
  if (panel)
    panel.dom.querySelector(".cm-panel-lint ul").focus();
  return true;
};
var closeLintPanel = (view) => {
  let field = view.state.field(lintState, false);
  if (!field || !field.panel)
    return false;
  view.dispatch({ effects: togglePanel2.of(false) });
  return true;
};
var nextDiagnostic = (view) => {
  let field = view.state.field(lintState, false);
  if (!field)
    return false;
  let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
  if (!next.value) {
    next = field.diagnostics.iter(0);
    if (!next.value || next.from == sel.from && next.to == sel.to)
      return false;
  }
  view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
  return true;
};
var lintKeymap = [
  { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
  { key: "F8", run: nextDiagnostic }
];
var lintPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.timeout = -1;
    this.set = true;
    let { delay } = view.state.facet(lintConfig);
    this.lintTime = Date.now() + delay;
    this.run = this.run.bind(this);
    this.timeout = setTimeout(this.run, delay);
  }
  run() {
    clearTimeout(this.timeout);
    let now = Date.now();
    if (now < this.lintTime - 10) {
      this.timeout = setTimeout(this.run, this.lintTime - now);
    } else {
      this.set = false;
      let { state } = this.view, { sources } = state.facet(lintConfig);
      if (sources.length)
        batchResults(sources.map((s) => Promise.resolve(s(this.view))), (annotations) => {
          if (this.view.state.doc == state.doc)
            this.view.dispatch(setDiagnostics(this.view.state, annotations.reduce((a, b) => a.concat(b))));
        }, (error) => {
          logException(this.view.state, error);
        });
    }
  }
  update(update) {
    let config2 = update.state.facet(lintConfig);
    if (update.docChanged || config2 != update.startState.facet(lintConfig) || config2.needsRefresh && config2.needsRefresh(update)) {
      this.lintTime = Date.now() + config2.delay;
      if (!this.set) {
        this.set = true;
        this.timeout = setTimeout(this.run, config2.delay);
      }
    }
  }
  force() {
    if (this.set) {
      this.lintTime = Date.now();
      this.run();
    }
  }
  destroy() {
    clearTimeout(this.timeout);
  }
});
function batchResults(promises, sink, error) {
  let collected = [], timeout = -1;
  for (let p of promises)
    p.then((value) => {
      collected.push(value);
      clearTimeout(timeout);
      if (collected.length == promises.length)
        sink(collected);
      else
        setTimeout(() => sink(collected), 200);
    }, error);
}
var lintConfig = Facet.define({
  combine(input) {
    return Object.assign({ sources: input.map((i2) => i2.source).filter((x2) => x2 != null) }, combineConfig(input.map((i2) => i2.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null,
      hideOn: () => null
    }, {
      needsRefresh: (a, b) => !a ? b : !b ? a : (u2) => a(u2) || b(u2)
    }));
  }
});
function assignKeys(actions) {
  let assigned = [];
  if (actions)
    actions: for (let { name } of actions) {
      for (let i2 = 0; i2 < name.length; i2++) {
        let ch = name[i2];
        if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
          assigned.push(ch);
          continue actions;
        }
      }
      assigned.push("");
    }
  return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
  var _a3;
  let keys = inPanel ? assignKeys(diagnostic.actions) : [];
  return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage(view) : diagnostic.message), (_a3 = diagnostic.actions) === null || _a3 === void 0 ? void 0 : _a3.map((action, i2) => {
    let fired = false, click = (e2) => {
      e2.preventDefault();
      if (fired)
        return;
      fired = true;
      let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
      if (found)
        action.apply(view, found.from, found.to);
    };
    let { name } = action, keyIndex = keys[i2] ? name.indexOf(keys[i2]) : -1;
    let nameElt = keyIndex < 0 ? name : [
      name.slice(0, keyIndex),
      crelt("u", name.slice(keyIndex, keyIndex + 1)),
      name.slice(keyIndex + 1)
    ];
    return crelt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: click,
      onmousedown: click,
      "aria-label": ` Action: ${name}${keyIndex < 0 ? "" : ` (access key "${keys[i2]})"`}.`
    }, nameElt);
  }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
var DiagnosticWidget = class extends WidgetType {
  constructor(diagnostic) {
    super();
    this.diagnostic = diagnostic;
  }
  eq(other) {
    return other.diagnostic == this.diagnostic;
  }
  toDOM() {
    return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
};
var PanelItem = class {
  constructor(view, diagnostic) {
    this.diagnostic = diagnostic;
    this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
    this.dom = renderDiagnostic(view, diagnostic, true);
    this.dom.id = this.id;
    this.dom.setAttribute("role", "option");
  }
};
var LintPanel = class _LintPanel {
  constructor(view) {
    this.view = view;
    this.items = [];
    let onkeydown = (event) => {
      if (event.keyCode == 27) {
        closeLintPanel(this.view);
        this.view.focus();
      } else if (event.keyCode == 38 || event.keyCode == 33) {
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      } else if (event.keyCode == 40 || event.keyCode == 34) {
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      } else if (event.keyCode == 36) {
        this.moveSelection(0);
      } else if (event.keyCode == 35) {
        this.moveSelection(this.items.length - 1);
      } else if (event.keyCode == 13) {
        this.view.focus();
      } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
        for (let i2 = 0; i2 < keys.length; i2++)
          if (keys[i2].toUpperCase().charCodeAt(0) == event.keyCode) {
            let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
            if (found)
              diagnostic.actions[i2].apply(view, found.from, found.to);
          }
      } else {
        return;
      }
      event.preventDefault();
    };
    let onclick = (event) => {
      for (let i2 = 0; i2 < this.items.length; i2++) {
        if (this.items[i2].dom.contains(event.target))
          this.moveSelection(i2);
      }
    };
    this.list = crelt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown,
      onclick
    });
    this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => closeLintPanel(this.view)
    }, "×"));
    this.update();
  }
  get selectedIndex() {
    let selected = this.view.state.field(lintState).selected;
    if (!selected)
      return -1;
    for (let i2 = 0; i2 < this.items.length; i2++)
      if (this.items[i2].diagnostic == selected.diagnostic)
        return i2;
    return -1;
  }
  update() {
    let { diagnostics, selected } = this.view.state.field(lintState);
    let i2 = 0, needsSync = false, newSelectedItem = null;
    diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
      let found = -1, item;
      for (let j = i2; j < this.items.length; j++)
        if (this.items[j].diagnostic == spec.diagnostic) {
          found = j;
          break;
        }
      if (found < 0) {
        item = new PanelItem(this.view, spec.diagnostic);
        this.items.splice(i2, 0, item);
        needsSync = true;
      } else {
        item = this.items[found];
        if (found > i2) {
          this.items.splice(i2, found - i2);
          needsSync = true;
        }
      }
      if (selected && item.diagnostic == selected.diagnostic) {
        if (!item.dom.hasAttribute("aria-selected")) {
          item.dom.setAttribute("aria-selected", "true");
          newSelectedItem = item;
        }
      } else if (item.dom.hasAttribute("aria-selected")) {
        item.dom.removeAttribute("aria-selected");
      }
      i2++;
    });
    while (i2 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
      needsSync = true;
      this.items.pop();
    }
    if (this.items.length == 0) {
      this.items.push(new PanelItem(this.view, {
        from: -1,
        to: -1,
        severity: "info",
        message: this.view.state.phrase("No diagnostics")
      }));
      needsSync = true;
    }
    if (newSelectedItem) {
      this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
      this.view.requestMeasure({
        key: this,
        read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
        write: ({ sel, panel }) => {
          let scaleY = panel.height / this.list.offsetHeight;
          if (sel.top < panel.top)
            this.list.scrollTop -= (panel.top - sel.top) / scaleY;
          else if (sel.bottom > panel.bottom)
            this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
        }
      });
    } else if (this.selectedIndex < 0) {
      this.list.removeAttribute("aria-activedescendant");
    }
    if (needsSync)
      this.sync();
  }
  sync() {
    let domPos = this.list.firstChild;
    function rm() {
      let prev = domPos;
      domPos = prev.nextSibling;
      prev.remove();
    }
    for (let item of this.items) {
      if (item.dom.parentNode == this.list) {
        while (domPos != item.dom)
          rm();
        domPos = item.dom.nextSibling;
      } else {
        this.list.insertBefore(item.dom, domPos);
      }
    }
    while (domPos)
      rm();
  }
  moveSelection(selectedIndex) {
    if (this.selectedIndex < 0)
      return;
    let field = this.view.state.field(lintState);
    let selection2 = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
    if (!selection2)
      return;
    this.view.dispatch({
      selection: { anchor: selection2.from, head: selection2.to },
      scrollIntoView: true,
      effects: movePanelSelection.of(selection2)
    });
  }
  static open(view) {
    return new _LintPanel(view);
  }
};
function svg(content, attrs = `viewBox="0 0 40 40"`) {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content)}</svg>')`;
}
function underline(color) {
  return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
var baseTheme2 = EditorView.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: underline("#d11") },
  ".cm-lintRange-warning": { backgroundImage: underline("orange") },
  ".cm-lintRange-info": { backgroundImage: underline("#999") },
  ".cm-lintRange-hint": { backgroundImage: underline("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
});
function severityWeight(sev) {
  return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
var LintGutterMarker = class extends GutterMarker {
  constructor(diagnostics) {
    super();
    this.diagnostics = diagnostics;
    this.severity = diagnostics.reduce((max, d) => severityWeight(max) < severityWeight(d.severity) ? d.severity : max, "hint");
  }
  toDOM(view) {
    let elt = document.createElement("div");
    elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
    let diagnostics = this.diagnostics;
    let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
    if (diagnosticsFilter)
      diagnostics = diagnosticsFilter(diagnostics, view.state);
    if (diagnostics.length)
      elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
    return elt;
  }
};
function trackHoverOn(view, marker) {
  let mousemove = (event) => {
    let rect = marker.getBoundingClientRect();
    if (event.clientX > rect.left - 10 && event.clientX < rect.right + 10 && event.clientY > rect.top - 10 && event.clientY < rect.bottom + 10)
      return;
    for (let target = event.target; target; target = target.parentNode) {
      if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
        return;
    }
    window.removeEventListener("mousemove", mousemove);
    if (view.state.field(lintGutterTooltip))
      view.dispatch({ effects: setLintGutterTooltip.of(null) });
  };
  window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
  function hovered() {
    let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
    const linePos = view.coordsAtPos(line.from);
    if (linePos) {
      view.dispatch({ effects: setLintGutterTooltip.of({
        pos: line.from,
        above: false,
        create() {
          return {
            dom: diagnosticsTooltip(view, diagnostics),
            getCoords: () => marker.getBoundingClientRect()
          };
        }
      }) });
    }
    marker.onmouseout = marker.onmousemove = null;
    trackHoverOn(view, marker);
  }
  let { hoverTime } = view.state.facet(lintGutterConfig);
  let hoverTimeout = setTimeout(hovered, hoverTime);
  marker.onmouseout = () => {
    clearTimeout(hoverTimeout);
    marker.onmouseout = marker.onmousemove = null;
  };
  marker.onmousemove = () => {
    clearTimeout(hoverTimeout);
    hoverTimeout = setTimeout(hovered, hoverTime);
  };
}
function markersForDiagnostics(doc, diagnostics) {
  let byLine = /* @__PURE__ */ Object.create(null);
  for (let diagnostic of diagnostics) {
    let line = doc.lineAt(diagnostic.from);
    (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
  }
  let markers = [];
  for (let line in byLine) {
    markers.push(new LintGutterMarker(byLine[line]).range(+line));
  }
  return RangeSet.of(markers, true);
}
var lintGutterExtension = gutter({
  class: "cm-gutter-lint",
  markers: (view) => view.state.field(lintGutterMarkers),
  widgetMarker: (view, widget, block) => {
    let diagnostics = [];
    view.state.field(lintGutterMarkers).between(block.from, block.to, (from, to, value) => {
      diagnostics.push(...value.diagnostics);
    });
    return diagnostics.length ? new LintGutterMarker(diagnostics) : null;
  }
});
var lintGutterMarkers = StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(markers, tr) {
    markers = markers.map(tr.changes);
    let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
    for (let effect of tr.effects) {
      if (effect.is(setDiagnosticsEffect)) {
        let diagnostics = effect.value;
        if (diagnosticFilter)
          diagnostics = diagnosticFilter(diagnostics || [], tr.state);
        markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
      }
    }
    return markers;
  }
});
var setLintGutterTooltip = StateEffect.define();
var lintGutterTooltip = StateField.define({
  create() {
    return null;
  },
  update(tooltip, tr) {
    if (tooltip && tr.docChanged)
      tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });
    return tr.effects.reduce((t2, e2) => e2.is(setLintGutterTooltip) ? e2.value : t2, tooltip);
  },
  provide: (field) => showTooltip.from(field)
});
var lintGutterTheme = EditorView.baseTheme({
  ".cm-gutter-lint": {
    width: "1.4em",
    "& .cm-gutterElement": {
      padding: ".2em"
    }
  },
  ".cm-lint-marker": {
    width: "1em",
    height: "1em"
  },
  ".cm-lint-marker-info": {
    content: svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
  },
  ".cm-lint-marker-warning": {
    content: svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`)
  },
  ".cm-lint-marker-error": {
    content: svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
  }
});
var lintExtensions = [
  lintState,
  EditorView.decorations.compute([lintState], (state) => {
    let { selected, panel } = state.field(lintState);
    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
      activeMark.range(selected.from, selected.to)
    ]);
  }),
  hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
  baseTheme2
];
var lintGutterConfig = Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      hoverTime: 300,
      markerFilter: null,
      tooltipFilter: null
    });
  }
});

// node_modules/codemirror/dist/index.js
var basicSetup = (() => [
  lineNumbers(),
  highlightActiveLineGutter(),
  highlightSpecialChars(),
  history(),
  foldGutter(),
  drawSelection(),
  dropCursor(),
  EditorState.allowMultipleSelections.of(true),
  indentOnInput(),
  syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
  bracketMatching(),
  closeBrackets(),
  autocompletion(),
  rectangularSelection(),
  crosshairCursor(),
  highlightActiveLine(),
  highlightSelectionMatches(),
  keymap.of([
    ...closeBracketsKeymap,
    ...defaultKeymap,
    ...searchKeymap,
    ...historyKeymap,
    ...foldKeymap,
    ...completionKeymap,
    ...lintKeymap
  ])
])();
var minimalSetup = (() => [
  highlightSpecialChars(),
  history(),
  drawSelection(),
  syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
  keymap.of([
    ...defaultKeymap,
    ...historyKeymap
  ])
])();

// node_modules/@codemirror/language-data/dist/index.js
function legacy(parser2) {
  return new LanguageSupport(StreamLanguage.define(parser2));
}
function sql(dialectName) {
  return import("./dist-RP2WUOZW.js").then((m) => m.sql({ dialect: m[dialectName] }));
}
var languages = [
  // New-style language modes
  LanguageDescription.of({
    name: "C",
    extensions: ["c", "h", "ino"],
    load() {
      return import("./dist-GBNZWE6P.js").then((m) => m.cpp());
    }
  }),
  LanguageDescription.of({
    name: "C++",
    alias: ["cpp"],
    extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
    load() {
      return import("./dist-GBNZWE6P.js").then((m) => m.cpp());
    }
  }),
  LanguageDescription.of({
    name: "CQL",
    alias: ["cassandra"],
    extensions: ["cql"],
    load() {
      return sql("Cassandra");
    }
  }),
  LanguageDescription.of({
    name: "CSS",
    extensions: ["css"],
    load() {
      return import("./dist-XYPAWUZA.js").then((m) => m.css());
    }
  }),
  LanguageDescription.of({
    name: "Go",
    extensions: ["go"],
    load() {
      return import("./dist-UB5GCWNA.js").then((m) => m.go());
    }
  }),
  LanguageDescription.of({
    name: "HTML",
    alias: ["xhtml"],
    extensions: ["html", "htm", "handlebars", "hbs"],
    load() {
      return import("./dist-ZR2QVOCB.js").then((m) => m.html());
    }
  }),
  LanguageDescription.of({
    name: "Java",
    extensions: ["java"],
    load() {
      return import("./dist-RGKH5PSE.js").then((m) => m.java());
    }
  }),
  LanguageDescription.of({
    name: "JavaScript",
    alias: ["ecmascript", "js", "node"],
    extensions: ["js", "mjs", "cjs"],
    load() {
      return import("./dist-K36OSNES.js").then((m) => m.javascript());
    }
  }),
  LanguageDescription.of({
    name: "JSON",
    alias: ["json5"],
    extensions: ["json", "map"],
    load() {
      return import("./dist-ED7ZFVOT.js").then((m) => m.json());
    }
  }),
  LanguageDescription.of({
    name: "JSX",
    extensions: ["jsx"],
    load() {
      return import("./dist-K36OSNES.js").then((m) => m.javascript({ jsx: true }));
    }
  }),
  LanguageDescription.of({
    name: "LESS",
    extensions: ["less"],
    load() {
      return import("./dist-2UHQIJYD.js").then((m) => m.less());
    }
  }),
  LanguageDescription.of({
    name: "Liquid",
    extensions: ["liquid"],
    load() {
      return import("./dist-ANN4RQQN.js").then((m) => m.liquid());
    }
  }),
  LanguageDescription.of({
    name: "MariaDB SQL",
    load() {
      return sql("MariaSQL");
    }
  }),
  LanguageDescription.of({
    name: "Markdown",
    extensions: ["md", "markdown", "mkd"],
    load() {
      return import("./dist-LDRRPM6G.js").then((m) => m.markdown());
    }
  }),
  LanguageDescription.of({
    name: "MS SQL",
    load() {
      return sql("MSSQL");
    }
  }),
  LanguageDescription.of({
    name: "MySQL",
    load() {
      return sql("MySQL");
    }
  }),
  LanguageDescription.of({
    name: "PHP",
    extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
    load() {
      return import("./dist-KHZJZONW.js").then((m) => m.php());
    }
  }),
  LanguageDescription.of({
    name: "PLSQL",
    extensions: ["pls"],
    load() {
      return sql("PLSQL");
    }
  }),
  LanguageDescription.of({
    name: "PostgreSQL",
    load() {
      return sql("PostgreSQL");
    }
  }),
  LanguageDescription.of({
    name: "Python",
    extensions: ["BUILD", "bzl", "py", "pyw"],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return import("./dist-DLY3ZIS5.js").then((m) => m.python());
    }
  }),
  LanguageDescription.of({
    name: "Rust",
    extensions: ["rs"],
    load() {
      return import("./dist-GHEOILLM.js").then((m) => m.rust());
    }
  }),
  LanguageDescription.of({
    name: "Sass",
    extensions: ["sass"],
    load() {
      return import("./dist-SKJ7FG5K.js").then((m) => m.sass({ indented: true }));
    }
  }),
  LanguageDescription.of({
    name: "SCSS",
    extensions: ["scss"],
    load() {
      return import("./dist-SKJ7FG5K.js").then((m) => m.sass());
    }
  }),
  LanguageDescription.of({
    name: "SQL",
    extensions: ["sql"],
    load() {
      return sql("StandardSQL");
    }
  }),
  LanguageDescription.of({
    name: "SQLite",
    load() {
      return sql("SQLite");
    }
  }),
  LanguageDescription.of({
    name: "TSX",
    extensions: ["tsx"],
    load() {
      return import("./dist-K36OSNES.js").then((m) => m.javascript({ jsx: true, typescript: true }));
    }
  }),
  LanguageDescription.of({
    name: "TypeScript",
    alias: ["ts"],
    extensions: ["ts", "mts", "cts"],
    load() {
      return import("./dist-K36OSNES.js").then((m) => m.javascript({ typescript: true }));
    }
  }),
  LanguageDescription.of({
    name: "WebAssembly",
    extensions: ["wat", "wast"],
    load() {
      return import("./dist-MAYKUVPF.js").then((m) => m.wast());
    }
  }),
  LanguageDescription.of({
    name: "XML",
    alias: ["rss", "wsdl", "xsd"],
    extensions: ["xml", "xsl", "xsd", "svg"],
    load() {
      return import("./dist-VBP3QAUG.js").then((m) => m.xml());
    }
  }),
  LanguageDescription.of({
    name: "YAML",
    alias: ["yml"],
    extensions: ["yaml", "yml"],
    load() {
      return import("./dist-OZ2GUFFU.js").then((m) => m.yaml());
    }
  }),
  // Legacy modes ported from CodeMirror 5
  LanguageDescription.of({
    name: "APL",
    extensions: ["dyalog", "apl"],
    load() {
      return import("./apl-JVWURNI3.js").then((m) => legacy(m.apl));
    }
  }),
  LanguageDescription.of({
    name: "PGP",
    alias: ["asciiarmor"],
    extensions: ["asc", "pgp", "sig"],
    load() {
      return import("./asciiarmor-3ILH53CW.js").then((m) => legacy(m.asciiArmor));
    }
  }),
  LanguageDescription.of({
    name: "ASN.1",
    extensions: ["asn", "asn1"],
    load() {
      return import("./asn1-M5BJV7AK.js").then((m) => legacy(m.asn1({})));
    }
  }),
  LanguageDescription.of({
    name: "Asterisk",
    filename: /^extensions\.conf$/i,
    load() {
      return import("./asterisk-P3YBBB4L.js").then((m) => legacy(m.asterisk));
    }
  }),
  LanguageDescription.of({
    name: "Brainfuck",
    extensions: ["b", "bf"],
    load() {
      return import("./brainfuck-HKZGWSK2.js").then((m) => legacy(m.brainfuck));
    }
  }),
  LanguageDescription.of({
    name: "Cobol",
    extensions: ["cob", "cpy"],
    load() {
      return import("./cobol-BVIVT672.js").then((m) => legacy(m.cobol));
    }
  }),
  LanguageDescription.of({
    name: "C#",
    alias: ["csharp", "cs"],
    extensions: ["cs"],
    load() {
      return import("./clike-7DJIT7LA.js").then((m) => legacy(m.csharp));
    }
  }),
  LanguageDescription.of({
    name: "Clojure",
    extensions: ["clj", "cljc", "cljx"],
    load() {
      return import("./clojure-FKTPLPVY.js").then((m) => legacy(m.clojure));
    }
  }),
  LanguageDescription.of({
    name: "ClojureScript",
    extensions: ["cljs"],
    load() {
      return import("./clojure-FKTPLPVY.js").then((m) => legacy(m.clojure));
    }
  }),
  LanguageDescription.of({
    name: "Closure Stylesheets (GSS)",
    extensions: ["gss"],
    load() {
      return import("./css-EIDXHEKS.js").then((m) => legacy(m.gss));
    }
  }),
  LanguageDescription.of({
    name: "CMake",
    extensions: ["cmake", "cmake.in"],
    filename: /^CMakeLists\.txt$/,
    load() {
      return import("./cmake-6BY5SFVS.js").then((m) => legacy(m.cmake));
    }
  }),
  LanguageDescription.of({
    name: "CoffeeScript",
    alias: ["coffee", "coffee-script"],
    extensions: ["coffee"],
    load() {
      return import("./coffeescript-VDDJN4Z5.js").then((m) => legacy(m.coffeeScript));
    }
  }),
  LanguageDescription.of({
    name: "Common Lisp",
    alias: ["lisp"],
    extensions: ["cl", "lisp", "el"],
    load() {
      return import("./commonlisp-BKKTAJD7.js").then((m) => legacy(m.commonLisp));
    }
  }),
  LanguageDescription.of({
    name: "Cypher",
    extensions: ["cyp", "cypher"],
    load() {
      return import("./cypher-F3X5KTR2.js").then((m) => legacy(m.cypher));
    }
  }),
  LanguageDescription.of({
    name: "Cython",
    extensions: ["pyx", "pxd", "pxi"],
    load() {
      return import("./python-NGQ6BEGG.js").then((m) => legacy(m.cython));
    }
  }),
  LanguageDescription.of({
    name: "Crystal",
    extensions: ["cr"],
    load() {
      return import("./crystal-3K4T3CG2.js").then((m) => legacy(m.crystal));
    }
  }),
  LanguageDescription.of({
    name: "D",
    extensions: ["d"],
    load() {
      return import("./d-Q46XL6E3.js").then((m) => legacy(m.d));
    }
  }),
  LanguageDescription.of({
    name: "Dart",
    extensions: ["dart"],
    load() {
      return import("./clike-7DJIT7LA.js").then((m) => legacy(m.dart));
    }
  }),
  LanguageDescription.of({
    name: "diff",
    extensions: ["diff", "patch"],
    load() {
      return import("./diff-EAKRKC3G.js").then((m) => legacy(m.diff));
    }
  }),
  LanguageDescription.of({
    name: "Dockerfile",
    filename: /^Dockerfile$/,
    load() {
      return import("./dockerfile-ZLMWQARF.js").then((m) => legacy(m.dockerFile));
    }
  }),
  LanguageDescription.of({
    name: "DTD",
    extensions: ["dtd"],
    load() {
      return import("./dtd-O2SBPLO3.js").then((m) => legacy(m.dtd));
    }
  }),
  LanguageDescription.of({
    name: "Dylan",
    extensions: ["dylan", "dyl", "intr"],
    load() {
      return import("./dylan-TMZWCR5Q.js").then((m) => legacy(m.dylan));
    }
  }),
  LanguageDescription.of({
    name: "EBNF",
    load() {
      return import("./ebnf-PR3E7DFN.js").then((m) => legacy(m.ebnf));
    }
  }),
  LanguageDescription.of({
    name: "ECL",
    extensions: ["ecl"],
    load() {
      return import("./ecl-F7BXUO7V.js").then((m) => legacy(m.ecl));
    }
  }),
  LanguageDescription.of({
    name: "edn",
    extensions: ["edn"],
    load() {
      return import("./clojure-FKTPLPVY.js").then((m) => legacy(m.clojure));
    }
  }),
  LanguageDescription.of({
    name: "Eiffel",
    extensions: ["e"],
    load() {
      return import("./eiffel-QP7XTCL5.js").then((m) => legacy(m.eiffel));
    }
  }),
  LanguageDescription.of({
    name: "Elm",
    extensions: ["elm"],
    load() {
      return import("./elm-SKP73WAU.js").then((m) => legacy(m.elm));
    }
  }),
  LanguageDescription.of({
    name: "Erlang",
    extensions: ["erl"],
    load() {
      return import("./erlang-H3W6Z3JG.js").then((m) => legacy(m.erlang));
    }
  }),
  LanguageDescription.of({
    name: "Esper",
    load() {
      return import("./sql-W5UBAYZN.js").then((m) => legacy(m.esper));
    }
  }),
  LanguageDescription.of({
    name: "Factor",
    extensions: ["factor"],
    load() {
      return import("./factor-SRV6RN4K.js").then((m) => legacy(m.factor));
    }
  }),
  LanguageDescription.of({
    name: "FCL",
    load() {
      return import("./fcl-SS2ZH4HU.js").then((m) => legacy(m.fcl));
    }
  }),
  LanguageDescription.of({
    name: "Forth",
    extensions: ["forth", "fth", "4th"],
    load() {
      return import("./forth-RTT5IBY2.js").then((m) => legacy(m.forth));
    }
  }),
  LanguageDescription.of({
    name: "Fortran",
    extensions: ["f", "for", "f77", "f90", "f95"],
    load() {
      return import("./fortran-XAHQ2UYR.js").then((m) => legacy(m.fortran));
    }
  }),
  LanguageDescription.of({
    name: "F#",
    alias: ["fsharp"],
    extensions: ["fs"],
    load() {
      return import("./mllike-HLCBV3ZR.js").then((m) => legacy(m.fSharp));
    }
  }),
  LanguageDescription.of({
    name: "Gas",
    extensions: ["s"],
    load() {
      return import("./gas-UOVN4MSU.js").then((m) => legacy(m.gas));
    }
  }),
  LanguageDescription.of({
    name: "Gherkin",
    extensions: ["feature"],
    load() {
      return import("./gherkin-AMOWOZ7G.js").then((m) => legacy(m.gherkin));
    }
  }),
  LanguageDescription.of({
    name: "Groovy",
    extensions: ["groovy", "gradle"],
    filename: /^Jenkinsfile$/,
    load() {
      return import("./groovy-VCOKBLI7.js").then((m) => legacy(m.groovy));
    }
  }),
  LanguageDescription.of({
    name: "Haskell",
    extensions: ["hs"],
    load() {
      return import("./haskell-33YWCAEX.js").then((m) => legacy(m.haskell));
    }
  }),
  LanguageDescription.of({
    name: "Haxe",
    extensions: ["hx"],
    load() {
      return import("./haxe-EAAPRMXQ.js").then((m) => legacy(m.haxe));
    }
  }),
  LanguageDescription.of({
    name: "HXML",
    extensions: ["hxml"],
    load() {
      return import("./haxe-EAAPRMXQ.js").then((m) => legacy(m.hxml));
    }
  }),
  LanguageDescription.of({
    name: "HTTP",
    load() {
      return import("./http-DOQWGO6L.js").then((m) => legacy(m.http));
    }
  }),
  LanguageDescription.of({
    name: "IDL",
    extensions: ["pro"],
    load() {
      return import("./idl-CD4W3YK4.js").then((m) => legacy(m.idl));
    }
  }),
  LanguageDescription.of({
    name: "JSON-LD",
    alias: ["jsonld"],
    extensions: ["jsonld"],
    load() {
      return import("./javascript-IIIQB32M.js").then((m) => legacy(m.jsonld));
    }
  }),
  LanguageDescription.of({
    name: "Jinja2",
    extensions: ["j2", "jinja", "jinja2"],
    load() {
      return import("./jinja2-EQOHB6BS.js").then((m) => legacy(m.jinja2));
    }
  }),
  LanguageDescription.of({
    name: "Julia",
    extensions: ["jl"],
    load() {
      return import("./julia-P7ST2RP4.js").then((m) => legacy(m.julia));
    }
  }),
  LanguageDescription.of({
    name: "Kotlin",
    extensions: ["kt", "kts"],
    load() {
      return import("./clike-7DJIT7LA.js").then((m) => legacy(m.kotlin));
    }
  }),
  LanguageDescription.of({
    name: "LiveScript",
    alias: ["ls"],
    extensions: ["ls"],
    load() {
      return import("./livescript-M2XIUWP4.js").then((m) => legacy(m.liveScript));
    }
  }),
  LanguageDescription.of({
    name: "Lua",
    extensions: ["lua"],
    load() {
      return import("./lua-6GX3GSQB.js").then((m) => legacy(m.lua));
    }
  }),
  LanguageDescription.of({
    name: "mIRC",
    extensions: ["mrc"],
    load() {
      return import("./mirc-P3YSW2LV.js").then((m) => legacy(m.mirc));
    }
  }),
  LanguageDescription.of({
    name: "Mathematica",
    extensions: ["m", "nb", "wl", "wls"],
    load() {
      return import("./mathematica-PEM4ZIKG.js").then((m) => legacy(m.mathematica));
    }
  }),
  LanguageDescription.of({
    name: "Modelica",
    extensions: ["mo"],
    load() {
      return import("./modelica-ZMDGOMGJ.js").then((m) => legacy(m.modelica));
    }
  }),
  LanguageDescription.of({
    name: "MUMPS",
    extensions: ["mps"],
    load() {
      return import("./mumps-EWX3B2WM.js").then((m) => legacy(m.mumps));
    }
  }),
  LanguageDescription.of({
    name: "Mbox",
    extensions: ["mbox"],
    load() {
      return import("./mbox-SNDL6IRO.js").then((m) => legacy(m.mbox));
    }
  }),
  LanguageDescription.of({
    name: "Nginx",
    filename: /nginx.*\.conf$/i,
    load() {
      return import("./nginx-7BYQONOD.js").then((m) => legacy(m.nginx));
    }
  }),
  LanguageDescription.of({
    name: "NSIS",
    extensions: ["nsh", "nsi"],
    load() {
      return import("./nsis-KOKQKN6N.js").then((m) => legacy(m.nsis));
    }
  }),
  LanguageDescription.of({
    name: "NTriples",
    extensions: ["nt", "nq"],
    load() {
      return import("./ntriples-CH2SY57U.js").then((m) => legacy(m.ntriples));
    }
  }),
  LanguageDescription.of({
    name: "Objective-C",
    alias: ["objective-c", "objc"],
    extensions: ["m"],
    load() {
      return import("./clike-7DJIT7LA.js").then((m) => legacy(m.objectiveC));
    }
  }),
  LanguageDescription.of({
    name: "Objective-C++",
    alias: ["objective-c++", "objc++"],
    extensions: ["mm"],
    load() {
      return import("./clike-7DJIT7LA.js").then((m) => legacy(m.objectiveCpp));
    }
  }),
  LanguageDescription.of({
    name: "OCaml",
    extensions: ["ml", "mli", "mll", "mly"],
    load() {
      return import("./mllike-HLCBV3ZR.js").then((m) => legacy(m.oCaml));
    }
  }),
  LanguageDescription.of({
    name: "Octave",
    extensions: ["m"],
    load() {
      return import("./octave-3M3RSAB6.js").then((m) => legacy(m.octave));
    }
  }),
  LanguageDescription.of({
    name: "Oz",
    extensions: ["oz"],
    load() {
      return import("./oz-YV3V5EIL.js").then((m) => legacy(m.oz));
    }
  }),
  LanguageDescription.of({
    name: "Pascal",
    extensions: ["p", "pas"],
    load() {
      return import("./pascal-YDCO5SVW.js").then((m) => legacy(m.pascal));
    }
  }),
  LanguageDescription.of({
    name: "Perl",
    extensions: ["pl", "pm"],
    load() {
      return import("./perl-5G7ET23X.js").then((m) => legacy(m.perl));
    }
  }),
  LanguageDescription.of({
    name: "Pig",
    extensions: ["pig"],
    load() {
      return import("./pig-I3W2U46H.js").then((m) => legacy(m.pig));
    }
  }),
  LanguageDescription.of({
    name: "PowerShell",
    extensions: ["ps1", "psd1", "psm1"],
    load() {
      return import("./powershell-5YI44F7S.js").then((m) => legacy(m.powerShell));
    }
  }),
  LanguageDescription.of({
    name: "Properties files",
    alias: ["ini", "properties"],
    extensions: ["properties", "ini", "in"],
    load() {
      return import("./properties-BHV6DXGY.js").then((m) => legacy(m.properties));
    }
  }),
  LanguageDescription.of({
    name: "ProtoBuf",
    extensions: ["proto"],
    load() {
      return import("./protobuf-5AQYSS4K.js").then((m) => legacy(m.protobuf));
    }
  }),
  LanguageDescription.of({
    name: "Pug",
    alias: ["jade"],
    extensions: ["pug", "jade"],
    load() {
      return import("./pug-HST2PLSO.js").then((m) => legacy(m.pug));
    }
  }),
  LanguageDescription.of({
    name: "Puppet",
    extensions: ["pp"],
    load() {
      return import("./puppet-X5IUHKGT.js").then((m) => legacy(m.puppet));
    }
  }),
  LanguageDescription.of({
    name: "Q",
    extensions: ["q"],
    load() {
      return import("./q-DC6JV7MY.js").then((m) => legacy(m.q));
    }
  }),
  LanguageDescription.of({
    name: "R",
    alias: ["rscript"],
    extensions: ["r", "R"],
    load() {
      return import("./r-D2YFXCNG.js").then((m) => legacy(m.r));
    }
  }),
  LanguageDescription.of({
    name: "RPM Changes",
    load() {
      return import("./rpm-36DYUOGP.js").then((m) => legacy(m.rpmChanges));
    }
  }),
  LanguageDescription.of({
    name: "RPM Spec",
    extensions: ["spec"],
    load() {
      return import("./rpm-36DYUOGP.js").then((m) => legacy(m.rpmSpec));
    }
  }),
  LanguageDescription.of({
    name: "Ruby",
    alias: ["jruby", "macruby", "rake", "rb", "rbx"],
    extensions: ["rb"],
    filename: /^(Gemfile|Rakefile)$/,
    load() {
      return import("./ruby-TR5QJCAP.js").then((m) => legacy(m.ruby));
    }
  }),
  LanguageDescription.of({
    name: "SAS",
    extensions: ["sas"],
    load() {
      return import("./sas-KRE7SGOB.js").then((m) => legacy(m.sas));
    }
  }),
  LanguageDescription.of({
    name: "Scala",
    extensions: ["scala"],
    load() {
      return import("./clike-7DJIT7LA.js").then((m) => legacy(m.scala));
    }
  }),
  LanguageDescription.of({
    name: "Scheme",
    extensions: ["scm", "ss"],
    load() {
      return import("./scheme-5S4VYDB6.js").then((m) => legacy(m.scheme));
    }
  }),
  LanguageDescription.of({
    name: "Shell",
    alias: ["bash", "sh", "zsh"],
    extensions: ["sh", "ksh", "bash"],
    filename: /^PKGBUILD$/,
    load() {
      return import("./shell-QYC6JJNJ.js").then((m) => legacy(m.shell));
    }
  }),
  LanguageDescription.of({
    name: "Sieve",
    extensions: ["siv", "sieve"],
    load() {
      return import("./sieve-MNLXOY2Z.js").then((m) => legacy(m.sieve));
    }
  }),
  LanguageDescription.of({
    name: "Smalltalk",
    extensions: ["st"],
    load() {
      return import("./smalltalk-GHXBRYSK.js").then((m) => legacy(m.smalltalk));
    }
  }),
  LanguageDescription.of({
    name: "Solr",
    load() {
      return import("./solr-LEPVAKDA.js").then((m) => legacy(m.solr));
    }
  }),
  LanguageDescription.of({
    name: "SML",
    extensions: ["sml", "sig", "fun", "smackspec"],
    load() {
      return import("./mllike-HLCBV3ZR.js").then((m) => legacy(m.sml));
    }
  }),
  LanguageDescription.of({
    name: "SPARQL",
    alias: ["sparul"],
    extensions: ["rq", "sparql"],
    load() {
      return import("./sparql-ZG6KEI3Y.js").then((m) => legacy(m.sparql));
    }
  }),
  LanguageDescription.of({
    name: "Spreadsheet",
    alias: ["excel", "formula"],
    load() {
      return import("./spreadsheet-KV4ICROA.js").then((m) => legacy(m.spreadsheet));
    }
  }),
  LanguageDescription.of({
    name: "Squirrel",
    extensions: ["nut"],
    load() {
      return import("./clike-7DJIT7LA.js").then((m) => legacy(m.squirrel));
    }
  }),
  LanguageDescription.of({
    name: "Stylus",
    extensions: ["styl"],
    load() {
      return import("./stylus-SIAROCMJ.js").then((m) => legacy(m.stylus));
    }
  }),
  LanguageDescription.of({
    name: "Swift",
    extensions: ["swift"],
    load() {
      return import("./swift-RF37CZ5W.js").then((m) => legacy(m.swift));
    }
  }),
  LanguageDescription.of({
    name: "sTeX",
    load() {
      return import("./stex-6LM57FA6.js").then((m) => legacy(m.stex));
    }
  }),
  LanguageDescription.of({
    name: "LaTeX",
    alias: ["tex"],
    extensions: ["text", "ltx", "tex"],
    load() {
      return import("./stex-6LM57FA6.js").then((m) => legacy(m.stex));
    }
  }),
  LanguageDescription.of({
    name: "SystemVerilog",
    extensions: ["v", "sv", "svh"],
    load() {
      return import("./verilog-O7X4GZB6.js").then((m) => legacy(m.verilog));
    }
  }),
  LanguageDescription.of({
    name: "Tcl",
    extensions: ["tcl"],
    load() {
      return import("./tcl-XI6QV7SI.js").then((m) => legacy(m.tcl));
    }
  }),
  LanguageDescription.of({
    name: "Textile",
    extensions: ["textile"],
    load() {
      return import("./textile-7S7IG4JY.js").then((m) => legacy(m.textile));
    }
  }),
  LanguageDescription.of({
    name: "TiddlyWiki",
    load() {
      return import("./tiddlywiki-SEY3VWLZ.js").then((m) => legacy(m.tiddlyWiki));
    }
  }),
  LanguageDescription.of({
    name: "Tiki wiki",
    load() {
      return import("./tiki-DFCTTUIP.js").then((m) => legacy(m.tiki));
    }
  }),
  LanguageDescription.of({
    name: "TOML",
    extensions: ["toml"],
    load() {
      return import("./toml-AVS2ZMGE.js").then((m) => legacy(m.toml));
    }
  }),
  LanguageDescription.of({
    name: "Troff",
    extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    load() {
      return import("./troff-OZREYPQU.js").then((m) => legacy(m.troff));
    }
  }),
  LanguageDescription.of({
    name: "TTCN",
    extensions: ["ttcn", "ttcn3", "ttcnpp"],
    load() {
      return import("./ttcn-ORBMO2XT.js").then((m) => legacy(m.ttcn));
    }
  }),
  LanguageDescription.of({
    name: "TTCN_CFG",
    extensions: ["cfg"],
    load() {
      return import("./ttcn-cfg-FV5CXATQ.js").then((m) => legacy(m.ttcnCfg));
    }
  }),
  LanguageDescription.of({
    name: "Turtle",
    extensions: ["ttl"],
    load() {
      return import("./turtle-N6IAMNKN.js").then((m) => legacy(m.turtle));
    }
  }),
  LanguageDescription.of({
    name: "Web IDL",
    extensions: ["webidl"],
    load() {
      return import("./webidl-JKIB4POG.js").then((m) => legacy(m.webIDL));
    }
  }),
  LanguageDescription.of({
    name: "VB.NET",
    extensions: ["vb"],
    load() {
      return import("./vb-ZZX4MZM6.js").then((m) => legacy(m.vb));
    }
  }),
  LanguageDescription.of({
    name: "VBScript",
    extensions: ["vbs"],
    load() {
      return import("./vbscript-NXZXA6QN.js").then((m) => legacy(m.vbScript));
    }
  }),
  LanguageDescription.of({
    name: "Velocity",
    extensions: ["vtl"],
    load() {
      return import("./velocity-46R55NRK.js").then((m) => legacy(m.velocity));
    }
  }),
  LanguageDescription.of({
    name: "Verilog",
    extensions: ["v"],
    load() {
      return import("./verilog-O7X4GZB6.js").then((m) => legacy(m.verilog));
    }
  }),
  LanguageDescription.of({
    name: "VHDL",
    extensions: ["vhd", "vhdl"],
    load() {
      return import("./vhdl-CSZQCV7I.js").then((m) => legacy(m.vhdl));
    }
  }),
  LanguageDescription.of({
    name: "XQuery",
    extensions: ["xy", "xquery"],
    load() {
      return import("./xquery-C3R4UZ5X.js").then((m) => legacy(m.xQuery));
    }
  }),
  LanguageDescription.of({
    name: "Yacas",
    extensions: ["ys"],
    load() {
      return import("./yacas-Y2ZXN7QX.js").then((m) => legacy(m.yacas));
    }
  }),
  LanguageDescription.of({
    name: "Z80",
    extensions: ["z80"],
    load() {
      return import("./z80-QEBG2ZFK.js").then((m) => legacy(m.z80));
    }
  }),
  LanguageDescription.of({
    name: "MscGen",
    extensions: ["mscgen", "mscin", "msc"],
    load() {
      return import("./mscgen-BYOMDZCK.js").then((m) => legacy(m.mscgen));
    }
  }),
  LanguageDescription.of({
    name: "Xù",
    extensions: ["xu"],
    load() {
      return import("./mscgen-BYOMDZCK.js").then((m) => legacy(m.xu));
    }
  }),
  LanguageDescription.of({
    name: "MsGenny",
    extensions: ["msgenny"],
    load() {
      return import("./mscgen-BYOMDZCK.js").then((m) => legacy(m.msgenny));
    }
  }),
  LanguageDescription.of({
    name: "Vue",
    extensions: ["vue"],
    load() {
      return import("./dist-66RJH6YO.js").then((m) => m.vue());
    }
  }),
  LanguageDescription.of({
    name: "Angular Template",
    load() {
      return import("./dist-X5AJBVOY.js").then((m) => m.angular());
    }
  })
];

// node_modules/medium-zoom/dist/medium-zoom.esm.js
var _extends = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var isSupported = function isSupported2(node) {
  return node.tagName === "IMG";
};
var isNodeList = function isNodeList2(selector) {
  return NodeList.prototype.isPrototypeOf(selector);
};
var isNode = function isNode2(selector) {
  return selector && selector.nodeType === 1;
};
var isSvg = function isSvg2(image) {
  var source = image.currentSrc || image.src;
  return source.substr(-4).toLowerCase() === ".svg";
};
var getImagesFromSelector = function getImagesFromSelector2(selector) {
  try {
    if (Array.isArray(selector)) {
      return selector.filter(isSupported);
    }
    if (isNodeList(selector)) {
      return [].slice.call(selector).filter(isSupported);
    }
    if (isNode(selector)) {
      return [selector].filter(isSupported);
    }
    if (typeof selector === "string") {
      return [].slice.call(document.querySelectorAll(selector)).filter(isSupported);
    }
    return [];
  } catch (err) {
    throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom");
  }
};
var createOverlay = function createOverlay2(background2) {
  var overlay = document.createElement("div");
  overlay.classList.add("medium-zoom-overlay");
  overlay.style.background = background2;
  return overlay;
};
var cloneTarget = function cloneTarget2(template2) {
  var _template$getBounding = template2.getBoundingClientRect(), top = _template$getBounding.top, left = _template$getBounding.left, width = _template$getBounding.width, height = _template$getBounding.height;
  var clone = template2.cloneNode();
  var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  var scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
  clone.removeAttribute("id");
  clone.style.position = "absolute";
  clone.style.top = top + scrollTop + "px";
  clone.style.left = left + scrollLeft + "px";
  clone.style.width = width + "px";
  clone.style.height = height + "px";
  clone.style.transform = "";
  return clone;
};
var createCustomEvent = function createCustomEvent2(type, params) {
  var eventParams = _extends({
    bubbles: false,
    cancelable: false,
    detail: void 0
  }, params);
  if (typeof window.CustomEvent === "function") {
    return new CustomEvent(type, eventParams);
  }
  var customEvent = document.createEvent("CustomEvent");
  customEvent.initCustomEvent(type, eventParams.bubbles, eventParams.cancelable, eventParams.detail);
  return customEvent;
};
var mediumZoom = function mediumZoom2(selector) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var Promise2 = window.Promise || function Promise3(fn) {
    function noop() {
    }
    fn(noop, noop);
  };
  var _handleClick = function _handleClick2(event) {
    var target = event.target;
    if (target === overlay) {
      close();
      return;
    }
    if (images.indexOf(target) === -1) {
      return;
    }
    toggle({ target });
  };
  var _handleScroll = function _handleScroll2() {
    if (isAnimating || !active.original) {
      return;
    }
    var currentScroll = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    if (Math.abs(scrollTop - currentScroll) > zoomOptions.scrollOffset) {
      setTimeout(close, 150);
    }
  };
  var _handleKeyUp = function _handleKeyUp2(event) {
    var key = event.key || event.keyCode;
    if (key === "Escape" || key === "Esc" || key === 27) {
      close();
    }
  };
  var update = function update2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var newOptions = options2;
    if (options2.background) {
      overlay.style.background = options2.background;
    }
    if (options2.container && options2.container instanceof Object) {
      newOptions.container = _extends({}, zoomOptions.container, options2.container);
    }
    if (options2.template) {
      var template2 = isNode(options2.template) ? options2.template : document.querySelector(options2.template);
      newOptions.template = template2;
    }
    zoomOptions = _extends({}, zoomOptions, newOptions);
    images.forEach(function(image) {
      image.dispatchEvent(createCustomEvent("medium-zoom:update", {
        detail: { zoom }
      }));
    });
    return zoom;
  };
  var clone = function clone2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return mediumZoom2(_extends({}, zoomOptions, options2));
  };
  var attach = function attach2() {
    for (var _len = arguments.length, selectors = Array(_len), _key = 0; _key < _len; _key++) {
      selectors[_key] = arguments[_key];
    }
    var newImages = selectors.reduce(function(imagesAccumulator, currentSelector) {
      return [].concat(imagesAccumulator, getImagesFromSelector(currentSelector));
    }, []);
    newImages.filter(function(newImage) {
      return images.indexOf(newImage) === -1;
    }).forEach(function(newImage) {
      images.push(newImage);
      newImage.classList.add("medium-zoom-image");
    });
    eventListeners.forEach(function(_ref) {
      var type = _ref.type, listener = _ref.listener, options2 = _ref.options;
      newImages.forEach(function(image) {
        image.addEventListener(type, listener, options2);
      });
    });
    return zoom;
  };
  var detach = function detach2() {
    for (var _len2 = arguments.length, selectors = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      selectors[_key2] = arguments[_key2];
    }
    if (active.zoomed) {
      close();
    }
    var imagesToDetach = selectors.length > 0 ? selectors.reduce(function(imagesAccumulator, currentSelector) {
      return [].concat(imagesAccumulator, getImagesFromSelector(currentSelector));
    }, []) : images;
    imagesToDetach.forEach(function(image) {
      image.classList.remove("medium-zoom-image");
      image.dispatchEvent(createCustomEvent("medium-zoom:detach", {
        detail: { zoom }
      }));
    });
    images = images.filter(function(image) {
      return imagesToDetach.indexOf(image) === -1;
    });
    return zoom;
  };
  var on = function on2(type, listener) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    images.forEach(function(image) {
      image.addEventListener("medium-zoom:" + type, listener, options2);
    });
    eventListeners.push({ type: "medium-zoom:" + type, listener, options: options2 });
    return zoom;
  };
  var off = function off2(type, listener) {
    var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    images.forEach(function(image) {
      image.removeEventListener("medium-zoom:" + type, listener, options2);
    });
    eventListeners = eventListeners.filter(function(eventListener) {
      return !(eventListener.type === "medium-zoom:" + type && eventListener.listener.toString() === listener.toString());
    });
    return zoom;
  };
  var open = function open2() {
    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, target = _ref2.target;
    var _animate = function _animate2() {
      var container = {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      var viewportWidth = void 0;
      var viewportHeight = void 0;
      if (zoomOptions.container) {
        if (zoomOptions.container instanceof Object) {
          container = _extends({}, container, zoomOptions.container);
          viewportWidth = container.width - container.left - container.right - zoomOptions.margin * 2;
          viewportHeight = container.height - container.top - container.bottom - zoomOptions.margin * 2;
        } else {
          var zoomContainer = isNode(zoomOptions.container) ? zoomOptions.container : document.querySelector(zoomOptions.container);
          var _zoomContainer$getBou = zoomContainer.getBoundingClientRect(), _width = _zoomContainer$getBou.width, _height = _zoomContainer$getBou.height, _left = _zoomContainer$getBou.left, _top = _zoomContainer$getBou.top;
          container = _extends({}, container, {
            width: _width,
            height: _height,
            left: _left,
            top: _top
          });
        }
      }
      viewportWidth = viewportWidth || container.width - zoomOptions.margin * 2;
      viewportHeight = viewportHeight || container.height - zoomOptions.margin * 2;
      var zoomTarget = active.zoomedHd || active.original;
      var naturalWidth = isSvg(zoomTarget) ? viewportWidth : zoomTarget.naturalWidth || viewportWidth;
      var naturalHeight = isSvg(zoomTarget) ? viewportHeight : zoomTarget.naturalHeight || viewportHeight;
      var _zoomTarget$getBoundi = zoomTarget.getBoundingClientRect(), top = _zoomTarget$getBoundi.top, left = _zoomTarget$getBoundi.left, width = _zoomTarget$getBoundi.width, height = _zoomTarget$getBoundi.height;
      var scaleX = Math.min(Math.max(width, naturalWidth), viewportWidth) / width;
      var scaleY = Math.min(Math.max(height, naturalHeight), viewportHeight) / height;
      var scale = Math.min(scaleX, scaleY);
      var translateX = (-left + (viewportWidth - width) / 2 + zoomOptions.margin + container.left) / scale;
      var translateY = (-top + (viewportHeight - height) / 2 + zoomOptions.margin + container.top) / scale;
      var transform = "scale(" + scale + ") translate3d(" + translateX + "px, " + translateY + "px, 0)";
      active.zoomed.style.transform = transform;
      if (active.zoomedHd) {
        active.zoomedHd.style.transform = transform;
      }
    };
    return new Promise2(function(resolve) {
      if (target && images.indexOf(target) === -1) {
        resolve(zoom);
        return;
      }
      var _handleOpenEnd = function _handleOpenEnd2() {
        isAnimating = false;
        active.zoomed.removeEventListener("transitionend", _handleOpenEnd2);
        active.original.dispatchEvent(createCustomEvent("medium-zoom:opened", {
          detail: { zoom }
        }));
        resolve(zoom);
      };
      if (active.zoomed) {
        resolve(zoom);
        return;
      }
      if (target) {
        active.original = target;
      } else if (images.length > 0) {
        var _images = images;
        active.original = _images[0];
      } else {
        resolve(zoom);
        return;
      }
      active.original.dispatchEvent(createCustomEvent("medium-zoom:open", {
        detail: { zoom }
      }));
      scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
      isAnimating = true;
      active.zoomed = cloneTarget(active.original);
      document.body.appendChild(overlay);
      if (zoomOptions.template) {
        var template2 = isNode(zoomOptions.template) ? zoomOptions.template : document.querySelector(zoomOptions.template);
        active.template = document.createElement("div");
        active.template.appendChild(template2.content.cloneNode(true));
        document.body.appendChild(active.template);
      }
      if (active.original.parentElement && active.original.parentElement.tagName === "PICTURE" && active.original.currentSrc) {
        active.zoomed.src = active.original.currentSrc;
      }
      document.body.appendChild(active.zoomed);
      window.requestAnimationFrame(function() {
        document.body.classList.add("medium-zoom--opened");
      });
      active.original.classList.add("medium-zoom-image--hidden");
      active.zoomed.classList.add("medium-zoom-image--opened");
      active.zoomed.addEventListener("click", close);
      active.zoomed.addEventListener("transitionend", _handleOpenEnd);
      if (active.original.getAttribute("data-zoom-src")) {
        active.zoomedHd = active.zoomed.cloneNode();
        active.zoomedHd.removeAttribute("srcset");
        active.zoomedHd.removeAttribute("sizes");
        active.zoomedHd.removeAttribute("loading");
        active.zoomedHd.src = active.zoomed.getAttribute("data-zoom-src");
        active.zoomedHd.onerror = function() {
          clearInterval(getZoomTargetSize);
          console.warn("Unable to reach the zoom image target " + active.zoomedHd.src);
          active.zoomedHd = null;
          _animate();
        };
        var getZoomTargetSize = setInterval(function() {
          if (active.zoomedHd.complete) {
            clearInterval(getZoomTargetSize);
            active.zoomedHd.classList.add("medium-zoom-image--opened");
            active.zoomedHd.addEventListener("click", close);
            document.body.appendChild(active.zoomedHd);
            _animate();
          }
        }, 10);
      } else if (active.original.hasAttribute("srcset")) {
        active.zoomedHd = active.zoomed.cloneNode();
        active.zoomedHd.removeAttribute("sizes");
        active.zoomedHd.removeAttribute("loading");
        var loadEventListener = active.zoomedHd.addEventListener("load", function() {
          active.zoomedHd.removeEventListener("load", loadEventListener);
          active.zoomedHd.classList.add("medium-zoom-image--opened");
          active.zoomedHd.addEventListener("click", close);
          document.body.appendChild(active.zoomedHd);
          _animate();
        });
      } else {
        _animate();
      }
    });
  };
  var close = function close2() {
    return new Promise2(function(resolve) {
      if (isAnimating || !active.original) {
        resolve(zoom);
        return;
      }
      var _handleCloseEnd = function _handleCloseEnd2() {
        active.original.classList.remove("medium-zoom-image--hidden");
        document.body.removeChild(active.zoomed);
        if (active.zoomedHd) {
          document.body.removeChild(active.zoomedHd);
        }
        document.body.removeChild(overlay);
        active.zoomed.classList.remove("medium-zoom-image--opened");
        if (active.template) {
          document.body.removeChild(active.template);
        }
        isAnimating = false;
        active.zoomed.removeEventListener("transitionend", _handleCloseEnd2);
        active.original.dispatchEvent(createCustomEvent("medium-zoom:closed", {
          detail: { zoom }
        }));
        active.original = null;
        active.zoomed = null;
        active.zoomedHd = null;
        active.template = null;
        resolve(zoom);
      };
      isAnimating = true;
      document.body.classList.remove("medium-zoom--opened");
      active.zoomed.style.transform = "";
      if (active.zoomedHd) {
        active.zoomedHd.style.transform = "";
      }
      if (active.template) {
        active.template.style.transition = "opacity 150ms";
        active.template.style.opacity = 0;
      }
      active.original.dispatchEvent(createCustomEvent("medium-zoom:close", {
        detail: { zoom }
      }));
      active.zoomed.addEventListener("transitionend", _handleCloseEnd);
    });
  };
  var toggle = function toggle2() {
    var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, target = _ref3.target;
    if (active.original) {
      return close();
    }
    return open({ target });
  };
  var getOptions = function getOptions2() {
    return zoomOptions;
  };
  var getImages = function getImages2() {
    return images;
  };
  var getZoomedImage = function getZoomedImage2() {
    return active.original;
  };
  var images = [];
  var eventListeners = [];
  var isAnimating = false;
  var scrollTop = 0;
  var zoomOptions = options;
  var active = {
    original: null,
    zoomed: null,
    zoomedHd: null,
    template: null
    // If the selector is omitted, it's replaced by the options
  };
  if (Object.prototype.toString.call(selector) === "[object Object]") {
    zoomOptions = selector;
  } else if (selector || typeof selector === "string") {
    attach(selector);
  }
  zoomOptions = _extends({
    margin: 0,
    background: "#fff",
    scrollOffset: 40,
    container: null,
    template: null
  }, zoomOptions);
  var overlay = createOverlay(zoomOptions.background);
  document.addEventListener("click", _handleClick);
  document.addEventListener("keyup", _handleKeyUp);
  document.addEventListener("scroll", _handleScroll);
  window.addEventListener("resize", close);
  var zoom = {
    open,
    close,
    toggle,
    update,
    clone,
    attach,
    detach,
    on,
    off,
    getOptions,
    getImages,
    getZoomedImage
  };
  return zoom;
};
function styleInject(css3, ref2) {
  if (ref2 === void 0) ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css3 || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css3;
  } else {
    style.appendChild(document.createTextNode(css3));
  }
}
var css = ".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}";
styleInject(css);
var medium_zoom_esm_default = mediumZoom;

// node_modules/md-editor-v3/lib/es/chunks/index.mjs
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard(), 1);

// node_modules/markdown-it-image-figures/dist/markdown-it-images-figures.mjs
var t = /* @__PURE__ */ new Set([true, false, "alt", "title"]);
function e(t2, e2) {
  return (Array.isArray(t2) ? t2 : []).filter(([t3]) => t3 !== e2);
}
function n(t2, n2) {
  t2 && t2.attrs && (t2.attrs = e(t2.attrs, n2));
}
function i(e2, i2) {
  if (!t.has(e2)) throw new TypeError(`figcaption must be one of: ${[...t]}.`);
  if ("alt" === e2) return i2.content;
  const r2 = i2.attrs.find(([t2]) => "title" === t2);
  return Array.isArray(r2) && r2[1] ? (n(i2, "title"), r2[1]) : void 0;
}
function r(t2, r2) {
  r2 = r2 || {}, t2.core.ruler.before("linkify", "image_figures", function(s) {
    let a = 1;
    for (let o = 1, c = s.tokens.length; o < c - 1; ++o) {
      const l = s.tokens[o];
      if ("inline" !== l.type) continue;
      if (!l.children || 1 !== l.children.length && 3 !== l.children.length) continue;
      if (1 === l.children.length && "image" !== l.children[0].type) continue;
      if (3 === l.children.length) {
        const [t3, e2, n2] = l.children;
        if ("link_open" !== t3.type || "image" !== e2.type || "link_close" !== n2.type) continue;
      }
      if (0 !== o && "paragraph_open" !== s.tokens[o - 1].type) continue;
      if (o !== c - 1 && "paragraph_close" !== s.tokens[o + 1].type) continue;
      const f = s.tokens[o - 1];
      let h2;
      if (f.type = "figure_open", f.tag = "figure", s.tokens[o + 1].type = "figure_close", s.tokens[o + 1].tag = "figure", r2.dataType && s.tokens[o - 1].attrPush(["data-type", "image"]), r2.link && 1 === l.children.length) {
        [h2] = l.children;
        const t3 = new s.Token("link_open", "a", 1);
        t3.attrPush(["href", h2.attrGet("src")]), l.children.unshift(t3), l.children.push(new s.Token("link_close", "a", -1));
      }
      if (h2 = 1 === l.children.length ? l.children[0] : l.children[1], r2.figcaption) {
        const n2 = i(r2.figcaption, h2);
        if (n2) {
          const [i2] = t2.parseInline(n2, s.env);
          l.children.push(new s.Token("figcaption_open", "figcaption", 1)), l.children.push(...i2.children), l.children.push(new s.Token("figcaption_close", "figcaption", -1)), h2.attrs && (h2.attrs = e(h2.attrs, "title"));
        }
      }
      if (r2.copyAttrs && h2.attrs) {
        const t3 = true === r2.copyAttrs ? "" : r2.copyAttrs;
        f.attrs = h2.attrs.filter(([e2]) => e2.match(t3)).map((t4) => Array.from(t4));
      }
      if (r2.tabindex && (s.tokens[o - 1].attrPush(["tabindex", a]), a++), r2.lazy && (h2.attrs.some(([t3]) => "loading" === t3) || h2.attrs.push(["loading", "lazy"])), r2.async && (h2.attrs.some(([t3]) => "decoding" === t3) || h2.attrs.push(["decoding", "async"])), r2.classes && "string" == typeof r2.classes) {
        let t3 = false;
        for (let e2 = 0, n2 = h2.attrs.length; e2 < n2 && !t3; e2++) {
          const n3 = h2.attrs[e2];
          "class" === n3[0] && (n3[1] = `${n3[1]} ${r2.classes}`, t3 = true);
        }
        t3 || h2.attrs.push(["class", r2.classes]);
      }
      if (r2.removeSrc) {
        const t3 = h2.attrs.find(([t4]) => "src" === t4);
        h2.attrs.push(["data-src", t3[1]]), n(h2, "src");
      }
    }
  });
}

// node_modules/markdown-it-sub/index.mjs
var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function subscript(state, silent) {
  const max = state.posMax;
  const start = state.pos;
  if (state.src.charCodeAt(start) !== 126) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 2 >= max) {
    return false;
  }
  state.pos = start + 1;
  let found = false;
  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 126) {
      found = true;
      break;
    }
    state.md.inline.skipToken(state);
  }
  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }
  const content = state.src.slice(start + 1, state.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }
  state.posMax = state.pos;
  state.pos = start + 1;
  const token_so = state.push("sub_open", "sub", 1);
  token_so.markup = "~";
  const token_t = state.push("text", "", 0);
  token_t.content = content.replace(UNESCAPE_RE, "$1");
  const token_sc = state.push("sub_close", "sub", -1);
  token_sc.markup = "~";
  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
}
function sub_plugin(md) {
  md.inline.ruler.after("emphasis", "sub", subscript);
}

// node_modules/markdown-it-sup/index.mjs
var UNESCAPE_RE2 = /\\([ \\!"#$%&'()*+,./:;<=>?@[\]^_`{|}~-])/g;
function superscript(state, silent) {
  const max = state.posMax;
  const start = state.pos;
  if (state.src.charCodeAt(start) !== 94) {
    return false;
  }
  if (silent) {
    return false;
  }
  if (start + 2 >= max) {
    return false;
  }
  state.pos = start + 1;
  let found = false;
  while (state.pos < max) {
    if (state.src.charCodeAt(state.pos) === 94) {
      found = true;
      break;
    }
    state.md.inline.skipToken(state);
  }
  if (!found || start + 1 === state.pos) {
    state.pos = start;
    return false;
  }
  const content = state.src.slice(start + 1, state.pos);
  if (content.match(/(^|[^\\])(\\\\)*\s/)) {
    state.pos = start;
    return false;
  }
  state.posMax = state.pos;
  state.pos = start + 1;
  const token_so = state.push("sup_open", "sup", 1);
  token_so.markup = "^";
  const token_t = state.push("text", "", 0);
  token_t.content = content.replace(UNESCAPE_RE2, "$1");
  const token_sc = state.push("sup_close", "sup", -1);
  token_sc.markup = "^";
  state.pos = state.posMax + 1;
  state.posMax = max;
  return true;
}
function sup_plugin(md) {
  md.inline.ruler.after("emphasis", "sup", superscript);
}

// node_modules/md-editor-v3/node_modules/lru-cache/dist/esm/index.js
var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
var warned = /* @__PURE__ */ new Set();
var PROCESS = typeof process === "object" && !!process ? process : {};
var emitWarning = (msg, type, code, fn) => {
  typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
};
var AC = globalThis.AbortController;
var AS = globalThis.AbortSignal;
var _a;
if (typeof AC === "undefined") {
  AS = class AbortSignal {
    constructor() {
      __publicField(this, "onabort");
      __publicField(this, "_onabort", []);
      __publicField(this, "reason");
      __publicField(this, "aborted", false);
    }
    addEventListener(_2, fn) {
      this._onabort.push(fn);
    }
  };
  AC = class AbortController {
    constructor() {
      __publicField(this, "signal", new AS());
      warnACPolyfill();
    }
    abort(reason) {
      var _a3, _b2;
      if (this.signal.aborted)
        return;
      this.signal.reason = reason;
      this.signal.aborted = true;
      for (const fn of this.signal._onabort) {
        fn(reason);
      }
      (_b2 = (_a3 = this.signal).onabort) == null ? void 0 : _b2.call(_a3, reason);
    }
  };
  let printACPolyfillWarning = ((_a = PROCESS.env) == null ? void 0 : _a.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const warnACPolyfill = () => {
    if (!printACPolyfillWarning)
      return;
    printACPolyfillWarning = false;
    emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
  };
}
var shouldWarn = (code) => !warned.has(code);
var TYPE = Symbol("type");
var isPosInt = (n2) => n2 && n2 === Math.floor(n2) && n2 > 0 && isFinite(n2);
var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
var ZeroArray = class extends Array {
  constructor(size) {
    super(size);
    this.fill(0);
  }
};
var _constructing;
var _Stack = class _Stack {
  constructor(max, HeapCls) {
    __publicField(this, "heap");
    __publicField(this, "length");
    if (!__privateGet(_Stack, _constructing)) {
      throw new TypeError("instantiate Stack using Stack.create(n)");
    }
    this.heap = new HeapCls(max);
    this.length = 0;
  }
  static create(max) {
    const HeapCls = getUintArray(max);
    if (!HeapCls)
      return [];
    __privateSet(_Stack, _constructing, true);
    const s = new _Stack(max, HeapCls);
    __privateSet(_Stack, _constructing, false);
    return s;
  }
  push(n2) {
    this.heap[this.length++] = n2;
  }
  pop() {
    return this.heap[--this.length];
  }
};
_constructing = new WeakMap();
// private constructor
__privateAdd(_Stack, _constructing, false);
var Stack = _Stack;
var _a2, _b, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _memoMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn, delete_fn, clear_fn;
var _LRUCache = class _LRUCache {
  constructor(options) {
    __privateAdd(this, _LRUCache_instances);
    // options that cannot be changed without disaster
    __privateAdd(this, _max);
    __privateAdd(this, _maxSize);
    __privateAdd(this, _dispose);
    __privateAdd(this, _disposeAfter);
    __privateAdd(this, _fetchMethod);
    __privateAdd(this, _memoMethod);
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    __publicField(this, "ttl");
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    __publicField(this, "ttlResolution");
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    __publicField(this, "ttlAutopurge");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    __publicField(this, "updateAgeOnGet");
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    __publicField(this, "updateAgeOnHas");
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    __publicField(this, "allowStale");
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    __publicField(this, "noDisposeOnSet");
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    __publicField(this, "noUpdateTTL");
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    __publicField(this, "maxEntrySize");
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    __publicField(this, "sizeCalculation");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    __publicField(this, "noDeleteOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    __publicField(this, "noDeleteOnStaleGet");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    __publicField(this, "allowStaleOnFetchAbort");
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    __publicField(this, "allowStaleOnFetchRejection");
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    __publicField(this, "ignoreFetchAbort");
    // computed properties
    __privateAdd(this, _size);
    __privateAdd(this, _calculatedSize);
    __privateAdd(this, _keyMap);
    __privateAdd(this, _keyList);
    __privateAdd(this, _valList);
    __privateAdd(this, _next);
    __privateAdd(this, _prev);
    __privateAdd(this, _head);
    __privateAdd(this, _tail);
    __privateAdd(this, _free);
    __privateAdd(this, _disposed);
    __privateAdd(this, _sizes);
    __privateAdd(this, _starts);
    __privateAdd(this, _ttls);
    __privateAdd(this, _hasDispose);
    __privateAdd(this, _hasFetchMethod);
    __privateAdd(this, _hasDisposeAfter);
    // conditionally set private methods related to TTL
    __privateAdd(this, _updateItemAge, () => {
    });
    __privateAdd(this, _statusTTL, () => {
    });
    __privateAdd(this, _setItemTTL, () => {
    });
    /* c8 ignore stop */
    __privateAdd(this, _isStale, () => false);
    __privateAdd(this, _removeItemSize, (_i) => {
    });
    __privateAdd(this, _addItemSize, (_i, _s, _st) => {
    });
    __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    });
    /**
     * A String value that is used in the creation of the default string
     * description of an object. Called by the built-in method
     * `Object.prototype.toString`.
     */
    __publicField(this, _a2, "LRUCache");
    const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
    if (max !== 0 && !isPosInt(max)) {
      throw new TypeError("max option must be a nonnegative integer");
    }
    const UintArray = max ? getUintArray(max) : Array;
    if (!UintArray) {
      throw new Error("invalid max value: " + max);
    }
    __privateSet(this, _max, max);
    __privateSet(this, _maxSize, maxSize);
    this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
    this.sizeCalculation = sizeCalculation;
    if (this.sizeCalculation) {
      if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      }
      if (typeof this.sizeCalculation !== "function") {
        throw new TypeError("sizeCalculation set to non-function");
      }
    }
    if (memoMethod !== void 0 && typeof memoMethod !== "function") {
      throw new TypeError("memoMethod must be a function if defined");
    }
    __privateSet(this, _memoMethod, memoMethod);
    if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
      throw new TypeError("fetchMethod must be a function if specified");
    }
    __privateSet(this, _fetchMethod, fetchMethod);
    __privateSet(this, _hasFetchMethod, !!fetchMethod);
    __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
    __privateSet(this, _keyList, new Array(max).fill(void 0));
    __privateSet(this, _valList, new Array(max).fill(void 0));
    __privateSet(this, _next, new UintArray(max));
    __privateSet(this, _prev, new UintArray(max));
    __privateSet(this, _head, 0);
    __privateSet(this, _tail, 0);
    __privateSet(this, _free, Stack.create(max));
    __privateSet(this, _size, 0);
    __privateSet(this, _calculatedSize, 0);
    if (typeof dispose === "function") {
      __privateSet(this, _dispose, dispose);
    }
    if (typeof disposeAfter === "function") {
      __privateSet(this, _disposeAfter, disposeAfter);
      __privateSet(this, _disposed, []);
    } else {
      __privateSet(this, _disposeAfter, void 0);
      __privateSet(this, _disposed, void 0);
    }
    __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
    __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
    this.noDisposeOnSet = !!noDisposeOnSet;
    this.noUpdateTTL = !!noUpdateTTL;
    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
    this.ignoreFetchAbort = !!ignoreFetchAbort;
    if (this.maxEntrySize !== 0) {
      if (__privateGet(this, _maxSize) !== 0) {
        if (!isPosInt(__privateGet(this, _maxSize))) {
          throw new TypeError("maxSize must be a positive integer if specified");
        }
      }
      if (!isPosInt(this.maxEntrySize)) {
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      }
      __privateMethod(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
    }
    this.allowStale = !!allowStale;
    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
    this.updateAgeOnGet = !!updateAgeOnGet;
    this.updateAgeOnHas = !!updateAgeOnHas;
    this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
    this.ttlAutopurge = !!ttlAutopurge;
    this.ttl = ttl || 0;
    if (this.ttl) {
      if (!isPosInt(this.ttl)) {
        throw new TypeError("ttl must be a positive integer if specified");
      }
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    }
    if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
      const code = "LRU_CACHE_UNBOUNDED";
      if (shouldWarn(code)) {
        warned.add(code);
        const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
        emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
      }
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(c) {
    return {
      // properties
      starts: __privateGet(c, _starts),
      ttls: __privateGet(c, _ttls),
      sizes: __privateGet(c, _sizes),
      keyMap: __privateGet(c, _keyMap),
      keyList: __privateGet(c, _keyList),
      valList: __privateGet(c, _valList),
      next: __privateGet(c, _next),
      prev: __privateGet(c, _prev),
      get head() {
        return __privateGet(c, _head);
      },
      get tail() {
        return __privateGet(c, _tail);
      },
      free: __privateGet(c, _free),
      // methods
      isBackgroundFetch: (p) => {
        var _a3;
        return __privateMethod(_a3 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a3, p);
      },
      backgroundFetch: (k2, index2, options, context) => {
        var _a3;
        return __privateMethod(_a3 = c, _LRUCache_instances, backgroundFetch_fn).call(_a3, k2, index2, options, context);
      },
      moveToTail: (index2) => {
        var _a3;
        return __privateMethod(_a3 = c, _LRUCache_instances, moveToTail_fn).call(_a3, index2);
      },
      indexes: (options) => {
        var _a3;
        return __privateMethod(_a3 = c, _LRUCache_instances, indexes_fn).call(_a3, options);
      },
      rindexes: (options) => {
        var _a3;
        return __privateMethod(_a3 = c, _LRUCache_instances, rindexes_fn).call(_a3, options);
      },
      isStale: (index2) => {
        var _a3;
        return __privateGet(_a3 = c, _isStale).call(_a3, index2);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return __privateGet(this, _max);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return __privateGet(this, _maxSize);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return __privateGet(this, _calculatedSize);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return __privateGet(this, _size);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return __privateGet(this, _fetchMethod);
  }
  get memoMethod() {
    return __privateGet(this, _memoMethod);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return __privateGet(this, _dispose);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return __privateGet(this, _disposeAfter);
  }
  /**
   * Return the number of ms left in the item's TTL. If item is not in cache,
   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
   */
  getRemainingTTL(key) {
    return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i2] !== void 0 && __privateGet(this, _keyList)[i2] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2])) {
        yield [__privateGet(this, _keyList)[i2], __privateGet(this, _valList)[i2]];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      if (__privateGet(this, _valList)[i2] !== void 0 && __privateGet(this, _keyList)[i2] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2])) {
        yield [__privateGet(this, _keyList)[i2], __privateGet(this, _valList)[i2]];
      }
    }
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const k2 = __privateGet(this, _keyList)[i2];
      if (k2 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2])) {
        yield k2;
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const k2 = __privateGet(this, _keyList)[i2];
      if (k2 !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2])) {
        yield k2;
      }
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i2];
      if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2])) {
        yield __privateGet(this, _valList)[i2];
      }
    }
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const i2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i2];
      if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i2])) {
        yield __privateGet(this, _valList)[i2];
      }
    }
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [(_b = Symbol.iterator, _a2 = Symbol.toStringTag, _b)]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
   */
  find(fn, getOptions = {}) {
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i2];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      if (fn(value, __privateGet(this, _keyList)[i2], this)) {
        return this.get(__privateGet(this, _keyList)[i2], getOptions);
      }
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from most
   * recently used to least recently used.
   *
   * `fn` is called as `fn(value, key, cache)`.
   *
   * If `thisp` is provided, function will be called in the `this`-context of
   * the provided object, or the cache if no `thisp` object is provided.
   *
   * Does not update age or recenty of use, or iterate over stale values.
   */
  forEach(fn, thisp = this) {
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i2];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i2], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(fn, thisp = this) {
    for (const i2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
      const v = __privateGet(this, _valList)[i2];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        continue;
      fn.call(thisp, value, __privateGet(this, _keyList)[i2], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let deleted = false;
    for (const i2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
      if (__privateGet(this, _isStale).call(this, i2)) {
        __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[i2], "expire");
        deleted = true;
      }
    }
    return deleted;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Returns `undefined` if the key is not present.
   *
   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
   * serialization, the `start` value is always the current timestamp, and the
   * `ttl` is a calculated remaining time to live (negative if expired).
   *
   * Always returns stale values, if their info is found in the cache, so be
   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
   * if relevant.
   */
  info(key) {
    const i2 = __privateGet(this, _keyMap).get(key);
    if (i2 === void 0)
      return void 0;
    const v = __privateGet(this, _valList)[i2];
    const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
    if (value === void 0)
      return void 0;
    const entry = { value };
    if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
      const ttl = __privateGet(this, _ttls)[i2];
      const start = __privateGet(this, _starts)[i2];
      if (ttl && start) {
        const remain = ttl - (perf.now() - start);
        entry.ttl = remain;
        entry.start = Date.now();
      }
    }
    if (__privateGet(this, _sizes)) {
      entry.size = __privateGet(this, _sizes)[i2];
    }
    return entry;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to {@link LRLUCache#load}.
   *
   * The `start` fields are calculated relative to a portable `Date.now()`
   * timestamp, even if `performance.now()` is available.
   *
   * Stale entries are always included in the `dump`, even if
   * {@link LRUCache.OptionsBase.allowStale} is false.
   *
   * Note: this returns an actual array, not a generator, so it can be more
   * easily passed around.
   */
  dump() {
    const arr = [];
    for (const i2 of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
      const key = __privateGet(this, _keyList)[i2];
      const v = __privateGet(this, _valList)[i2];
      const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      if (value === void 0 || key === void 0)
        continue;
      const entry = { value };
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        entry.ttl = __privateGet(this, _ttls)[i2];
        const age = perf.now() - __privateGet(this, _starts)[i2];
        entry.start = Math.floor(Date.now() - age);
      }
      if (__privateGet(this, _sizes)) {
        entry.size = __privateGet(this, _sizes)[i2];
      }
      arr.unshift([key, entry]);
    }
    return arr;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   *
   * The shape of the resulting cache may be different if the same options are
   * not used in both caches.
   *
   * The `start` fields are assumed to be calculated relative to a portable
   * `Date.now()` timestamp, even if `performance.now()` is available.
   */
  load(arr) {
    this.clear();
    for (const [key, entry] of arr) {
      if (entry.start) {
        const age = Date.now() - entry.start;
        entry.start = perf.now() - age;
      }
      this.set(key, entry.value, entry);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   *
   * Fields on the {@link LRUCache.SetOptions} options param will override
   * their corresponding values in the constructor options for the scope
   * of this single `set()` operation.
   *
   * If `start` is provided, then that will set the effective start
   * time for the TTL calculation. Note that this must be a previous
   * value of `performance.now()` if supported, or a previous value of
   * `Date.now()` if not.
   *
   * Options object may also include `size`, which will prevent
   * calling the `sizeCalculation` function and just use the specified
   * number if it is a positive integer, and `noDisposeOnSet` which
   * will prevent calling a `dispose` function in the case of
   * overwrites.
   *
   * If the `size` (or return value of `sizeCalculation`) for a given
   * entry is greater than `maxEntrySize`, then the item will not be
   * added to the cache.
   *
   * Will update the recency of the entry.
   *
   * If the value is `undefined`, then this is an alias for
   * `cache.delete(key)`. `undefined` is never stored in the cache.
   */
  set(k2, v, setOptions = {}) {
    var _a3, _b2, _c, _d, _e;
    if (v === void 0) {
      this.delete(k2);
      return this;
    }
    const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
    let { noUpdateTTL = this.noUpdateTTL } = setOptions;
    const size = __privateGet(this, _requireSize).call(this, k2, v, setOptions.size || 0, sizeCalculation);
    if (this.maxEntrySize && size > this.maxEntrySize) {
      if (status) {
        status.set = "miss";
        status.maxEntrySizeExceeded = true;
      }
      __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "set");
      return this;
    }
    let index2 = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k2);
    if (index2 === void 0) {
      index2 = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _LRUCache_instances, evict_fn).call(this, false) : __privateGet(this, _size);
      __privateGet(this, _keyList)[index2] = k2;
      __privateGet(this, _valList)[index2] = v;
      __privateGet(this, _keyMap).set(k2, index2);
      __privateGet(this, _next)[__privateGet(this, _tail)] = index2;
      __privateGet(this, _prev)[index2] = __privateGet(this, _tail);
      __privateSet(this, _tail, index2);
      __privateWrapper(this, _size)._++;
      __privateGet(this, _addItemSize).call(this, index2, size, status);
      if (status)
        status.set = "add";
      noUpdateTTL = false;
    } else {
      __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2);
      const oldVal = __privateGet(this, _valList)[index2];
      if (v !== oldVal) {
        if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
          oldVal.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: s } = oldVal;
          if (s !== void 0 && !noDisposeOnSet) {
            if (__privateGet(this, _hasDispose)) {
              (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, s, k2, "set");
            }
            if (__privateGet(this, _hasDisposeAfter)) {
              (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([s, k2, "set"]);
            }
          }
        } else if (!noDisposeOnSet) {
          if (__privateGet(this, _hasDispose)) {
            (_c = __privateGet(this, _dispose)) == null ? void 0 : _c.call(this, oldVal, k2, "set");
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_d = __privateGet(this, _disposed)) == null ? void 0 : _d.push([oldVal, k2, "set"]);
          }
        }
        __privateGet(this, _removeItemSize).call(this, index2);
        __privateGet(this, _addItemSize).call(this, index2, size, status);
        __privateGet(this, _valList)[index2] = v;
        if (status) {
          status.set = "replace";
          const oldValue = oldVal && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
          if (oldValue !== void 0)
            status.oldValue = oldValue;
        }
      } else if (status) {
        status.set = "update";
      }
    }
    if (ttl !== 0 && !__privateGet(this, _ttls)) {
      __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
    }
    if (__privateGet(this, _ttls)) {
      if (!noUpdateTTL) {
        __privateGet(this, _setItemTTL).call(this, index2, ttl, start);
      }
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index2);
    }
    if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
      const dt = __privateGet(this, _disposed);
      let task;
      while (task = dt == null ? void 0 : dt.shift()) {
        (_e = __privateGet(this, _disposeAfter)) == null ? void 0 : _e.call(this, ...task);
      }
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var _a3;
    try {
      while (__privateGet(this, _size)) {
        const val = __privateGet(this, _valList)[__privateGet(this, _head)];
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
          if (val.__staleWhileFetching) {
            return val.__staleWhileFetching;
          }
        } else if (val !== void 0) {
          return val;
        }
      }
    } finally {
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt == null ? void 0 : dt.shift()) {
          (_a3 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a3.call(this, ...task);
        }
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Check if a key is in the cache, without updating the recency of
   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
   * to `true` in either the options or the constructor.
   *
   * Will return `false` if the item is stale, even though it is technically in
   * the cache. The difference can be determined (if it matters) by using a
   * `status` argument, and inspecting the `has` field.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(k2, hasOptions = {}) {
    const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
    const index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 !== void 0) {
      const v = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
        return false;
      }
      if (!__privateGet(this, _isStale).call(this, index2)) {
        if (updateAgeOnHas) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        if (status) {
          status.has = "hit";
          __privateGet(this, _statusTTL).call(this, status, index2);
        }
        return true;
      } else if (status) {
        status.has = "stale";
        __privateGet(this, _statusTTL).call(this, status, index2);
      }
    } else if (status) {
      status.has = "miss";
    }
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(k2, peekOptions = {}) {
    const { allowStale = this.allowStale } = peekOptions;
    const index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index2)) {
      return;
    }
    const v = __privateGet(this, _valList)[index2];
    return __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
  }
  async fetch(k2, fetchOptions = {}) {
    const {
      // get options
      allowStale = this.allowStale,
      updateAgeOnGet = this.updateAgeOnGet,
      noDeleteOnStaleGet = this.noDeleteOnStaleGet,
      // set options
      ttl = this.ttl,
      noDisposeOnSet = this.noDisposeOnSet,
      size = 0,
      sizeCalculation = this.sizeCalculation,
      noUpdateTTL = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
      ignoreFetchAbort = this.ignoreFetchAbort,
      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
      context,
      forceRefresh = false,
      status,
      signal
    } = fetchOptions;
    if (!__privateGet(this, _hasFetchMethod)) {
      if (status)
        status.fetch = "get";
      return this.get(k2, {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        status
      });
    }
    const options = {
      allowStale,
      updateAgeOnGet,
      noDeleteOnStaleGet,
      ttl,
      noDisposeOnSet,
      size,
      sizeCalculation,
      noUpdateTTL,
      noDeleteOnFetchRejection,
      allowStaleOnFetchRejection,
      allowStaleOnFetchAbort,
      ignoreFetchAbort,
      status,
      signal
    };
    let index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 === void 0) {
      if (status)
        status.fetch = "miss";
      const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k2, index2, options, context);
      return p.__returned = p;
    } else {
      const v = __privateGet(this, _valList)[index2];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        const stale = allowStale && v.__staleWhileFetching !== void 0;
        if (status) {
          status.fetch = "inflight";
          if (stale)
            status.returnedStale = true;
        }
        return stale ? v.__staleWhileFetching : v.__returned = v;
      }
      const isStale = __privateGet(this, _isStale).call(this, index2);
      if (!forceRefresh && !isStale) {
        if (status)
          status.fetch = "hit";
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        if (status)
          __privateGet(this, _statusTTL).call(this, status, index2);
        return v;
      }
      const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k2, index2, options, context);
      const hasStale = p.__staleWhileFetching !== void 0;
      const staleVal = hasStale && allowStale;
      if (status) {
        status.fetch = isStale ? "stale" : "refresh";
        if (staleVal && isStale)
          status.returnedStale = true;
      }
      return staleVal ? p.__staleWhileFetching : p.__returned = p;
    }
  }
  async forceFetch(k2, fetchOptions = {}) {
    const v = await this.fetch(k2, fetchOptions);
    if (v === void 0)
      throw new Error("fetch() returned undefined");
    return v;
  }
  memo(k2, memoOptions = {}) {
    const memoMethod = __privateGet(this, _memoMethod);
    if (!memoMethod) {
      throw new Error("no memoMethod provided to constructor");
    }
    const { context, forceRefresh, ...options } = memoOptions;
    const v = this.get(k2, options);
    if (!forceRefresh && v !== void 0)
      return v;
    const vv = memoMethod(k2, v, {
      options,
      context
    });
    this.set(k2, vv, options);
    return vv;
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(k2, getOptions = {}) {
    const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
    const index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 !== void 0) {
      const value = __privateGet(this, _valList)[index2];
      const fetching = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value);
      if (status)
        __privateGet(this, _statusTTL).call(this, status, index2);
      if (__privateGet(this, _isStale).call(this, index2)) {
        if (status)
          status.get = "stale";
        if (!fetching) {
          if (!noDeleteOnStaleGet) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "expire");
          }
          if (status && allowStale)
            status.returnedStale = true;
          return allowStale ? value : void 0;
        } else {
          if (status && allowStale && value.__staleWhileFetching !== void 0) {
            status.returnedStale = true;
          }
          return allowStale ? value.__staleWhileFetching : void 0;
        }
      } else {
        if (status)
          status.get = "hit";
        if (fetching) {
          return value.__staleWhileFetching;
        }
        __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index2);
        if (updateAgeOnGet) {
          __privateGet(this, _updateItemAge).call(this, index2);
        }
        return value;
      }
    } else if (status) {
      status.get = "miss";
    }
  }
  /**
   * Deletes a key out of the cache.
   *
   * Returns true if the key was deleted, false otherwise.
   */
  delete(k2) {
    return __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "delete");
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    return __privateMethod(this, _LRUCache_instances, clear_fn).call(this, "delete");
  }
};
_max = new WeakMap();
_maxSize = new WeakMap();
_dispose = new WeakMap();
_disposeAfter = new WeakMap();
_fetchMethod = new WeakMap();
_memoMethod = new WeakMap();
_size = new WeakMap();
_calculatedSize = new WeakMap();
_keyMap = new WeakMap();
_keyList = new WeakMap();
_valList = new WeakMap();
_next = new WeakMap();
_prev = new WeakMap();
_head = new WeakMap();
_tail = new WeakMap();
_free = new WeakMap();
_disposed = new WeakMap();
_sizes = new WeakMap();
_starts = new WeakMap();
_ttls = new WeakMap();
_hasDispose = new WeakMap();
_hasFetchMethod = new WeakMap();
_hasDisposeAfter = new WeakMap();
_LRUCache_instances = new WeakSet();
initializeTTLTracking_fn = function() {
  const ttls = new ZeroArray(__privateGet(this, _max));
  const starts = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _ttls, ttls);
  __privateSet(this, _starts, starts);
  __privateSet(this, _setItemTTL, (index2, ttl, start = perf.now()) => {
    starts[index2] = ttl !== 0 ? start : 0;
    ttls[index2] = ttl;
    if (ttl !== 0 && this.ttlAutopurge) {
      const t2 = setTimeout(() => {
        if (__privateGet(this, _isStale).call(this, index2)) {
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[index2], "expire");
        }
      }, ttl + 1);
      if (t2.unref) {
        t2.unref();
      }
    }
  });
  __privateSet(this, _updateItemAge, (index2) => {
    starts[index2] = ttls[index2] !== 0 ? perf.now() : 0;
  });
  __privateSet(this, _statusTTL, (status, index2) => {
    if (ttls[index2]) {
      const ttl = ttls[index2];
      const start = starts[index2];
      if (!ttl || !start)
        return;
      status.ttl = ttl;
      status.start = start;
      status.now = cachedNow || getNow();
      const age = status.now - start;
      status.remainingTTL = ttl - age;
    }
  });
  let cachedNow = 0;
  const getNow = () => {
    const n2 = perf.now();
    if (this.ttlResolution > 0) {
      cachedNow = n2;
      const t2 = setTimeout(() => cachedNow = 0, this.ttlResolution);
      if (t2.unref) {
        t2.unref();
      }
    }
    return n2;
  };
  this.getRemainingTTL = (key) => {
    const index2 = __privateGet(this, _keyMap).get(key);
    if (index2 === void 0) {
      return 0;
    }
    const ttl = ttls[index2];
    const start = starts[index2];
    if (!ttl || !start) {
      return Infinity;
    }
    const age = (cachedNow || getNow()) - start;
    return ttl - age;
  };
  __privateSet(this, _isStale, (index2) => {
    const s = starts[index2];
    const t2 = ttls[index2];
    return !!t2 && !!s && (cachedNow || getNow()) - s > t2;
  });
};
_updateItemAge = new WeakMap();
_statusTTL = new WeakMap();
_setItemTTL = new WeakMap();
_isStale = new WeakMap();
initializeSizeTracking_fn = function() {
  const sizes = new ZeroArray(__privateGet(this, _max));
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _sizes, sizes);
  __privateSet(this, _removeItemSize, (index2) => {
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index2]);
    sizes[index2] = 0;
  });
  __privateSet(this, _requireSize, (k2, v, size, sizeCalculation) => {
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
      return 0;
    }
    if (!isPosInt(size)) {
      if (sizeCalculation) {
        if (typeof sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation must be a function");
        }
        size = sizeCalculation(v, k2);
        if (!isPosInt(size)) {
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        }
      } else {
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      }
    }
    return size;
  });
  __privateSet(this, _addItemSize, (index2, size, status) => {
    sizes[index2] = size;
    if (__privateGet(this, _maxSize)) {
      const maxSize = __privateGet(this, _maxSize) - sizes[index2];
      while (__privateGet(this, _calculatedSize) > maxSize) {
        __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
      }
    }
    __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index2]);
    if (status) {
      status.entrySize = size;
      status.totalCalculatedSize = __privateGet(this, _calculatedSize);
    }
  });
};
_removeItemSize = new WeakMap();
_addItemSize = new WeakMap();
_requireSize = new WeakMap();
indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i2 = __privateGet(this, _tail); true; ) {
      if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i2)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i2)) {
        yield i2;
      }
      if (i2 === __privateGet(this, _head)) {
        break;
      } else {
        i2 = __privateGet(this, _prev)[i2];
      }
    }
  }
};
rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
  if (__privateGet(this, _size)) {
    for (let i2 = __privateGet(this, _head); true; ) {
      if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i2)) {
        break;
      }
      if (allowStale || !__privateGet(this, _isStale).call(this, i2)) {
        yield i2;
      }
      if (i2 === __privateGet(this, _tail)) {
        break;
      } else {
        i2 = __privateGet(this, _next)[i2];
      }
    }
  }
};
isValidIndex_fn = function(index2) {
  return index2 !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index2]) === index2;
};
evict_fn = function(free) {
  var _a3, _b2;
  const head = __privateGet(this, _head);
  const k2 = __privateGet(this, _keyList)[head];
  const v = __privateGet(this, _valList)[head];
  if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
    v.__abortController.abort(new Error("evicted"));
  } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
    if (__privateGet(this, _hasDispose)) {
      (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, v, k2, "evict");
    }
    if (__privateGet(this, _hasDisposeAfter)) {
      (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k2, "evict"]);
    }
  }
  __privateGet(this, _removeItemSize).call(this, head);
  if (free) {
    __privateGet(this, _keyList)[head] = void 0;
    __privateGet(this, _valList)[head] = void 0;
    __privateGet(this, _free).push(head);
  }
  if (__privateGet(this, _size) === 1) {
    __privateSet(this, _head, __privateSet(this, _tail, 0));
    __privateGet(this, _free).length = 0;
  } else {
    __privateSet(this, _head, __privateGet(this, _next)[head]);
  }
  __privateGet(this, _keyMap).delete(k2);
  __privateWrapper(this, _size)._--;
  return head;
};
backgroundFetch_fn = function(k2, index2, options, context) {
  const v = index2 === void 0 ? void 0 : __privateGet(this, _valList)[index2];
  if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
    return v;
  }
  const ac = new AC();
  const { signal } = options;
  signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
    signal: ac.signal
  });
  const fetchOpts = {
    signal: ac.signal,
    options,
    context
  };
  const cb = (v2, updateCache = false) => {
    const { aborted } = ac.signal;
    const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
    if (options.status) {
      if (aborted && !updateCache) {
        options.status.fetchAborted = true;
        options.status.fetchError = ac.signal.reason;
        if (ignoreAbort)
          options.status.fetchAbortIgnored = true;
      } else {
        options.status.fetchResolved = true;
      }
    }
    if (aborted && !ignoreAbort && !updateCache) {
      return fetchFail(ac.signal.reason);
    }
    const bf2 = p;
    if (__privateGet(this, _valList)[index2] === p) {
      if (v2 === void 0) {
        if (bf2.__staleWhileFetching) {
          __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching;
        } else {
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "fetch");
        }
      } else {
        if (options.status)
          options.status.fetchUpdated = true;
        this.set(k2, v2, fetchOpts.options);
      }
    }
    return v2;
  };
  const eb = (er) => {
    if (options.status) {
      options.status.fetchRejected = true;
      options.status.fetchError = er;
    }
    return fetchFail(er);
  };
  const fetchFail = (er) => {
    const { aborted } = ac.signal;
    const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
    const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
    const noDelete = allowStale || options.noDeleteOnFetchRejection;
    const bf2 = p;
    if (__privateGet(this, _valList)[index2] === p) {
      const del = !noDelete || bf2.__staleWhileFetching === void 0;
      if (del) {
        __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k2, "fetch");
      } else if (!allowStaleAborted) {
        __privateGet(this, _valList)[index2] = bf2.__staleWhileFetching;
      }
    }
    if (allowStale) {
      if (options.status && bf2.__staleWhileFetching !== void 0) {
        options.status.returnedStale = true;
      }
      return bf2.__staleWhileFetching;
    } else if (bf2.__returned === bf2) {
      throw er;
    }
  };
  const pcall = (res, rej) => {
    var _a3;
    const fmp = (_a3 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a3.call(this, k2, v, fetchOpts);
    if (fmp && fmp instanceof Promise) {
      fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
    }
    ac.signal.addEventListener("abort", () => {
      if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
        res(void 0);
        if (options.allowStaleOnFetchAbort) {
          res = (v2) => cb(v2, true);
        }
      }
    });
  };
  if (options.status)
    options.status.fetchDispatched = true;
  const p = new Promise(pcall).then(cb, eb);
  const bf = Object.assign(p, {
    __abortController: ac,
    __staleWhileFetching: v,
    __returned: void 0
  });
  if (index2 === void 0) {
    this.set(k2, bf, { ...fetchOpts.options, status: void 0 });
    index2 = __privateGet(this, _keyMap).get(k2);
  } else {
    __privateGet(this, _valList)[index2] = bf;
  }
  return bf;
};
isBackgroundFetch_fn = function(p) {
  if (!__privateGet(this, _hasFetchMethod))
    return false;
  const b = p;
  return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
};
connect_fn = function(p, n2) {
  __privateGet(this, _prev)[n2] = p;
  __privateGet(this, _next)[p] = n2;
};
moveToTail_fn = function(index2) {
  if (index2 !== __privateGet(this, _tail)) {
    if (index2 === __privateGet(this, _head)) {
      __privateSet(this, _head, __privateGet(this, _next)[index2]);
    } else {
      __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _prev)[index2], __privateGet(this, _next)[index2]);
    }
    __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _tail), index2);
    __privateSet(this, _tail, index2);
  }
};
delete_fn = function(k2, reason) {
  var _a3, _b2, _c, _d;
  let deleted = false;
  if (__privateGet(this, _size) !== 0) {
    const index2 = __privateGet(this, _keyMap).get(k2);
    if (index2 !== void 0) {
      deleted = true;
      if (__privateGet(this, _size) === 1) {
        __privateMethod(this, _LRUCache_instances, clear_fn).call(this, reason);
      } else {
        __privateGet(this, _removeItemSize).call(this, index2);
        const v = __privateGet(this, _valList)[index2];
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          v.__abortController.abort(new Error("deleted"));
        } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
          if (__privateGet(this, _hasDispose)) {
            (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, v, k2, reason);
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k2, reason]);
          }
        }
        __privateGet(this, _keyMap).delete(k2);
        __privateGet(this, _keyList)[index2] = void 0;
        __privateGet(this, _valList)[index2] = void 0;
        if (index2 === __privateGet(this, _tail)) {
          __privateSet(this, _tail, __privateGet(this, _prev)[index2]);
        } else if (index2 === __privateGet(this, _head)) {
          __privateSet(this, _head, __privateGet(this, _next)[index2]);
        } else {
          const pi = __privateGet(this, _prev)[index2];
          __privateGet(this, _next)[pi] = __privateGet(this, _next)[index2];
          const ni = __privateGet(this, _next)[index2];
          __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index2];
        }
        __privateWrapper(this, _size)._--;
        __privateGet(this, _free).push(index2);
      }
    }
  }
  if (__privateGet(this, _hasDisposeAfter) && ((_c = __privateGet(this, _disposed)) == null ? void 0 : _c.length)) {
    const dt = __privateGet(this, _disposed);
    let task;
    while (task = dt == null ? void 0 : dt.shift()) {
      (_d = __privateGet(this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
    }
  }
  return deleted;
};
clear_fn = function(reason) {
  var _a3, _b2, _c;
  for (const index2 of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
    const v = __privateGet(this, _valList)[index2];
    if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
      v.__abortController.abort(new Error("deleted"));
    } else {
      const k2 = __privateGet(this, _keyList)[index2];
      if (__privateGet(this, _hasDispose)) {
        (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, v, k2, reason);
      }
      if (__privateGet(this, _hasDisposeAfter)) {
        (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k2, reason]);
      }
    }
  }
  __privateGet(this, _keyMap).clear();
  __privateGet(this, _valList).fill(void 0);
  __privateGet(this, _keyList).fill(void 0);
  if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
    __privateGet(this, _ttls).fill(0);
    __privateGet(this, _starts).fill(0);
  }
  if (__privateGet(this, _sizes)) {
    __privateGet(this, _sizes).fill(0);
  }
  __privateSet(this, _head, 0);
  __privateSet(this, _tail, 0);
  __privateGet(this, _free).length = 0;
  __privateSet(this, _calculatedSize, 0);
  __privateSet(this, _size, 0);
  if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
    const dt = __privateGet(this, _disposed);
    let task;
    while (task = dt == null ? void 0 : dt.shift()) {
      (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
    }
  }
};
var LRUCache = _LRUCache;

// node_modules/md-editor-v3/lib/es/chunks/index.mjs
function _mergeNamespaces(n2, m) {
  for (var i2 = 0; i2 < m.length; i2++) {
    const e2 = m[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d = Object.getOwnPropertyDescriptor(e2, k2);
          if (d) {
            Object.defineProperty(n2, k2, d.get ? d : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var userZoom = (props8, html) => {
  const editorId = inject("editorId");
  const { noImgZoomIn } = props8;
  const zoomHander = k(() => {
    const imgs = document.querySelectorAll(
      `#${editorId}-preview img:not(.not-zoom):not(.medium-zoom-image)`
    );
    if (imgs.length === 0) {
      return;
    }
    medium_zoom_esm_default(imgs, {
      background: "#00000073"
    });
  });
  onMounted(() => {
    if (!noImgZoomIn && props8.setting.preview) {
      zoomHander();
    }
  });
  watch([html, toRef(props8.setting, "preview")], () => {
    if (!noImgZoomIn && props8.setting.preview) {
      zoomHander();
    }
  });
};
var useCopyCode = (props8, html, key) => {
  const editorId = inject("editorId");
  const rootRef = inject("rootRef");
  const ult = inject("usedLanguageText");
  const initCopyEntry = () => {
    rootRef.value.querySelectorAll(`#${editorId} .${prefix}-preview .${prefix}-code`).forEach((codeBlock) => {
      let clearTimer = -1;
      const copyButton = codeBlock.querySelector(
        `.${prefix}-copy-button`
      );
      if (copyButton)
        copyButton.onclick = (e2) => {
          e2.preventDefault();
          clearTimeout(clearTimer);
          const activeCode = codeBlock.querySelector("input:checked + pre code") || codeBlock.querySelector("pre code");
          const codeText = activeCode.textContent;
          const success = (0, import_copy_to_clipboard.default)(props8.formatCopiedText(codeText));
          const { text, successTips, failTips } = ult.value.copyCode;
          const msg = success ? successTips : failTips;
          if (copyButton.dataset.isIcon) {
            copyButton.dataset.tips = msg;
          } else {
            copyButton.innerHTML = msg;
          }
          clearTimer = window.setTimeout(() => {
            if (copyButton.dataset.isIcon) {
              copyButton.dataset.tips = text;
            } else {
              copyButton.innerHTML = text;
            }
          }, 1500);
        };
    });
  };
  const htmlChanged = () => {
    nextTick(initCopyEntry);
  };
  const settingPreviewChanged = (nVal) => {
    if (nVal) {
      nextTick(initCopyEntry);
    }
  };
  watch([html, key], htmlChanged);
  watch(() => props8.setting.preview, settingPreviewChanged);
  watch(() => props8.setting.htmlPreview, settingPreviewChanged);
  watch(() => ult.value, initCopyEntry);
  onMounted(initCopyEntry);
};
var useHighlight = (props8) => {
  const highlight = inject("highlight");
  const hljsRef = shallowRef(configOption.editorExtensions.highlight.instance);
  onMounted(() => {
    if (props8.noHighlight || hljsRef.value) {
      return;
    }
    appendHandler("link", {
      ...highlight.value.css,
      rel: "stylesheet",
      id: `${prefix}-hlCss`
    });
    appendHandler(
      "script",
      {
        ...highlight.value.js,
        id: `${prefix}-hljs`,
        onload() {
          hljsRef.value = window.hljs;
        }
      },
      "hljs"
    );
  });
  watch(
    () => highlight.value.css,
    () => {
      if (props8.noHighlight || configOption.editorExtensions.highlight.instance) {
        return;
      }
      updateHandler("link", {
        ...highlight.value.css,
        rel: "stylesheet",
        id: `${prefix}-hlCss`
      });
    }
  );
  return hljsRef;
};
var mermaidCache = new LRUCache({
  max: 1e3,
  // 缓存10分钟
  ttl: 6e5
});
var useMermaid = (props8) => {
  const theme = inject("theme");
  const rootRef = inject("rootRef");
  const { editorExtensions, editorExtensionsAttrs: editorExtensionsAttrs2, mermaidConfig } = configOption;
  const mermaidRef = shallowRef(editorExtensions.mermaid.instance);
  const reRenderRef = shallowRef(-1);
  const configMermaid = () => {
    const mermaid = mermaidRef.value;
    if (!props8.noMermaid && mermaid) {
      mermaid.initialize(
        mermaidConfig({
          startOnLoad: false,
          theme: theme.value === "dark" ? "dark" : "default"
        })
      );
      reRenderRef.value = reRenderRef.value + 1;
    }
  };
  watch(
    () => theme.value,
    () => {
      mermaidCache.clear();
      configMermaid();
    }
  );
  onMounted(() => {
    var _a3, _b2;
    if (props8.noMermaid || mermaidRef.value) {
      return;
    }
    const jsSrc = editorExtensions.mermaid.js;
    if (/\.mjs/.test(jsSrc)) {
      appendHandler("link", {
        ...(_a3 = editorExtensionsAttrs2.mermaid) == null ? void 0 : _a3.js,
        rel: "modulepreload",
        href: jsSrc,
        id: `${prefix}-mermaid-m`
      });
      import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        jsSrc
      ).then((module) => {
        mermaidRef.value = module.default;
        configMermaid();
      });
    } else {
      appendHandler(
        "script",
        {
          ...(_b2 = editorExtensionsAttrs2.mermaid) == null ? void 0 : _b2.js,
          src: jsSrc,
          id: `${prefix}-mermaid`,
          onload() {
            mermaidRef.value = window.mermaid;
            configMermaid();
          }
        },
        "mermaid"
      );
    }
  });
  const replaceMermaid = async () => {
    if (!props8.noMermaid && mermaidRef.value) {
      const mermaidSourceEles = rootRef.value.querySelectorAll(
        `div.${prefix}-mermaid`
      );
      const svgContainingElement = document.createElement("div");
      const sceWidth = document.body.offsetWidth > 1366 ? document.body.offsetWidth : 1366;
      const sceHeight = document.body.offsetHeight > 768 ? document.body.offsetHeight : 768;
      svgContainingElement.style.width = sceWidth + "px";
      svgContainingElement.style.height = sceHeight + "px";
      svgContainingElement.style.position = "fixed";
      svgContainingElement.style.zIndex = "-10000";
      svgContainingElement.style.top = "-10000";
      let count = mermaidSourceEles.length;
      if (count > 0) {
        document.body.appendChild(svgContainingElement);
      }
      await Promise.allSettled(
        Array.from(mermaidSourceEles).map((ele) => {
          const handler = async (item) => {
            var _a3;
            let mermaidHtml = mermaidCache.get(item.innerText);
            if (!mermaidHtml) {
              const idRand = U();
              let result = { svg: "" };
              try {
                result = await mermaidRef.value.render(
                  idRand,
                  item.innerText,
                  svgContainingElement
                );
                mermaidHtml = await props8.sanitizeMermaid(result.svg);
                const p = document.createElement("p");
                p.className = `${prefix}-mermaid`;
                p.setAttribute("data-processed", "");
                p.innerHTML = mermaidHtml;
                (_a3 = p.children[0]) == null ? void 0 : _a3.removeAttribute("height");
                mermaidCache.set(item.innerText, p.innerHTML);
                if (item.dataset.line !== void 0) {
                  p.dataset.line = item.dataset.line;
                }
                item.replaceWith(p);
              } catch {
              }
              if (--count === 0) {
                svgContainingElement.remove();
              }
            }
          };
          return handler(ele);
        })
      );
    }
  };
  return { mermaidRef, reRenderRef, replaceMermaid };
};
var useKatex = (props8) => {
  const katex = shallowRef(configOption.editorExtensions.katex.instance);
  onMounted(() => {
    if (props8.noKatex || katex.value) {
      return;
    }
    const { editorExtensions } = configOption;
    appendHandler(
      "script",
      {
        src: editorExtensions.katex.js,
        id: `${prefix}-katex`,
        onload() {
          katex.value = window.katex;
        }
      },
      "katex"
    );
    appendHandler("link", {
      rel: "stylesheet",
      href: editorExtensions.katex.css,
      id: `${prefix}-katexCss`
    });
  });
  return katex;
};
var MermaidPlugin = (md, options) => {
  const temp = md.renderer.rules.fence.bind(md.renderer.rules);
  md.renderer.rules.fence = (tokens, idx, ops, env, slf) => {
    const token = tokens[idx];
    const code = token.content.trim();
    if (token.info === "mermaid") {
      let line;
      if (tokens[idx].map && tokens[idx].level === 0) {
        line = tokens[idx].map[0];
        tokens[idx].attrSet("data-line", String(line));
      }
      const mermaidHtml = mermaidCache.get(code);
      if (mermaidHtml) {
        return `<p class="${prefix}-mermaid" ${line !== void 0 ? "data-line=" + line : ""} data-processed>${mermaidHtml}</p>`;
      }
      return `<div class="${prefix}-mermaid" ${line !== void 0 ? "data-line=" + line : ""} data-mermaid-theme=${options.themeRef.value}>${code}</div>`;
    }
    return temp(tokens, idx, ops, env, slf);
  };
};
var mergeAttrs = (token, addAttrs) => {
  const tmpAttrs = token.attrs ? token.attrs.slice() : [];
  addAttrs.forEach((addAttr) => {
    const i2 = token.attrIndex(addAttr[0]);
    if (i2 < 0) {
      tmpAttrs.push(addAttr);
    } else {
      tmpAttrs[i2] = tmpAttrs[i2].slice();
      tmpAttrs[i2][1] += ` ${addAttr[1]}`;
    }
  });
  return tmpAttrs;
};
var math_inline = (state, silent) => {
  const delimiters = [
    { open: "$", close: "$" },
    { open: "\\(", close: "\\)" }
  ];
  let match, token, pos;
  for (const delim of delimiters) {
    if (state.src.startsWith(delim.open, state.pos)) {
      const start = state.pos + delim.open.length;
      match = start;
      while ((match = state.src.indexOf(delim.close, match)) !== -1) {
        pos = match - 1;
        while (state.src[pos] === "\\") {
          pos -= 1;
        }
        if ((match - pos) % 2 == 1) {
          break;
        }
        match += delim.close.length;
      }
      if (match === -1) {
        if (!silent) {
          state.pending += delim.open;
        }
        state.pos = start;
        return true;
      }
      if (match - start === 0) {
        if (!silent) {
          state.pending += delim.open + delim.close;
        }
        state.pos = start + delim.close.length;
        return true;
      }
      if (!silent) {
        token = state.push("math_inline", "math", 0);
        token.markup = delim.open;
        token.content = state.src.slice(start, match);
      }
      state.pos = match + delim.close.length;
      return true;
    }
  }
  return false;
};
var math_block = (state, start, end, silent) => {
  const delimiters = [
    { open: "$$", close: "$$" },
    { open: "\\[", close: "\\]" }
  ];
  let firstLine, lastLine, next, lastPos, found = false;
  let pos = state.bMarks[start] + state.tShift[start];
  let max = state.eMarks[start];
  for (const delim of delimiters) {
    if (pos + delim.open.length > max) {
      continue;
    }
    if (state.src.slice(pos, pos + delim.open.length) !== delim.open) {
      continue;
    }
    pos += delim.open.length;
    firstLine = state.src.slice(pos, max);
    if (silent) {
      return true;
    }
    if (firstLine.trim().slice(-delim.close.length) === delim.close) {
      firstLine = firstLine.trim().slice(0, -delim.close.length);
      found = true;
    }
    for (next = start; !found; ) {
      next++;
      if (next >= end) {
        break;
      }
      pos = state.bMarks[next] + state.tShift[next];
      max = state.eMarks[next];
      if (pos < max && state.tShift[next] < state.blkIndent) {
        break;
      }
      if (state.src.slice(pos, max).trim().slice(-delim.close.length) === delim.close) {
        lastPos = state.src.slice(0, max).lastIndexOf(delim.close);
        lastLine = state.src.slice(pos, lastPos);
        found = true;
      }
    }
    state.line = next + 1;
    const token = state.push("math_block", "math", 0);
    token.block = true;
    token.content = (firstLine && firstLine.trim() ? firstLine + "\n" : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
    token.map = [start, state.line];
    token.markup = delim.open;
    return true;
  }
  return false;
};
var KatexPlugin = (md, { katexRef }) => {
  const katexInline = (tokens, idx, options, env, slf) => {
    const token = tokens[idx];
    const tmpToken = {
      attrs: mergeAttrs(token, [["class", `${prefix}-katex-inline`]])
    };
    if (katexRef.value) {
      const html = katexRef.value.renderToString(
        token.content,
        configOption.katexConfig({
          throwOnError: false
        })
      );
      return `<span ${slf.renderAttrs(tmpToken)} data-processed>${html}</span>`;
    } else {
      return `<span ${slf.renderAttrs(tmpToken)}>${token.content}</span>`;
    }
  };
  const katexBlock = (tokens, idx, options, env, slf) => {
    const token = tokens[idx];
    const tmpToken = {
      attrs: mergeAttrs(token, [["class", `${prefix}-katex-block`]])
    };
    if (katexRef.value) {
      const html = katexRef.value.renderToString(
        token.content,
        configOption.katexConfig({
          throwOnError: false,
          displayMode: true
        })
      );
      return `<p ${slf.renderAttrs(tmpToken)} data-processed>${html}</p>`;
    } else {
      return `<p ${slf.renderAttrs(tmpToken)}>${token.content}</p>`;
    }
  };
  md.inline.ruler.before("escape", "math_inline", math_inline);
  md.block.ruler.after("blockquote", "math_block", math_block, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md.renderer.rules.math_inline = katexInline;
  md.renderer.rules.math_block = katexBlock;
};
var AdmonitionPlugin = (md, options) => {
  options = options || {};
  const markers = 3, markerStr = options.marker || "!", markerChar = markerStr.charCodeAt(0), markerLen = markerStr.length;
  let type = "", title = "";
  const render = (tokens, idx, _options, _env, self2) => {
    const token = tokens[idx];
    if (token.type === "admonition_open") {
      tokens[idx].attrPush([
        "class",
        `${prefix}-admonition ${prefix}-admonition-${token.info}`
      ]);
    } else if (token.type === "admonition_title_open") {
      tokens[idx].attrPush(["class", `${prefix}-admonition-title`]);
    }
    return self2.renderToken(tokens, idx, _options);
  };
  const validate = (params) => {
    const array = params.trim().split(" ", 2);
    title = "";
    type = array[0];
    if (array.length > 1) {
      title = params.substring(type.length + 2);
    }
  };
  md.block.ruler.before(
    "code",
    "admonition",
    (state, startLine, endLine, silent) => {
      let pos, nextLine, token, autoClosed = false, start = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (markerChar !== state.src.charCodeAt(start)) {
        return false;
      }
      for (pos = start + 1; pos <= max; pos++) {
        if (markerStr[(pos - start) % markerLen] !== state.src[pos]) {
          break;
        }
      }
      const markerCount = Math.floor((pos - start) / markerLen);
      if (markerCount !== markers) {
        return false;
      }
      pos -= (pos - start) % markerLen;
      const markup = state.src.slice(start, pos);
      const params = state.src.slice(pos, max);
      validate(params);
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        start = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (start < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (markerChar !== state.src.charCodeAt(start)) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        for (pos = start + 1; pos <= max; pos++) {
          if (markerStr[(pos - start) % markerLen] !== state.src[pos]) {
            break;
          }
        }
        if (Math.floor((pos - start) / markerLen) < markerCount) {
          continue;
        }
        pos -= (pos - start) % markerLen;
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        autoClosed = true;
        break;
      }
      const oldParent = state.parentType;
      const oldLineMax = state.lineMax;
      state.parentType = "root";
      state.lineMax = nextLine;
      token = state.push("admonition_open", "div", 1);
      token.markup = markup;
      token.block = true;
      token.info = type;
      token.map = [startLine, nextLine];
      if (title) {
        token = state.push("admonition_title_open", "p", 1);
        token.markup = markup + " " + type;
        token.map = [startLine, nextLine];
        token = state.push("inline", "", 0);
        token.content = title;
        token.map = [startLine, state.line - 1];
        token.children = [];
        token = state.push("admonition_title_close", "p", -1);
        token.markup = markup + " " + type;
      }
      state.md.block.tokenize(state, startLine + 1, nextLine);
      token = state.push("admonition_close", "div", -1);
      token.markup = state.src.slice(start, pos);
      token.block = true;
      state.parentType = oldParent;
      state.lineMax = oldLineMax;
      state.line = nextLine + (autoClosed ? 1 : 0);
      return true;
    },
    {
      alt: ["paragraph", "reference", "blockquote", "list"]
    }
  );
  md.renderer.rules["admonition_open"] = render;
  md.renderer.rules["admonition_title_open"] = render;
  md.renderer.rules["admonition_title_close"] = render;
  md.renderer.rules["admonition_close"] = render;
};
var HeadingPlugin = (md, options) => {
  md.renderer.rules.heading_open = (tokens, idx) => {
    var _a3;
    const token = tokens[idx];
    const text = ((_a3 = tokens[idx + 1].children) == null ? void 0 : _a3.reduce((p, c) => {
      return p + (["text", "code_inline", "math_inline"].includes(c.type) ? c.content || "" : "");
    }, "")) || "";
    const level = token.markup.length;
    options.headsRef.value.push({
      text,
      level
    });
    if (token.map && token.level === 0) {
      token.attrSet(
        "id",
        options.mdHeadingId(text, level, options.headsRef.value.length)
      );
    }
    return md.renderer.renderToken(tokens, idx, options);
  };
  md.renderer.rules.heading_close = (tokens, idx, opts, _env, self2) => {
    return self2.renderToken(tokens, idx, opts);
  };
};
var StrIcon = (name, customIcon) => {
  if (typeof customIcon[name] === "string") {
    return customIcon[name];
  }
  const defaultStr = `<i class="${prefix}-iconfont ${prefix}-icon-${name}"></i>`;
  switch (configOption.iconfontType) {
    case "svg": {
      return `<svg class="${prefix}-icon" aria-hidden="true"><use xlink:href="#${prefix}-icon-${name}"></use></svg>`;
    }
    default: {
      return defaultStr;
    }
  }
};
var StrIcon$1 = StrIcon;
var codetabs = (md, _opts) => {
  const defaultRender = md.renderer.rules.fence, unescapeAll = md.utils.unescapeAll, re = /\[(\w*)(?::([\w ]*))?\]/, mandatoryRe = /::(open|close)/;
  const getInfo = (token) => {
    return token.info ? unescapeAll(token.info).trim() : "";
  };
  const getGroupAndTab = (token) => {
    const info = getInfo(token), [group = null, tab = ""] = (re.exec(info) || []).slice(1);
    return [group, tab];
  };
  const getLangName = (token) => {
    const info = getInfo(token);
    return info ? info.split(/(\s+)/g)[0] : "";
  };
  const getTagType = (token) => {
    const mandatory = token.info.match(mandatoryRe) || [];
    const open = mandatory[1] === "open" || mandatory[1] !== "close" && _opts.codeFoldable && token.content.trim().split("\n").length < _opts.autoFoldThreshold;
    const tagContainer = mandatory[1] || _opts.codeFoldable ? "details" : "div", tagHeader = mandatory[1] || _opts.codeFoldable ? "summary" : "div";
    return { open, tagContainer, tagHeader };
  };
  const fenceGroup = (tokens, idx, options, env, slf) => {
    var _a3;
    if (tokens[idx].hidden) {
      return "";
    }
    const codeCodeText = (_a3 = _opts.usedLanguageTextRef.value) == null ? void 0 : _a3.copyCode.text;
    const copyBtnHtml = _opts.customIconRef.value.copy || codeCodeText;
    const isIcon = !!_opts.customIconRef.value.copy;
    const collapseTips = `<span class="${prefix}-collapse-tips">${StrIcon$1("collapse-tips", _opts.customIconRef.value)}</span>`;
    const [GROUP] = getGroupAndTab(tokens[idx]);
    if (GROUP === null) {
      const { open: open2, tagContainer: tagContainer2, tagHeader: tagHeader2 } = getTagType(tokens[idx]);
      const addAttrs2 = [["class", `${prefix}-code`]];
      open2 && addAttrs2.push(["open", ""]);
      const tmpToken2 = {
        attrs: mergeAttrs(tokens[idx], addAttrs2)
      };
      tokens[idx].info = tokens[idx].info.replace(mandatoryRe, "");
      const codeRendered = defaultRender(tokens, idx, options, env, slf);
      return `
        <${tagContainer2} ${slf.renderAttrs(tmpToken2)}>
          <${tagHeader2} class="${prefix}-code-head">
            <div class="${prefix}-code-flag"><span></span><span></span><span></span></div>
            <div class="${prefix}-code-action">
              <span class="${prefix}-code-lang">${tokens[idx].info.trim()}</span>
              <span class="${prefix}-copy-button" data-tips="${codeCodeText}"${isIcon ? " data-is-icon=true" : ""}>${copyBtnHtml}</span>
              ${tagContainer2 === "details" ? collapseTips : ""}
            </div>
          </${tagHeader2}>
          ${codeRendered}
        </${tagContainer2}>
      `;
    }
    let token, group, tab, checked, labels = "", pres = "", langs = "";
    const { open, tagContainer, tagHeader } = getTagType(tokens[idx]);
    const addAttrs = [["class", `${prefix}-code`]];
    open && addAttrs.push(["open", ""]);
    const tmpToken = {
      attrs: mergeAttrs(tokens[idx], addAttrs)
    };
    for (let i2 = idx; i2 < tokens.length; i2++) {
      token = tokens[i2];
      [group, tab] = getGroupAndTab(token);
      if (group !== GROUP) {
        break;
      }
      token.info = token.info.replace(re, "").replace(mandatoryRe, "");
      token.hidden = true;
      const className = `${prefix}-codetab-${_opts.editorId}-${idx}-${i2 - idx}`;
      checked = i2 - idx > 0 ? "" : "checked";
      labels += `
        <li>
          <input
            type="radio"
            id="label-${prefix}-codetab-label-1-${_opts.editorId}-${idx}-${i2 - idx}"
            name="${prefix}-codetab-label-${_opts.editorId}-${idx}"
            class="${className}"
            ${checked}
          >
          <label
            for="label-${prefix}-codetab-label-1-${_opts.editorId}-${idx}-${i2 - idx}"
            onclick="this.getRootNode().querySelectorAll('.${className}').forEach(e => e.click())"
          >
            ${tab || getLangName(token)}
          </label>
        </li>`;
      pres += `
        <div role="tabpanel">
          <input
            type="radio"
            name="${prefix}-codetab-pre-${_opts.editorId}-${idx}"
            class="${className}"
            ${checked}
            role="presentation">
          ${defaultRender(tokens, i2, options, env, slf)}
        </div>`;
      langs += `
        <input
          type="radio"
          name="${prefix}-codetab-lang-${_opts.editorId}-${idx}"
          class="${className}"
          ${checked}
          role="presentation">
        <span class=${prefix}-code-lang role="note">${getLangName(token)}</span>`;
    }
    return `
      <${tagContainer} ${slf.renderAttrs(tmpToken)}>
        <${tagHeader} class="${prefix}-code-head">
          <div class="${prefix}-code-flag">
            <ul class="${prefix}-codetab-label" role="tablist">${labels}</ul>
          </div>
          <div class="${prefix}-code-action">
            <span class="${prefix}-codetab-lang">${langs}</span>
            <span class="${prefix}-copy-button" data-tips="${codeCodeText}"${isIcon ? " data-is-icon=true" : ""}>${copyBtnHtml}</span>
            ${tagContainer === "details" ? collapseTips : ""}
          </div>
        </${tagHeader}>
        ${pres}
      </${tagContainer}>
    `;
  };
  md.renderer.rules.fence = fenceGroup;
  md.renderer.rules.code_block = fenceGroup;
};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var lib$1 = { exports: {} };
var _default$1 = {};
var lib = { exports: {} };
var _default = {};
function getDefaultWhiteList$1() {
  var whiteList = {};
  whiteList["align-content"] = false;
  whiteList["align-items"] = false;
  whiteList["align-self"] = false;
  whiteList["alignment-adjust"] = false;
  whiteList["alignment-baseline"] = false;
  whiteList["all"] = false;
  whiteList["anchor-point"] = false;
  whiteList["animation"] = false;
  whiteList["animation-delay"] = false;
  whiteList["animation-direction"] = false;
  whiteList["animation-duration"] = false;
  whiteList["animation-fill-mode"] = false;
  whiteList["animation-iteration-count"] = false;
  whiteList["animation-name"] = false;
  whiteList["animation-play-state"] = false;
  whiteList["animation-timing-function"] = false;
  whiteList["azimuth"] = false;
  whiteList["backface-visibility"] = false;
  whiteList["background"] = true;
  whiteList["background-attachment"] = true;
  whiteList["background-clip"] = true;
  whiteList["background-color"] = true;
  whiteList["background-image"] = true;
  whiteList["background-origin"] = true;
  whiteList["background-position"] = true;
  whiteList["background-repeat"] = true;
  whiteList["background-size"] = true;
  whiteList["baseline-shift"] = false;
  whiteList["binding"] = false;
  whiteList["bleed"] = false;
  whiteList["bookmark-label"] = false;
  whiteList["bookmark-level"] = false;
  whiteList["bookmark-state"] = false;
  whiteList["border"] = true;
  whiteList["border-bottom"] = true;
  whiteList["border-bottom-color"] = true;
  whiteList["border-bottom-left-radius"] = true;
  whiteList["border-bottom-right-radius"] = true;
  whiteList["border-bottom-style"] = true;
  whiteList["border-bottom-width"] = true;
  whiteList["border-collapse"] = true;
  whiteList["border-color"] = true;
  whiteList["border-image"] = true;
  whiteList["border-image-outset"] = true;
  whiteList["border-image-repeat"] = true;
  whiteList["border-image-slice"] = true;
  whiteList["border-image-source"] = true;
  whiteList["border-image-width"] = true;
  whiteList["border-left"] = true;
  whiteList["border-left-color"] = true;
  whiteList["border-left-style"] = true;
  whiteList["border-left-width"] = true;
  whiteList["border-radius"] = true;
  whiteList["border-right"] = true;
  whiteList["border-right-color"] = true;
  whiteList["border-right-style"] = true;
  whiteList["border-right-width"] = true;
  whiteList["border-spacing"] = true;
  whiteList["border-style"] = true;
  whiteList["border-top"] = true;
  whiteList["border-top-color"] = true;
  whiteList["border-top-left-radius"] = true;
  whiteList["border-top-right-radius"] = true;
  whiteList["border-top-style"] = true;
  whiteList["border-top-width"] = true;
  whiteList["border-width"] = true;
  whiteList["bottom"] = false;
  whiteList["box-decoration-break"] = true;
  whiteList["box-shadow"] = true;
  whiteList["box-sizing"] = true;
  whiteList["box-snap"] = true;
  whiteList["box-suppress"] = true;
  whiteList["break-after"] = true;
  whiteList["break-before"] = true;
  whiteList["break-inside"] = true;
  whiteList["caption-side"] = false;
  whiteList["chains"] = false;
  whiteList["clear"] = true;
  whiteList["clip"] = false;
  whiteList["clip-path"] = false;
  whiteList["clip-rule"] = false;
  whiteList["color"] = true;
  whiteList["color-interpolation-filters"] = true;
  whiteList["column-count"] = false;
  whiteList["column-fill"] = false;
  whiteList["column-gap"] = false;
  whiteList["column-rule"] = false;
  whiteList["column-rule-color"] = false;
  whiteList["column-rule-style"] = false;
  whiteList["column-rule-width"] = false;
  whiteList["column-span"] = false;
  whiteList["column-width"] = false;
  whiteList["columns"] = false;
  whiteList["contain"] = false;
  whiteList["content"] = false;
  whiteList["counter-increment"] = false;
  whiteList["counter-reset"] = false;
  whiteList["counter-set"] = false;
  whiteList["crop"] = false;
  whiteList["cue"] = false;
  whiteList["cue-after"] = false;
  whiteList["cue-before"] = false;
  whiteList["cursor"] = false;
  whiteList["direction"] = false;
  whiteList["display"] = true;
  whiteList["display-inside"] = true;
  whiteList["display-list"] = true;
  whiteList["display-outside"] = true;
  whiteList["dominant-baseline"] = false;
  whiteList["elevation"] = false;
  whiteList["empty-cells"] = false;
  whiteList["filter"] = false;
  whiteList["flex"] = false;
  whiteList["flex-basis"] = false;
  whiteList["flex-direction"] = false;
  whiteList["flex-flow"] = false;
  whiteList["flex-grow"] = false;
  whiteList["flex-shrink"] = false;
  whiteList["flex-wrap"] = false;
  whiteList["float"] = false;
  whiteList["float-offset"] = false;
  whiteList["flood-color"] = false;
  whiteList["flood-opacity"] = false;
  whiteList["flow-from"] = false;
  whiteList["flow-into"] = false;
  whiteList["font"] = true;
  whiteList["font-family"] = true;
  whiteList["font-feature-settings"] = true;
  whiteList["font-kerning"] = true;
  whiteList["font-language-override"] = true;
  whiteList["font-size"] = true;
  whiteList["font-size-adjust"] = true;
  whiteList["font-stretch"] = true;
  whiteList["font-style"] = true;
  whiteList["font-synthesis"] = true;
  whiteList["font-variant"] = true;
  whiteList["font-variant-alternates"] = true;
  whiteList["font-variant-caps"] = true;
  whiteList["font-variant-east-asian"] = true;
  whiteList["font-variant-ligatures"] = true;
  whiteList["font-variant-numeric"] = true;
  whiteList["font-variant-position"] = true;
  whiteList["font-weight"] = true;
  whiteList["grid"] = false;
  whiteList["grid-area"] = false;
  whiteList["grid-auto-columns"] = false;
  whiteList["grid-auto-flow"] = false;
  whiteList["grid-auto-rows"] = false;
  whiteList["grid-column"] = false;
  whiteList["grid-column-end"] = false;
  whiteList["grid-column-start"] = false;
  whiteList["grid-row"] = false;
  whiteList["grid-row-end"] = false;
  whiteList["grid-row-start"] = false;
  whiteList["grid-template"] = false;
  whiteList["grid-template-areas"] = false;
  whiteList["grid-template-columns"] = false;
  whiteList["grid-template-rows"] = false;
  whiteList["hanging-punctuation"] = false;
  whiteList["height"] = true;
  whiteList["hyphens"] = false;
  whiteList["icon"] = false;
  whiteList["image-orientation"] = false;
  whiteList["image-resolution"] = false;
  whiteList["ime-mode"] = false;
  whiteList["initial-letters"] = false;
  whiteList["inline-box-align"] = false;
  whiteList["justify-content"] = false;
  whiteList["justify-items"] = false;
  whiteList["justify-self"] = false;
  whiteList["left"] = false;
  whiteList["letter-spacing"] = true;
  whiteList["lighting-color"] = true;
  whiteList["line-box-contain"] = false;
  whiteList["line-break"] = false;
  whiteList["line-grid"] = false;
  whiteList["line-height"] = false;
  whiteList["line-snap"] = false;
  whiteList["line-stacking"] = false;
  whiteList["line-stacking-ruby"] = false;
  whiteList["line-stacking-shift"] = false;
  whiteList["line-stacking-strategy"] = false;
  whiteList["list-style"] = true;
  whiteList["list-style-image"] = true;
  whiteList["list-style-position"] = true;
  whiteList["list-style-type"] = true;
  whiteList["margin"] = true;
  whiteList["margin-bottom"] = true;
  whiteList["margin-left"] = true;
  whiteList["margin-right"] = true;
  whiteList["margin-top"] = true;
  whiteList["marker-offset"] = false;
  whiteList["marker-side"] = false;
  whiteList["marks"] = false;
  whiteList["mask"] = false;
  whiteList["mask-box"] = false;
  whiteList["mask-box-outset"] = false;
  whiteList["mask-box-repeat"] = false;
  whiteList["mask-box-slice"] = false;
  whiteList["mask-box-source"] = false;
  whiteList["mask-box-width"] = false;
  whiteList["mask-clip"] = false;
  whiteList["mask-image"] = false;
  whiteList["mask-origin"] = false;
  whiteList["mask-position"] = false;
  whiteList["mask-repeat"] = false;
  whiteList["mask-size"] = false;
  whiteList["mask-source-type"] = false;
  whiteList["mask-type"] = false;
  whiteList["max-height"] = true;
  whiteList["max-lines"] = false;
  whiteList["max-width"] = true;
  whiteList["min-height"] = true;
  whiteList["min-width"] = true;
  whiteList["move-to"] = false;
  whiteList["nav-down"] = false;
  whiteList["nav-index"] = false;
  whiteList["nav-left"] = false;
  whiteList["nav-right"] = false;
  whiteList["nav-up"] = false;
  whiteList["object-fit"] = false;
  whiteList["object-position"] = false;
  whiteList["opacity"] = false;
  whiteList["order"] = false;
  whiteList["orphans"] = false;
  whiteList["outline"] = false;
  whiteList["outline-color"] = false;
  whiteList["outline-offset"] = false;
  whiteList["outline-style"] = false;
  whiteList["outline-width"] = false;
  whiteList["overflow"] = false;
  whiteList["overflow-wrap"] = false;
  whiteList["overflow-x"] = false;
  whiteList["overflow-y"] = false;
  whiteList["padding"] = true;
  whiteList["padding-bottom"] = true;
  whiteList["padding-left"] = true;
  whiteList["padding-right"] = true;
  whiteList["padding-top"] = true;
  whiteList["page"] = false;
  whiteList["page-break-after"] = false;
  whiteList["page-break-before"] = false;
  whiteList["page-break-inside"] = false;
  whiteList["page-policy"] = false;
  whiteList["pause"] = false;
  whiteList["pause-after"] = false;
  whiteList["pause-before"] = false;
  whiteList["perspective"] = false;
  whiteList["perspective-origin"] = false;
  whiteList["pitch"] = false;
  whiteList["pitch-range"] = false;
  whiteList["play-during"] = false;
  whiteList["position"] = false;
  whiteList["presentation-level"] = false;
  whiteList["quotes"] = false;
  whiteList["region-fragment"] = false;
  whiteList["resize"] = false;
  whiteList["rest"] = false;
  whiteList["rest-after"] = false;
  whiteList["rest-before"] = false;
  whiteList["richness"] = false;
  whiteList["right"] = false;
  whiteList["rotation"] = false;
  whiteList["rotation-point"] = false;
  whiteList["ruby-align"] = false;
  whiteList["ruby-merge"] = false;
  whiteList["ruby-position"] = false;
  whiteList["shape-image-threshold"] = false;
  whiteList["shape-outside"] = false;
  whiteList["shape-margin"] = false;
  whiteList["size"] = false;
  whiteList["speak"] = false;
  whiteList["speak-as"] = false;
  whiteList["speak-header"] = false;
  whiteList["speak-numeral"] = false;
  whiteList["speak-punctuation"] = false;
  whiteList["speech-rate"] = false;
  whiteList["stress"] = false;
  whiteList["string-set"] = false;
  whiteList["tab-size"] = false;
  whiteList["table-layout"] = false;
  whiteList["text-align"] = true;
  whiteList["text-align-last"] = true;
  whiteList["text-combine-upright"] = true;
  whiteList["text-decoration"] = true;
  whiteList["text-decoration-color"] = true;
  whiteList["text-decoration-line"] = true;
  whiteList["text-decoration-skip"] = true;
  whiteList["text-decoration-style"] = true;
  whiteList["text-emphasis"] = true;
  whiteList["text-emphasis-color"] = true;
  whiteList["text-emphasis-position"] = true;
  whiteList["text-emphasis-style"] = true;
  whiteList["text-height"] = true;
  whiteList["text-indent"] = true;
  whiteList["text-justify"] = true;
  whiteList["text-orientation"] = true;
  whiteList["text-overflow"] = true;
  whiteList["text-shadow"] = true;
  whiteList["text-space-collapse"] = true;
  whiteList["text-transform"] = true;
  whiteList["text-underline-position"] = true;
  whiteList["text-wrap"] = true;
  whiteList["top"] = false;
  whiteList["transform"] = false;
  whiteList["transform-origin"] = false;
  whiteList["transform-style"] = false;
  whiteList["transition"] = false;
  whiteList["transition-delay"] = false;
  whiteList["transition-duration"] = false;
  whiteList["transition-property"] = false;
  whiteList["transition-timing-function"] = false;
  whiteList["unicode-bidi"] = false;
  whiteList["vertical-align"] = false;
  whiteList["visibility"] = false;
  whiteList["voice-balance"] = false;
  whiteList["voice-duration"] = false;
  whiteList["voice-family"] = false;
  whiteList["voice-pitch"] = false;
  whiteList["voice-range"] = false;
  whiteList["voice-rate"] = false;
  whiteList["voice-stress"] = false;
  whiteList["voice-volume"] = false;
  whiteList["volume"] = false;
  whiteList["white-space"] = false;
  whiteList["widows"] = false;
  whiteList["width"] = true;
  whiteList["will-change"] = false;
  whiteList["word-break"] = true;
  whiteList["word-spacing"] = true;
  whiteList["word-wrap"] = true;
  whiteList["wrap-flow"] = false;
  whiteList["wrap-through"] = false;
  whiteList["writing-mode"] = false;
  whiteList["z-index"] = false;
  return whiteList;
}
function onAttr(name, value, options) {
}
function onIgnoreAttr(name, value, options) {
}
var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;
function safeAttrValue$1(name, value) {
  if (REGEXP_URL_JAVASCRIPT.test(value)) return "";
  return value;
}
_default.whiteList = getDefaultWhiteList$1();
_default.getDefaultWhiteList = getDefaultWhiteList$1;
_default.onAttr = onAttr;
_default.onIgnoreAttr = onIgnoreAttr;
_default.safeAttrValue = safeAttrValue$1;
var util$1 = {
  indexOf: function(arr, item) {
    var i2, j;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item);
    }
    for (i2 = 0, j = arr.length; i2 < j; i2++) {
      if (arr[i2] === item) {
        return i2;
      }
    }
    return -1;
  },
  forEach: function(arr, fn, scope) {
    var i2, j;
    if (Array.prototype.forEach) {
      return arr.forEach(fn, scope);
    }
    for (i2 = 0, j = arr.length; i2 < j; i2++) {
      fn.call(scope, arr[i2], i2, arr);
    }
  },
  trim: function(str) {
    if (String.prototype.trim) {
      return str.trim();
    }
    return str.replace(/(^\s*)|(\s*$)/g, "");
  },
  trimRight: function(str) {
    if (String.prototype.trimRight) {
      return str.trimRight();
    }
    return str.replace(/(\s*$)/g, "");
  }
};
var _$3 = util$1;
function parseStyle$1(css22, onAttr2) {
  css22 = _$3.trimRight(css22);
  if (css22[css22.length - 1] !== ";") css22 += ";";
  var cssLength = css22.length;
  var isParenthesisOpen = false;
  var lastPos = 0;
  var i2 = 0;
  var retCSS = "";
  function addNewAttr() {
    if (!isParenthesisOpen) {
      var source = _$3.trim(css22.slice(lastPos, i2));
      var j2 = source.indexOf(":");
      if (j2 !== -1) {
        var name = _$3.trim(source.slice(0, j2));
        var value = _$3.trim(source.slice(j2 + 1));
        if (name) {
          var ret = onAttr2(lastPos, retCSS.length, name, value, source);
          if (ret) retCSS += ret + "; ";
        }
      }
    }
    lastPos = i2 + 1;
  }
  for (; i2 < cssLength; i2++) {
    var c = css22[i2];
    if (c === "/" && css22[i2 + 1] === "*") {
      var j = css22.indexOf("*/", i2 + 2);
      if (j === -1) break;
      i2 = j + 1;
      lastPos = i2 + 1;
      isParenthesisOpen = false;
    } else if (c === "(") {
      isParenthesisOpen = true;
    } else if (c === ")") {
      isParenthesisOpen = false;
    } else if (c === ";") {
      if (isParenthesisOpen) ;
      else {
        addNewAttr();
      }
    } else if (c === "\n") {
      addNewAttr();
    }
  }
  return _$3.trim(retCSS);
}
var parser$2 = parseStyle$1;
var DEFAULT$1 = _default;
var parseStyle = parser$2;
function isNull$1(obj) {
  return obj === void 0 || obj === null;
}
function shallowCopyObject$1(obj) {
  var ret = {};
  for (var i2 in obj) {
    ret[i2] = obj[i2];
  }
  return ret;
}
function FilterCSS$2(options) {
  options = shallowCopyObject$1(options || {});
  options.whiteList = options.whiteList || DEFAULT$1.whiteList;
  options.onAttr = options.onAttr || DEFAULT$1.onAttr;
  options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT$1.onIgnoreAttr;
  options.safeAttrValue = options.safeAttrValue || DEFAULT$1.safeAttrValue;
  this.options = options;
}
FilterCSS$2.prototype.process = function(css22) {
  css22 = css22 || "";
  css22 = css22.toString();
  if (!css22) return "";
  var me = this;
  var options = me.options;
  var whiteList = options.whiteList;
  var onAttr2 = options.onAttr;
  var onIgnoreAttr2 = options.onIgnoreAttr;
  var safeAttrValue2 = options.safeAttrValue;
  var retCSS = parseStyle(css22, function(sourcePosition, position, name, value, source) {
    var check = whiteList[name];
    var isWhite = false;
    if (check === true) isWhite = check;
    else if (typeof check === "function") isWhite = check(value);
    else if (check instanceof RegExp) isWhite = check.test(value);
    if (isWhite !== true) isWhite = false;
    value = safeAttrValue2(name, value);
    if (!value) return;
    var opts = {
      position,
      sourcePosition,
      source,
      isWhite
    };
    if (isWhite) {
      var ret = onAttr2(name, value, opts);
      if (isNull$1(ret)) {
        return name + ":" + value;
      } else {
        return ret;
      }
    } else {
      var ret = onIgnoreAttr2(name, value, opts);
      if (!isNull$1(ret)) {
        return ret;
      }
    }
  });
  return retCSS;
};
var css2 = FilterCSS$2;
(function(module, exports) {
  var DEFAULT2 = _default;
  var FilterCSS2 = css2;
  function filterCSS(html, options) {
    var xss2 = new FilterCSS2(options);
    return xss2.process(html);
  }
  exports = module.exports = filterCSS;
  exports.FilterCSS = FilterCSS2;
  for (var i2 in DEFAULT2) exports[i2] = DEFAULT2[i2];
  if (typeof window !== "undefined") {
    window.filterCSS = module.exports;
  }
})(lib, lib.exports);
var libExports$1 = lib.exports;
var util = {
  indexOf: function(arr, item) {
    var i2, j;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item);
    }
    for (i2 = 0, j = arr.length; i2 < j; i2++) {
      if (arr[i2] === item) {
        return i2;
      }
    }
    return -1;
  },
  forEach: function(arr, fn, scope) {
    var i2, j;
    if (Array.prototype.forEach) {
      return arr.forEach(fn, scope);
    }
    for (i2 = 0, j = arr.length; i2 < j; i2++) {
      fn.call(scope, arr[i2], i2, arr);
    }
  },
  trim: function(str) {
    if (String.prototype.trim) {
      return str.trim();
    }
    return str.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function(str) {
    var reg = /\s|\n|\t/;
    var match = reg.exec(str);
    return match ? match.index : -1;
  }
};
var FilterCSS$1 = libExports$1.FilterCSS;
var getDefaultCSSWhiteList = libExports$1.getDefaultWhiteList;
var _$2 = util;
function getDefaultWhiteList() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "preload",
      "src"
    ],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height", "loading"],
    ins: ["datetime"],
    kbd: [],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "playsinline",
      "poster",
      "preload",
      "src",
      "height",
      "width"
    ]
  };
}
var defaultCSSFilter = new FilterCSS$1();
function onTag(tag, html, options) {
}
function onIgnoreTag(tag, html, options) {
}
function onTagAttr(tag, name, value) {
}
function onIgnoreTagAttr(tag, name, value) {
}
function escapeHtml(html) {
  return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
}
function safeAttrValue(tag, name, value, cssFilter) {
  value = friendlyAttrValue(value);
  if (name === "href" || name === "src") {
    value = _$2.trim(value);
    if (value === "#") return "#";
    if (!(value.substr(0, 7) === "http://" || value.substr(0, 8) === "https://" || value.substr(0, 7) === "mailto:" || value.substr(0, 4) === "tel:" || value.substr(0, 11) === "data:image/" || value.substr(0, 6) === "ftp://" || value.substr(0, 2) === "./" || value.substr(0, 3) === "../" || value[0] === "#" || value[0] === "/")) {
      return "";
    }
  } else if (name === "background") {
    REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
      return "";
    }
  } else if (name === "style") {
    REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
      return "";
    }
    REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
      REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
        return "";
      }
    }
    if (cssFilter !== false) {
      cssFilter = cssFilter || defaultCSSFilter;
      value = cssFilter.process(value);
    }
  }
  value = escapeAttrValue(value);
  return value;
}
var REGEXP_LT = /</g;
var REGEXP_GT = />/g;
var REGEXP_QUOTE = /"/g;
var REGEXP_QUOTE_2 = /&quot;/g;
var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;
function escapeQuote(str) {
  return str.replace(REGEXP_QUOTE, "&quot;");
}
function unescapeQuote(str) {
  return str.replace(REGEXP_QUOTE_2, '"');
}
function escapeHtmlEntities(str) {
  return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str2, code) {
    return code[0] === "x" || code[0] === "X" ? String.fromCharCode(parseInt(code.substr(1), 16)) : String.fromCharCode(parseInt(code, 10));
  });
}
function escapeDangerHtml5Entities(str) {
  return str.replace(REGEXP_ATTR_VALUE_COLON, ":").replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
}
function clearNonPrintableCharacter(str) {
  var str2 = "";
  for (var i2 = 0, len = str.length; i2 < len; i2++) {
    str2 += str.charCodeAt(i2) < 32 ? " " : str.charAt(i2);
  }
  return _$2.trim(str2);
}
function friendlyAttrValue(str) {
  str = unescapeQuote(str);
  str = escapeHtmlEntities(str);
  str = escapeDangerHtml5Entities(str);
  str = clearNonPrintableCharacter(str);
  return str;
}
function escapeAttrValue(str) {
  str = escapeQuote(str);
  str = escapeHtml(str);
  return str;
}
function onIgnoreTagStripAll() {
  return "";
}
function StripTagBody(tags2, next) {
  if (typeof next !== "function") {
    next = function() {
    };
  }
  var isRemoveAllTag = !Array.isArray(tags2);
  function isRemoveTag(tag) {
    if (isRemoveAllTag) return true;
    return _$2.indexOf(tags2, tag) !== -1;
  }
  var removeList = [];
  var posStart = false;
  return {
    onIgnoreTag: function(tag, html, options) {
      if (isRemoveTag(tag)) {
        if (options.isClosing) {
          var ret = "[/removed]";
          var end = options.position + ret.length;
          removeList.push([
            posStart !== false ? posStart : options.position,
            end
          ]);
          posStart = false;
          return ret;
        } else {
          if (!posStart) {
            posStart = options.position;
          }
          return "[removed]";
        }
      } else {
        return next(tag, html, options);
      }
    },
    remove: function(html) {
      var rethtml = "";
      var lastPos = 0;
      _$2.forEach(removeList, function(pos) {
        rethtml += html.slice(lastPos, pos[0]);
        lastPos = pos[1];
      });
      rethtml += html.slice(lastPos);
      return rethtml;
    }
  };
}
function stripCommentTag(html) {
  var retHtml = "";
  var lastPos = 0;
  while (lastPos < html.length) {
    var i2 = html.indexOf("<!--", lastPos);
    if (i2 === -1) {
      retHtml += html.slice(lastPos);
      break;
    }
    retHtml += html.slice(lastPos, i2);
    var j = html.indexOf("-->", i2);
    if (j === -1) {
      break;
    }
    lastPos = j + 3;
  }
  return retHtml;
}
function stripBlankChar(html) {
  var chars = html.split("");
  chars = chars.filter(function(char) {
    var c = char.charCodeAt(0);
    if (c === 127) return false;
    if (c <= 31) {
      if (c === 10 || c === 13) return true;
      return false;
    }
    return true;
  });
  return chars.join("");
}
_default$1.whiteList = getDefaultWhiteList();
_default$1.getDefaultWhiteList = getDefaultWhiteList;
_default$1.onTag = onTag;
_default$1.onIgnoreTag = onIgnoreTag;
_default$1.onTagAttr = onTagAttr;
_default$1.onIgnoreTagAttr = onIgnoreTagAttr;
_default$1.safeAttrValue = safeAttrValue;
_default$1.escapeHtml = escapeHtml;
_default$1.escapeQuote = escapeQuote;
_default$1.unescapeQuote = unescapeQuote;
_default$1.escapeHtmlEntities = escapeHtmlEntities;
_default$1.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
_default$1.clearNonPrintableCharacter = clearNonPrintableCharacter;
_default$1.friendlyAttrValue = friendlyAttrValue;
_default$1.escapeAttrValue = escapeAttrValue;
_default$1.onIgnoreTagStripAll = onIgnoreTagStripAll;
_default$1.StripTagBody = StripTagBody;
_default$1.stripCommentTag = stripCommentTag;
_default$1.stripBlankChar = stripBlankChar;
_default$1.attributeWrapSign = '"';
_default$1.cssFilter = defaultCSSFilter;
_default$1.getDefaultCSSWhiteList = getDefaultCSSWhiteList;
var parser$1 = {};
var _$1 = util;
function getTagName(html) {
  var i2 = _$1.spaceIndex(html);
  var tagName;
  if (i2 === -1) {
    tagName = html.slice(1, -1);
  } else {
    tagName = html.slice(1, i2 + 1);
  }
  tagName = _$1.trim(tagName).toLowerCase();
  if (tagName.slice(0, 1) === "/") tagName = tagName.slice(1);
  if (tagName.slice(-1) === "/") tagName = tagName.slice(0, -1);
  return tagName;
}
function isClosing(html) {
  return html.slice(0, 2) === "</";
}
function parseTag$1(html, onTag2, escapeHtml2) {
  var rethtml = "";
  var lastPos = 0;
  var tagStart = false;
  var quoteStart = false;
  var currentPos = 0;
  var len = html.length;
  var currentTagName = "";
  var currentHtml = "";
  chariterator: for (currentPos = 0; currentPos < len; currentPos++) {
    var c = html.charAt(currentPos);
    if (tagStart === false) {
      if (c === "<") {
        tagStart = currentPos;
        continue;
      }
    } else {
      if (quoteStart === false) {
        if (c === "<") {
          rethtml += escapeHtml2(html.slice(lastPos, currentPos));
          tagStart = currentPos;
          lastPos = currentPos;
          continue;
        }
        if (c === ">" || currentPos === len - 1) {
          rethtml += escapeHtml2(html.slice(lastPos, tagStart));
          currentHtml = html.slice(tagStart, currentPos + 1);
          currentTagName = getTagName(currentHtml);
          rethtml += onTag2(
            tagStart,
            rethtml.length,
            currentTagName,
            currentHtml,
            isClosing(currentHtml)
          );
          lastPos = currentPos + 1;
          tagStart = false;
          continue;
        }
        if (c === '"' || c === "'") {
          var i2 = 1;
          var ic = html.charAt(currentPos - i2);
          while (ic.trim() === "" || ic === "=") {
            if (ic === "=") {
              quoteStart = c;
              continue chariterator;
            }
            ic = html.charAt(currentPos - ++i2);
          }
        }
      } else {
        if (c === quoteStart) {
          quoteStart = false;
          continue;
        }
      }
    }
  }
  if (lastPos < len) {
    rethtml += escapeHtml2(html.substr(lastPos));
  }
  return rethtml;
}
var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim;
function parseAttr$1(html, onAttr2) {
  var lastPos = 0;
  var lastMarkPos = 0;
  var retAttrs = [];
  var tmpName = false;
  var len = html.length;
  function addAttr(name, value) {
    name = _$1.trim(name);
    name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
    if (name.length < 1) return;
    var ret = onAttr2(name, value || "");
    if (ret) retAttrs.push(ret);
  }
  for (var i2 = 0; i2 < len; i2++) {
    var c = html.charAt(i2);
    var v, j;
    if (tmpName === false && c === "=") {
      tmpName = html.slice(lastPos, i2);
      lastPos = i2 + 1;
      lastMarkPos = html.charAt(lastPos) === '"' || html.charAt(lastPos) === "'" ? lastPos : findNextQuotationMark(html, i2 + 1);
      continue;
    }
    if (tmpName !== false) {
      if (i2 === lastMarkPos) {
        j = html.indexOf(c, i2 + 1);
        if (j === -1) {
          break;
        } else {
          v = _$1.trim(html.slice(lastMarkPos + 1, j));
          addAttr(tmpName, v);
          tmpName = false;
          i2 = j;
          lastPos = i2 + 1;
          continue;
        }
      }
    }
    if (/\s|\n|\t/.test(c)) {
      html = html.replace(/\s|\n|\t/g, " ");
      if (tmpName === false) {
        j = findNextEqual(html, i2);
        if (j === -1) {
          v = _$1.trim(html.slice(lastPos, i2));
          addAttr(v);
          tmpName = false;
          lastPos = i2 + 1;
          continue;
        } else {
          i2 = j - 1;
          continue;
        }
      } else {
        j = findBeforeEqual(html, i2 - 1);
        if (j === -1) {
          v = _$1.trim(html.slice(lastPos, i2));
          v = stripQuoteWrap(v);
          addAttr(tmpName, v);
          tmpName = false;
          lastPos = i2 + 1;
          continue;
        } else {
          continue;
        }
      }
    }
  }
  if (lastPos < html.length) {
    if (tmpName === false) {
      addAttr(html.slice(lastPos));
    } else {
      addAttr(tmpName, stripQuoteWrap(_$1.trim(html.slice(lastPos))));
    }
  }
  return _$1.trim(retAttrs.join(" "));
}
function findNextEqual(str, i2) {
  for (; i2 < str.length; i2++) {
    var c = str[i2];
    if (c === " ") continue;
    if (c === "=") return i2;
    return -1;
  }
}
function findNextQuotationMark(str, i2) {
  for (; i2 < str.length; i2++) {
    var c = str[i2];
    if (c === " ") continue;
    if (c === "'" || c === '"') return i2;
    return -1;
  }
}
function findBeforeEqual(str, i2) {
  for (; i2 > 0; i2--) {
    var c = str[i2];
    if (c === " ") continue;
    if (c === "=") return i2;
    return -1;
  }
}
function isQuoteWrapString(text) {
  if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === "'" && text[text.length - 1] === "'") {
    return true;
  } else {
    return false;
  }
}
function stripQuoteWrap(text) {
  if (isQuoteWrapString(text)) {
    return text.substr(1, text.length - 2);
  } else {
    return text;
  }
}
parser$1.parseTag = parseTag$1;
parser$1.parseAttr = parseAttr$1;
var FilterCSS = libExports$1.FilterCSS;
var DEFAULT = _default$1;
var parser = parser$1;
var parseTag = parser.parseTag;
var parseAttr = parser.parseAttr;
var _ = util;
function isNull(obj) {
  return obj === void 0 || obj === null;
}
function getAttrs(html) {
  var i2 = _.spaceIndex(html);
  if (i2 === -1) {
    return {
      html: "",
      closing: html[html.length - 2] === "/"
    };
  }
  html = _.trim(html.slice(i2 + 1, -1));
  var isClosing2 = html[html.length - 1] === "/";
  if (isClosing2) html = _.trim(html.slice(0, -1));
  return {
    html,
    closing: isClosing2
  };
}
function shallowCopyObject(obj) {
  var ret = {};
  for (var i2 in obj) {
    ret[i2] = obj[i2];
  }
  return ret;
}
function keysToLowerCase(obj) {
  var ret = {};
  for (var i2 in obj) {
    if (Array.isArray(obj[i2])) {
      ret[i2.toLowerCase()] = obj[i2].map(function(item) {
        return item.toLowerCase();
      });
    } else {
      ret[i2.toLowerCase()] = obj[i2];
    }
  }
  return ret;
}
function FilterXSS(options) {
  options = shallowCopyObject(options || {});
  if (options.stripIgnoreTag) {
    if (options.onIgnoreTag) {
      console.error(
        'Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time'
      );
    }
    options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
  }
  if (options.whiteList || options.allowList) {
    options.whiteList = keysToLowerCase(options.whiteList || options.allowList);
  } else {
    options.whiteList = DEFAULT.whiteList;
  }
  this.attributeWrapSign = options.singleQuotedAttributeValue === true ? "'" : DEFAULT.attributeWrapSign;
  options.onTag = options.onTag || DEFAULT.onTag;
  options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
  options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
  options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
  options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
  options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
  this.options = options;
  if (options.css === false) {
    this.cssFilter = false;
  } else {
    options.css = options.css || {};
    this.cssFilter = new FilterCSS(options.css);
  }
}
FilterXSS.prototype.process = function(html) {
  html = html || "";
  html = html.toString();
  if (!html) return "";
  var me = this;
  var options = me.options;
  var whiteList = options.whiteList;
  var onTag2 = options.onTag;
  var onIgnoreTag2 = options.onIgnoreTag;
  var onTagAttr2 = options.onTagAttr;
  var onIgnoreTagAttr2 = options.onIgnoreTagAttr;
  var safeAttrValue2 = options.safeAttrValue;
  var escapeHtml2 = options.escapeHtml;
  var attributeWrapSign = me.attributeWrapSign;
  var cssFilter = me.cssFilter;
  if (options.stripBlankChar) {
    html = DEFAULT.stripBlankChar(html);
  }
  if (!options.allowCommentTag) {
    html = DEFAULT.stripCommentTag(html);
  }
  var stripIgnoreTagBody = false;
  if (options.stripIgnoreTagBody) {
    stripIgnoreTagBody = DEFAULT.StripTagBody(
      options.stripIgnoreTagBody,
      onIgnoreTag2
    );
    onIgnoreTag2 = stripIgnoreTagBody.onIgnoreTag;
  }
  var retHtml = parseTag(
    html,
    function(sourcePosition, position, tag, html2, isClosing2) {
      var info = {
        sourcePosition,
        position,
        isClosing: isClosing2,
        isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag)
      };
      var ret = onTag2(tag, html2, info);
      if (!isNull(ret)) return ret;
      if (info.isWhite) {
        if (info.isClosing) {
          return "</" + tag + ">";
        }
        var attrs = getAttrs(html2);
        var whiteAttrList = whiteList[tag];
        var attrsHtml = parseAttr(attrs.html, function(name, value) {
          var isWhiteAttr = _.indexOf(whiteAttrList, name) !== -1;
          var ret2 = onTagAttr2(tag, name, value, isWhiteAttr);
          if (!isNull(ret2)) return ret2;
          if (isWhiteAttr) {
            value = safeAttrValue2(tag, name, value, cssFilter);
            if (value) {
              return name + "=" + attributeWrapSign + value + attributeWrapSign;
            } else {
              return name;
            }
          } else {
            ret2 = onIgnoreTagAttr2(tag, name, value, isWhiteAttr);
            if (!isNull(ret2)) return ret2;
            return;
          }
        });
        html2 = "<" + tag;
        if (attrsHtml) html2 += " " + attrsHtml;
        if (attrs.closing) html2 += " /";
        html2 += ">";
        return html2;
      } else {
        ret = onIgnoreTag2(tag, html2, info);
        if (!isNull(ret)) return ret;
        return escapeHtml2(html2);
      }
    },
    escapeHtml2
  );
  if (stripIgnoreTagBody) {
    retHtml = stripIgnoreTagBody.remove(retHtml);
  }
  return retHtml;
};
var xss$1 = FilterXSS;
(function(module, exports) {
  var DEFAULT2 = _default$1;
  var parser2 = parser$1;
  var FilterXSS2 = xss$1;
  function filterXSS(html, options) {
    var xss2 = new FilterXSS2(options);
    return xss2.process(html);
  }
  exports = module.exports = filterXSS;
  exports.filterXSS = filterXSS;
  exports.FilterXSS = FilterXSS2;
  (function() {
    for (var i2 in DEFAULT2) {
      exports[i2] = DEFAULT2[i2];
    }
    for (var j in parser2) {
      exports[j] = parser2[j];
    }
  })();
  if (typeof window !== "undefined") {
    window.filterXSS = module.exports;
  }
  function isWorkerEnv() {
    return typeof self !== "undefined" && typeof DedicatedWorkerGlobalScope !== "undefined" && self instanceof DedicatedWorkerGlobalScope;
  }
  if (isWorkerEnv()) {
    self.filterXSS = module.exports;
  }
})(lib$1, lib$1.exports);
var libExports = lib$1.exports;
var index = getDefaultExportFromCjs(libExports);
var xss = _mergeNamespaces({
  __proto__: null,
  default: index
}, [libExports]);
var MdWhiteList = {
  img: ["class"],
  // 支持任务列表
  input: ["class", "disabled", "type", "checked"],
  // 主要支持youtobe、腾讯视频、哔哩哔哩等内嵌视频代码
  iframe: [
    "class",
    "width",
    "height",
    "src",
    "title",
    "border",
    "frameborder",
    "framespacing",
    "allow",
    "allowfullscreen"
  ]
};
var XSSPlugin = (md, options) => {
  const { extendedWhiteList = {}, xss: xssOption = {} } = options;
  let xssIns;
  if (typeof xssOption === "function") {
    xssIns = new libExports.FilterXSS(xssOption(xss));
  } else {
    const whiteList = libExports.getDefaultWhiteList();
    const keys = [...Object.keys(extendedWhiteList), ...Object.keys(MdWhiteList)];
    keys.forEach((key) => {
      const xssWhiteItem = whiteList[key] || [];
      const innerWhiteItem = MdWhiteList[key] || [];
      const userDefWhiteItem = extendedWhiteList[key] || [];
      whiteList[key] = [
        .../* @__PURE__ */ new Set([...xssWhiteItem, ...innerWhiteItem, ...userDefWhiteItem])
      ];
    });
    xssIns = new libExports.FilterXSS({
      whiteList,
      // 自定义的优先级最高
      ...xssOption
    });
  }
  md.core.ruler.after("linkify", "xss", (state) => {
    for (let i2 = 0; i2 < state.tokens.length; i2++) {
      const cur = state.tokens[i2];
      switch (cur.type) {
        case "html_block": {
          cur.content = xssIns.process(cur.content);
          break;
        }
        case "inline": {
          const inlineTokens = cur.children || [];
          inlineTokens.forEach((it) => {
            if (it.type === "html_inline") {
              it.content = xssIns.process(it.content);
            }
          });
          break;
        }
      }
    }
  });
};
var attrSet = (token, name, value) => {
  const index2 = token.attrIndex(name);
  const attr = [name, value];
  if (index2 < 0) {
    token.attrPush(attr);
  } else {
    token.attrs = token.attrs || [];
    token.attrs[index2] = attr;
  }
};
var isInline = (token) => {
  return token.type === "inline";
};
var isParagraph = (token) => {
  return token.type === "paragraph_open";
};
var isListItem = (token) => {
  return token.type === "list_item_open";
};
var startsWithTodoMarkdown = (token) => {
  return token.content.indexOf("[ ] ") === 0 || token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0;
};
var isTodoItem = (tokens, index2) => {
  return isInline(tokens[index2]) && isParagraph(tokens[index2 - 1]) && isListItem(tokens[index2 - 2]) && startsWithTodoMarkdown(tokens[index2]);
};
var parentToken = (tokens, index2) => {
  const targetLevel = tokens[index2].level - 1;
  for (let i2 = index2 - 1; i2 >= 0; i2--) {
    if (tokens[i2].level === targetLevel) {
      return i2;
    }
  }
  return -1;
};
var beginLabel = (TokenConstructor) => {
  const token = new TokenConstructor("html_inline", "", 0);
  token.content = "<label>";
  return token;
};
var endLabel = (TokenConstructor) => {
  const token = new TokenConstructor("html_inline", "", 0);
  token.content = "</label>";
  return token;
};
var afterLabel = (content, id, TokenConstructor) => {
  const token = new TokenConstructor("html_inline", "", 0);
  token.content = '<label class="task-list-item-label" for="' + id + '">' + content + "</label>";
  token.attrs = [{ for: id }];
  return token;
};
var makeCheckbox = (token, TokenConstructor, options) => {
  const checkbox = new TokenConstructor("html_inline", "", 0);
  const disabledAttr = !options.enabled ? ' disabled="" ' : " ";
  if (token.content.indexOf("[ ] ") === 0) {
    checkbox.content = '<input class="task-list-item-checkbox"' + disabledAttr + 'type="checkbox">';
  } else if (token.content.indexOf("[x] ") === 0 || token.content.indexOf("[X] ") === 0) {
    checkbox.content = '<input class="task-list-item-checkbox" checked=""' + disabledAttr + 'type="checkbox">';
  }
  return checkbox;
};
var todoify = (token, TokenConstructor, options) => {
  token.children = token.children || [];
  token.children.unshift(makeCheckbox(token, TokenConstructor, options));
  token.children[1].content = token.children[1].content.slice(3);
  token.content = token.content.slice(3);
  if (options.label) {
    if (options.labelAfter) {
      token.children.pop();
      const id = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
      token.children[0].content = token.children[0].content.slice(0, -1) + ' id="' + id + '">';
      token.children.push(afterLabel(token.content, id, TokenConstructor));
    } else {
      token.children.unshift(beginLabel(TokenConstructor));
      token.children.push(endLabel(TokenConstructor));
    }
  }
};
var githubTaskLists = (md, options = {}) => {
  md.core.ruler.after("inline", "github-task-lists", (state) => {
    const tokens = state.tokens;
    for (let i2 = 2; i2 < tokens.length; i2++) {
      if (isTodoItem(tokens, i2)) {
        todoify(tokens[i2], state.Token, options);
        attrSet(
          tokens[i2 - 2],
          "class",
          "task-list-item" + (options.enabled ? " enabled" : " ")
        );
        attrSet(tokens[parentToken(tokens, i2 - 2)], "class", "contains-task-list");
      }
    }
  });
};
var initLineNumber = (md) => {
  md.core.ruler.push("init-line-number", (state) => {
    state.tokens.forEach((token) => {
      if (token.map) {
        if (!token.attrs) {
          token.attrs = [];
        }
        token.attrs.push(["data-line", token.map[0].toString()]);
      }
    });
    return true;
  });
};
var useMarkdownIt = (props8, previewOnly) => {
  const { editorConfig, markdownItConfig, markdownItPlugins } = configOption;
  const editorId = inject("editorId");
  const languageRef = inject("language");
  const usedLanguageTextRef = inject(
    "usedLanguageText"
  );
  const showCodeRowNumber = inject("showCodeRowNumber");
  const themeRef = inject("theme");
  const customIconRef = inject("customIcon");
  const rootRef = inject("rootRef");
  const headsRef = ref([]);
  const hljsRef = useHighlight(props8);
  const katexRef = useKatex(props8);
  const { reRenderRef, replaceMermaid } = useMermaid(props8);
  const md = lib_default({
    html: true,
    breaks: true,
    linkify: true
  });
  markdownItConfig(md, {
    editorId
  });
  const plugins = [
    {
      type: "image",
      plugin: r,
      options: { figcaption: true, classes: "md-zoom" }
    },
    {
      type: "admonition",
      plugin: AdmonitionPlugin,
      options: {}
    },
    {
      type: "taskList",
      plugin: githubTaskLists,
      options: {}
    },
    {
      type: "heading",
      plugin: HeadingPlugin,
      options: { mdHeadingId: props8.mdHeadingId, headsRef }
    },
    {
      type: "code",
      plugin: codetabs,
      options: {
        editorId,
        usedLanguageTextRef,
        // showCodeRowNumber,
        codeFoldable: props8.codeFoldable,
        autoFoldThreshold: props8.autoFoldThreshold,
        customIconRef
      }
    },
    {
      type: "xss",
      plugin: XSSPlugin,
      options: {}
    },
    {
      type: "sub",
      plugin: sub_plugin,
      options: {}
    },
    {
      type: "sup",
      plugin: sup_plugin,
      options: {}
    }
  ];
  if (!props8.noKatex) {
    plugins.push({
      type: "katex",
      plugin: KatexPlugin,
      options: { katexRef }
    });
  }
  if (!props8.noMermaid) {
    plugins.push({
      type: "mermaid",
      plugin: MermaidPlugin,
      options: { themeRef }
    });
  }
  markdownItPlugins(plugins, {
    editorId
  }).forEach((item) => {
    md.use(item.plugin, item.options);
  });
  const userDefHighlight = md.options.highlight;
  md.set({
    highlight: (str, language, attrs) => {
      if (userDefHighlight) {
        const result = userDefHighlight(str, language, attrs);
        if (result) {
          return result;
        }
      }
      let codeHtml;
      if (!props8.noHighlight && hljsRef.value) {
        const hljsLang = hljsRef.value.getLanguage(language);
        if (hljsLang) {
          codeHtml = hljsRef.value.highlight(str, {
            language,
            ignoreIllegals: true
          }).value;
        } else {
          codeHtml = hljsRef.value.highlightAuto(str).value;
        }
      } else {
        codeHtml = md.utils.escapeHtml(str);
      }
      const codeSpan = showCodeRowNumber ? generateCodeRowNumber(
        codeHtml.replace(/^\n+|\n+$/g, ""),
        str.replace(/^\n+|\n+$/g, "")
      ) : `<span class="${prefix}-code-block">${codeHtml.replace(/^\n+|\n+$/g, "")}</span>`;
      return `<pre><code class="language-${language}" language=${language}>${codeSpan}</code></pre>`;
    }
  });
  initLineNumber(md);
  const key = ref(`_article-key_${U()}`);
  const html = ref(props8.sanitize(md.render(props8.modelValue)));
  const updatedTodo = () => {
    bus.emit(editorId, BUILD_FINISHED, html.value);
    props8.onHtmlChanged(html.value);
    props8.onGetCatalog(headsRef.value);
    bus.emit(editorId, CATALOG_CHANGED, headsRef.value);
    nextTick(() => {
      replaceMermaid().then(() => {
        zoomMermaid(rootRef.value.querySelectorAll(`#${editorId} .${prefix}-mermaid`));
      });
    });
  };
  onMounted(updatedTodo);
  const markHtml = () => {
    headsRef.value = [];
    html.value = props8.sanitize(md.render(props8.modelValue));
    updatedTodo();
  };
  const needReRender = computed(() => {
    return (props8.noKatex || katexRef.value) && (props8.noHighlight || hljsRef.value);
  });
  watch(
    [toRef(props8, "modelValue"), needReRender, reRenderRef, languageRef],
    k(markHtml, previewOnly ? 0 : editorConfig.renderDelay)
  );
  watch(
    () => props8.setting.preview,
    () => {
      if (props8.setting.preview) {
        nextTick(() => {
          replaceMermaid().then(() => {
            zoomMermaid(
              rootRef.value.querySelectorAll(`#${editorId} .${prefix}-mermaid`)
            );
          });
          bus.emit(editorId, CATALOG_CHANGED, headsRef.value);
        });
      }
    }
  );
  onMounted(() => {
    bus.on(editorId, {
      name: PUSH_CATALOG,
      callback() {
        bus.emit(editorId, CATALOG_CHANGED, headsRef.value);
      }
    });
    bus.on(editorId, {
      name: RERENDER,
      callback: () => {
        key.value = `_article-key_${U()}`;
        markHtml();
      }
    });
  });
  return { html, key };
};
var template = {
  checked: {
    regexp: /- \[x\]/,
    value: "- [ ]"
  },
  unChecked: {
    regexp: /- \[\s\]/,
    value: "- [x]"
  }
};
var useTaskState = (props8, html) => {
  const editorId = inject("editorId");
  const rootRef = inject("rootRef");
  let removeListener = () => {
  };
  const addListener = () => {
    if (!rootRef.value) {
      return false;
    }
    const tasks = rootRef.value.querySelectorAll(".task-list-item.enabled");
    const listener = (e2) => {
      var _a3;
      e2.preventDefault();
      const nextValue = e2.target.checked ? "unChecked" : "checked";
      const line = (_a3 = e2.target.parentElement) == null ? void 0 : _a3.dataset.line;
      if (!line) {
        return;
      }
      const lineNumber = Number(line);
      const lines = props8.modelValue.split("\n");
      const targetValue = lines[Number(lineNumber)].replace(
        template[nextValue].regexp,
        template[nextValue].value
      );
      if (props8.previewOnly) {
        lines[Number(lineNumber)] = targetValue;
        props8.onChange(lines.join("\n"));
      } else {
        bus.emit(editorId, TASK_STATE_CHANGED, lineNumber + 1, targetValue);
      }
    };
    tasks.forEach((item) => {
      item.addEventListener("click", listener);
    });
    removeListener = () => {
      tasks.forEach((item) => {
        item.removeEventListener("click", listener);
      });
    };
  };
  onBeforeUnmount(() => {
    removeListener();
  });
  watch(
    [html],
    () => {
      removeListener();
      nextTick(addListener);
    },
    {
      immediate: true
    }
  );
};
var contentPreviewProps = {
  modelValue: {
    type: String,
    default: ""
  },
  onChange: {
    type: Function,
    default: () => {
    }
  },
  setting: {
    type: Object,
    default: () => ({ preview: true })
  },
  onHtmlChanged: {
    type: Function,
    default: () => {
    }
  },
  onGetCatalog: {
    type: Function,
    default: () => {
    }
  },
  mdHeadingId: {
    type: Function,
    default: () => ""
  },
  noMermaid: {
    type: Boolean,
    default: false
  },
  sanitize: {
    type: Function,
    default: (html) => html
  },
  // 不使用该函数功能
  noKatex: {
    type: Boolean,
    default: false
  },
  formatCopiedText: {
    type: Function,
    default: (text) => text
  },
  noHighlight: {
    type: Boolean,
    default: false
  },
  previewOnly: {
    type: Boolean,
    default: false
  },
  noImgZoomIn: {
    type: Boolean
  },
  sanitizeMermaid: {
    type: Function
  },
  codeFoldable: {
    type: Boolean
  },
  autoFoldThreshold: {
    type: Number
  }
};
var contentProps = {
  ...contentPreviewProps,
  updateModelValue: {
    type: Function,
    default: () => {
    }
  },
  placeholder: {
    type: String,
    default: ""
  },
  scrollAuto: {
    type: Boolean
  },
  autofocus: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  readonly: {
    type: Boolean
  },
  maxlength: {
    type: Number
  },
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: () => {
    }
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: () => {
    }
  },
  noPrettier: {
    type: Boolean
  },
  completions: {
    type: Array
  },
  catalogVisible: {
    type: Boolean
  },
  theme: {
    type: String,
    default: "light"
  },
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function,
    default: () => {
    }
  },
  inputBoxWitdh: {
    type: String
  },
  onInputBoxWitdhChange: {
    type: Function
  },
  transformImgUrl: {
    type: Function,
    default: (t2) => t2
  }
};
var ContentPreview = defineComponent({
  name: "ContentPreview",
  props: contentPreviewProps,
  setup(props8) {
    const editorId = inject("editorId");
    const previewTheme = inject("previewTheme");
    const showCodeRowNumber = inject("showCodeRowNumber");
    const {
      html,
      key
    } = useMarkdownIt(props8, props8.previewOnly);
    useCopyCode(props8, html, key);
    userZoom(props8, html);
    useTaskState(props8, html);
    return () => {
      return createVNode(Fragment, null, [props8.setting.preview && createVNode("div", {
        "id": `${editorId}-preview-wrapper`,
        "class": `${prefix}-preview-wrapper`,
        "key": "content-preview-wrapper"
      }, [createVNode("div", {
        "key": key.value,
        "id": `${editorId}-preview`,
        "class": [`${prefix}-preview`, `${previewTheme == null ? void 0 : previewTheme.value}-theme`, showCodeRowNumber && `${prefix}-scrn`],
        "innerHTML": html.value
      }, null)]), !props8.previewOnly && props8.setting.htmlPreview && createVNode("div", {
        "id": `${editorId}-html-wrapper`,
        "class": `${prefix}-preview-wrapper`,
        "key": "html-preview-wrapper"
      }, [createVNode("div", {
        "class": `${prefix}-html`
      }, [html.value])])]);
    };
  }
});
var useOnSave = (props8, context) => {
  const { editorId } = props8;
  const state = reactive({
    // 是否已编译成html
    buildFinished: false,
    // 存储当前最新的html
    html: ""
  });
  watch(
    () => props8.modelValue,
    () => {
      state.buildFinished = false;
    }
  );
  onMounted(() => {
    bus.on(editorId, {
      name: BUILD_FINISHED,
      callback(html) {
        state.buildFinished = true;
        state.html = html;
      }
    });
    bus.on(editorId, {
      name: ON_SAVE,
      callback() {
        const htmlPromise = new Promise((rev) => {
          if (state.buildFinished) {
            rev(state.html);
          } else {
            const buildFinishedCallback = (html) => {
              rev(html);
              bus.remove(editorId, BUILD_FINISHED, buildFinishedCallback);
            };
            bus.on(editorId, {
              name: BUILD_FINISHED,
              callback: buildFinishedCallback
            });
          }
        });
        if (props8.onSave) {
          props8.onSave(props8.modelValue, htmlPromise);
        } else {
          context.emit("onSave", props8.modelValue, htmlPromise);
        }
      }
    });
  });
};
var useProvidePreview = (props8, rootRef) => {
  const { editorId } = props8;
  const hljsUrls = configOption.editorExtensions.highlight;
  const hljsAttrs = configOption.editorExtensionsAttrs.highlight;
  provide("editorId", editorId);
  provide("rootRef", rootRef);
  provide(
    "theme",
    computed(() => props8.theme)
  );
  provide(
    "language",
    computed(() => props8.language)
  );
  provide(
    "highlight",
    computed(() => {
      const { js: jsUrl } = hljsUrls;
      const cssList = {
        ...codeCss,
        ...hljsUrls.css
      };
      const { js: jsAttrs, css: cssAttrs = {} } = hljsAttrs || {};
      const _theme = props8.codeStyleReverse && props8.codeStyleReverseList.includes(props8.previewTheme) ? "dark" : props8.theme;
      const codeCssHref = cssList[props8.codeTheme] ? cssList[props8.codeTheme][_theme] : codeCss.atom[_theme];
      const codeCssAttrs = cssList[props8.codeTheme] && cssAttrs[props8.codeTheme] ? cssAttrs[props8.codeTheme][_theme] : cssAttrs["atom"] ? cssAttrs["atom"][_theme] : {};
      return {
        js: {
          src: jsUrl,
          ...jsAttrs
        },
        css: {
          href: codeCssHref,
          ...codeCssAttrs
        }
      };
    })
  );
  provide("showCodeRowNumber", props8.showCodeRowNumber);
  const usedLanguageText = computed(() => {
    const allText = {
      ...staticTextDefault,
      ...configOption.editorConfig.languageUserDefined
    };
    return M(
      u(staticTextDefault["en-US"]),
      allText[props8.language] || {}
    );
  });
  provide("usedLanguageText", usedLanguageText);
  provide(
    "previewTheme",
    computed(() => props8.previewTheme)
  );
  provide(
    "customIcon",
    computed(() => props8.customIcon)
  );
};
var useProvide = (props8, rootRef) => {
  useProvidePreview(props8, rootRef);
  provide("tabWidth", props8.tabWidth);
};
var useExpansionPreview = (props8) => {
  onMounted(() => {
    const { editorExtensions, editorExtensionsAttrs: editorExtensionsAttrs2, iconfontType } = configOption;
    if (props8.noIconfont) {
      return;
    }
    if (iconfontType === "svg") {
      appendHandler("script", {
        ...editorExtensionsAttrs2.iconfont,
        src: editorExtensions.iconfont,
        id: `${prefix}-icon`
      });
    } else {
      appendHandler("link", {
        ...editorExtensionsAttrs2.iconfontClass,
        rel: "stylesheet",
        href: editorExtensions.iconfontClass,
        id: `${prefix}-icon-class`
      });
    }
  });
};
var useExpansion = (props8) => {
  const { noPrettier, noUploadImg } = props8;
  const { editorExtensions, editorExtensionsAttrs: editorExtensionsAttrs2 } = configOption;
  const noPrettierScript = noPrettier || editorExtensions.prettier.prettierInstance;
  const noParserMarkdownScript = noPrettier || editorExtensions.prettier.parserMarkdownInstance;
  const noCropperScript = noUploadImg || editorExtensions.cropper.instance;
  onMounted(() => {
    if (!noCropperScript) {
      const { js = {}, css: css22 = {} } = editorExtensionsAttrs2.cropper || {};
      appendHandler("link", {
        ...css22,
        rel: "stylesheet",
        href: editorExtensions.cropper.css,
        id: `${prefix}-cropperCss`
      });
      appendHandler("script", {
        ...js,
        src: editorExtensions.cropper.js,
        id: `${prefix}-cropper`
      });
    }
    if (!noPrettierScript) {
      const { standaloneJs = {} } = editorExtensionsAttrs2.prettier || {};
      appendHandler("script", {
        ...standaloneJs,
        src: editorExtensions.prettier.standaloneJs,
        id: `${prefix}-prettier`
      });
    }
    if (!noParserMarkdownScript) {
      const { parserMarkdownJs = {} } = editorExtensionsAttrs2.prettier || {};
      appendHandler("script", {
        ...parserMarkdownJs,
        src: editorExtensions.prettier.parserMarkdownJs,
        id: `${prefix}-prettierMD`
      });
    }
  });
  useExpansionPreview(props8);
};
var useErrorCatcher = (props8, context) => {
  const { editorId } = props8;
  onMounted(() => {
    bus.on(editorId, {
      name: ERROR_CATCHER,
      callback: (err) => {
        if (props8.onError instanceof Function) {
          props8.onError(err);
        } else {
          context.emit("onError", err);
        }
      }
    });
  });
};
var useConfig = (props8, context) => {
  const { editorId } = props8;
  const setting = reactive({
    pageFullscreen: props8.pageFullscreen,
    fullscreen: false,
    preview: props8.preview,
    htmlPreview: props8.preview ? false : props8.htmlPreview,
    previewOnly: false
  });
  const cacheSetting = reactive({ ...setting });
  const updateSetting = (k2, v) => {
    const realValue = v === void 0 ? !setting[k2] : v;
    switch (k2) {
      case "preview": {
        setting.htmlPreview = false;
        setting.previewOnly = false;
        break;
      }
      case "htmlPreview": {
        setting.preview = false;
        setting.previewOnly = false;
        break;
      }
      case "previewOnly": {
        if (realValue) {
          if (!setting.preview && !setting.htmlPreview) {
            setting.preview = true;
          }
        } else {
          if (!cacheSetting.preview) {
            setting.preview = false;
          }
          if (!cacheSetting.htmlPreview) {
            setting.htmlPreview = false;
          }
        }
        break;
      }
    }
    cacheSetting[k2] = realValue;
    setting[k2] = realValue;
  };
  let bodyOverflowHistory = "";
  const adjustBody = () => {
    if (setting.pageFullscreen || setting.fullscreen) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = bodyOverflowHistory;
    }
  };
  watch(() => [setting.pageFullscreen, setting.fullscreen], adjustBody);
  onMounted(() => {
    bus.on(editorId, {
      name: UPLOAD_IMAGE,
      callback(files, cb) {
        const insertHanlder = (urls) => {
          bus.emit(editorId, REPLACE, "image", {
            desc: "",
            urls
          });
          cb && cb();
        };
        if (props8.onUploadImg) {
          props8.onUploadImg(files, insertHanlder);
        } else {
          context.emit("onUploadImg", files, insertHanlder);
        }
      }
    });
    bodyOverflowHistory = document.body.style.overflow;
    adjustBody();
  });
  return [setting, updateSetting];
};
var useCatalog = (props8) => {
  const { editorId } = props8;
  const catalogShow = ref(false);
  onMounted(() => {
    bus.on(editorId, {
      name: CHANGE_CATALOG_VISIBLE,
      callback: (v) => {
        if (v === void 0) {
          catalogShow.value = !catalogShow.value;
        } else {
          catalogShow.value = v;
        }
      }
    });
  });
  const catalogVisible = computed(() => {
    return !props8.toolbarsExclude.includes("catalog") && props8.toolbars.includes("catalog") && catalogShow.value;
  });
  return catalogVisible;
};
var useExpose$1 = (props8, ctx, catalogVisible, setting, updateSetting, codeRef) => {
  const { editorId } = props8;
  watch(
    () => setting.pageFullscreen,
    (newVal) => {
      bus.emit(editorId, PAGE_FULL_SCREEN_CHANGED, newVal);
    }
  );
  watch(
    () => setting.fullscreen,
    (newVal) => {
      bus.emit(editorId, FULL_SCREEN_CHANGED, newVal);
    }
  );
  watch(
    () => setting.preview,
    (newVal) => {
      bus.emit(editorId, PREVIEW_CHANGED, newVal);
    }
  );
  watch(
    () => setting.previewOnly,
    (newVal) => {
      bus.emit(editorId, PREVIEW_ONLY_CHANGED, newVal);
    }
  );
  watch(
    () => setting.htmlPreview,
    (newVal) => {
      bus.emit(editorId, HTML_PREVIEW_CHANGED, newVal);
    }
  );
  watch(catalogVisible, (newVal) => {
    bus.emit(editorId, CATALOG_VISIBLE_CHANGED, newVal);
  });
  const exposeParam = {
    on(eventName, callBack) {
      switch (eventName) {
        case "pageFullscreen": {
          bus.on(editorId, {
            name: PAGE_FULL_SCREEN_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "fullscreen": {
          bus.on(editorId, {
            name: FULL_SCREEN_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "preview": {
          bus.on(editorId, {
            name: PREVIEW_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "previewOnly": {
          bus.on(editorId, {
            name: PREVIEW_ONLY_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "htmlPreview": {
          bus.on(editorId, {
            name: HTML_PREVIEW_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
        case "catalog": {
          bus.on(editorId, {
            name: CATALOG_VISIBLE_CHANGED,
            callback(status) {
              callBack(status);
            }
          });
          break;
        }
      }
    },
    togglePageFullscreen(status) {
      updateSetting("pageFullscreen", status);
    },
    toggleFullscreen(status) {
      bus.emit(editorId, CHANGE_FULL_SCREEN, status);
    },
    togglePreview(status) {
      updateSetting("preview", status);
    },
    togglePreviewOnly(status) {
      updateSetting("previewOnly", status);
    },
    toggleHtmlPreview(status) {
      updateSetting("htmlPreview", status);
    },
    toggleCatalog(status) {
      bus.emit(editorId, CHANGE_CATALOG_VISIBLE, status);
    },
    triggerSave() {
      bus.emit(editorId, ON_SAVE);
    },
    insert(generate) {
      bus.emit(editorId, REPLACE, "universal", { generate });
    },
    focus(options) {
      var _a3;
      (_a3 = codeRef.value) == null ? void 0 : _a3.focus(options);
    },
    rerender() {
      bus.emit(editorId, RERENDER);
    },
    getSelectedText() {
      var _a3;
      return (_a3 = codeRef.value) == null ? void 0 : _a3.getSelectedText();
    },
    resetHistory() {
      var _a3;
      (_a3 = codeRef.value) == null ? void 0 : _a3.resetHistory();
    },
    domEventHandlers(handlers) {
      bus.emit(editorId, EVENT_LISTENER, handlers);
    },
    execCommand(direct) {
      bus.emit(editorId, REPLACE, direct);
    },
    getEditorView() {
      var _a3;
      return (_a3 = codeRef.value) == null ? void 0 : _a3.getEditorView();
    }
  };
  ctx.expose(exposeParam);
};
var mdHeadingId = (text) => text;
var mdPreviewProps = {
  /**
   * markdown content.
   *
   * @default ''
   */
  modelValue: {
    type: String,
    default: ""
  },
  /**
   * input回调事件
   */
  onChange: {
    type: Function,
    default: void 0
  },
  /**
   * 主题，支持light和dark
   *
   * @default 'light'
   */
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 外层类名
   *
   * @default ''
   */
  class: {
    type: String,
    default: ""
  },
  /**
   * 预设语言名称
   *
   * @default 'zh-CN'
   */
  language: {
    type: String,
    default: "zh-CN"
  },
  /**
   * html变化事件
   */
  onHtmlChanged: {
    type: Function,
    default: void 0
  },
  /**
   * 获取目录结构
   */
  onGetCatalog: {
    type: Function,
    default: void 0
  },
  /**
   * 编辑器唯一标识
   *
   * @default 'md-editor-v3'
   */
  editorId: {
    type: String,
    default: () => getNextId("md-editor-v3_")
  },
  /**
   * 预览中代码是否显示行号
   *
   * @default true
   */
  showCodeRowNumber: {
    type: Boolean,
    default: true
  },
  /**
   * 预览内容样式
   *
   * @default 'default'
   */
  previewTheme: {
    type: String,
    default: "default"
  },
  /**
   * 编辑器样式
   */
  style: {
    type: Object,
    default: () => ({})
  },
  /**
   * 标题的id生成方式
   *
   * @default (text: string) => text
   */
  mdHeadingId: {
    type: Function,
    default: mdHeadingId
  },
  /**
   *
   * 不能保证文本正确的情况，在marked编译md文本后通过该方法处理
   * 推荐DOMPurify、sanitize-html
   *
   * @default (text: string) => text
   */
  sanitize: {
    type: Function,
    default: (html) => html
  },
  /**
   * 不使用该mermaid
   *
   * @default false
   */
  noMermaid: {
    type: Boolean,
    default: false
  },
  /**
   * 不使用katex
   *
   * @default false
   */
  noKatex: {
    type: Boolean,
    default: false
  },
  /**
   * 代码主题
   *
   * @default 'atom'
   */
  codeTheme: {
    type: String,
    default: "atom"
  },
  /**
   * 不插入iconfont链接
   *
   * @default false
   */
  noIconfont: {
    type: Boolean,
    default: void 0
  },
  /**
   * 复制代码格式化方法
   *
   * @default (text) => text
   */
  formatCopiedText: {
    type: Function,
    default: (text) => text
  },
  /**
   * 某些预览主题的代码模块背景是暗色系
   * 将这个属性设置为true，会自动在该主题下的light模式下使用暗色系的代码风格
   *
   * @default true
   */
  codeStyleReverse: {
    type: Boolean,
    default: true
  },
  /**
   * 需要自动调整的预览主题
   *
   * @default ['default', 'mk-cute']
   */
  codeStyleReverseList: {
    type: Array,
    default: ["default", "mk-cute"]
  },
  noHighlight: {
    type: Boolean,
    default: false
  },
  /**
   * 是否关闭编辑器默认的放大缩小功能
   */
  noImgZoomIn: {
    type: Boolean,
    default: false
  },
  /**
   * 自定义的图标
   */
  customIcon: {
    type: Object,
    default: {}
  },
  sanitizeMermaid: {
    type: Function,
    default: (h2) => Promise.resolve(h2)
  },
  /**
   * 是否开启折叠代码功能
   * 不开启会使用div标签替代details标签
   *
   * @default true
   */
  codeFoldable: {
    type: Boolean,
    default: true
  },
  /**
   * 触发自动折叠代码的行数阈值
   *
   * @default 30
   */
  autoFoldThreshold: {
    type: Number,
    default: 30
  }
};
var editorProps = {
  ...mdPreviewProps,
  /**
   * input回调事件
   */
  onSave: {
    type: Function,
    default: void 0
  },
  /**
   * 上传图片事件
   */
  onUploadImg: {
    type: Function,
    default: void 0
  },
  /**
   * 是否页面内全屏
   *
   * @default false
   */
  pageFullscreen: {
    type: Boolean,
    default: false
  },
  /**
   * 是否展开预览
   *
   * @default true
   */
  preview: {
    type: Boolean,
    default: true
  },
  /**
   * 是否展开html预览
   *
   * @default false
   */
  htmlPreview: {
    type: Boolean,
    default: false
  },
  /**
   * 仅预览模式，不显示toolbar和编辑框
   *
   * @4.0.0开始移除该设置，使用组件MdPreview替换
   *
   * @default false
   */
  // previewOnly: {
  //   type: Boolean as PropType<boolean>,
  //   default: false
  // },
  /**
   * 工具栏选择显示
   *
   * @default allToolbar
   */
  toolbars: {
    type: Array,
    default: allToolbar
  },
  /**
   * 工具栏选择不显示
   *
   * @default []
   */
  toolbarsExclude: {
    type: Array,
    default: []
  },
  /**
   * 格式化md
   *
   * @default true
   */
  noPrettier: {
    type: Boolean,
    default: false
  },
  /**
   * 一个tab等于空格数
   *
   * @default 2
   */
  tabWidth: {
    type: Number,
    default: 2
  },
  /**
   * 表格预设格子数
   *
   * 也可以是[6, 4, 10, 8]
   *
   * @default [6, 4]
   */
  tableShape: {
    type: Array,
    default: [6, 4]
  },
  /**
   * 空提示
   *
   * @default ''
   */
  placeholder: {
    type: String,
    default: ""
  },
  /**
   * 自定义的工具栏列表
   */
  defToolbars: {
    type: [String, Object],
    default: void 0
  },
  /**
   * 内部错误捕获
   */
  onError: {
    type: Function,
    default: void 0
  },
  /**
   * 页脚列表显示顺序
   */
  footers: {
    type: Array,
    default: allFooter
  },
  /**
   * 是否默认激活输入框和预览框同步滚动
   *
   * @default true
   */
  scrollAuto: {
    type: Boolean,
    default: true
  },
  /**
   * 自定义的也叫工具组件列表
   */
  defFooters: {
    type: [String, Object],
    default: void 0
  },
  /**
   * 是否禁用上传图片
   *
   * @default false
   */
  noUploadImg: {
    type: Boolean,
    default: false
  },
  /**
   * 文本区域自动获得焦点
   *
   * @default false
   */
  autoFocus: {
    type: Boolean,
    default: false
  },
  /**
   * 禁用文本区域
   *
   * @default false
   */
  disabled: {
    type: Boolean,
    default: false
  },
  /**
   * 文本区域为只读
   *
   * @default false
   */
  readOnly: {
    type: Boolean,
    default: false
  },
  /**
   * 文本区域允许的最大字符数
   */
  maxLength: {
    type: Number,
    default: void 0
  },
  /**
   * 是否启用自动识别粘贴代码类别
   * 目前支持 vscode 复制的代码识别
   *
   * @default false
   */
  autoDetectCode: {
    type: Boolean,
    default: false
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: void 0
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: void 0
  },
  /**
   * @codemirror/autocomplete匹配关键词的方法列表
   *
   * 它会被像下面这样嵌入编辑器
   *
   * import { autocompletion } from '@codemirror/autocomplete';
   * autocompletion({
   *   override: [...completions]
   * })
   */
  completions: {
    type: Array,
    default: void 0
  },
  /**
   * 是否在工具栏下面显示对应的文字名称
   *
   * @default false
   */
  showToolbarName: {
    type: Boolean,
    default: false
  },
  /**
   * 字符输入事件
   */
  onInput: {
    type: Function,
    default: void 0
  },
  onDrop: {
    type: Function,
    default: void 0
  },
  /**
   * 输入框的默认宽度
   *
   * @example '100px'/'50%'
   * @default '50%
   */
  inputBoxWitdh: {
    type: String,
    default: "50%"
  },
  /**
   * 输入框宽度变化事件
   */
  onInputBoxWitdhChange: {
    type: Function,
    default: void 0
  },
  /**
   * 替换粘贴的图片链接
   *
   * @param t 图片链接
   * @returns
   */
  transformImgUrl: {
    type: Function,
    default: (t2) => t2
  }
};
var mdPreviewEmits = [
  "onHtmlChanged",
  "onGetCatalog",
  "onChange",
  "update:modelValue"
];
var editorEmits = [
  ...mdPreviewEmits,
  "onSave",
  "onUploadImg",
  "onError",
  "onBlur",
  "onFocus",
  "onInput",
  "onDrop",
  "onInputBoxWitdhChange"
];
var useExpose = (props8, ctx) => {
  const { editorId } = props8;
  const exposeParam = {
    rerender() {
      bus.emit(editorId, RERENDER);
    }
  };
  ctx.expose(exposeParam);
};
var MdPreview = defineComponent({
  name: "MdPreview",
  props: mdPreviewProps,
  emits: mdPreviewEmits,
  setup(props8, ctx) {
    const {
      editorId,
      noKatex,
      noMermaid,
      noHighlight
    } = props8;
    const rootRef = ref();
    useProvidePreview(props8, rootRef);
    useExpansionPreview(props8);
    useExpose(props8, ctx);
    onBeforeUnmount(() => {
      bus.clear(editorId);
    });
    return () => {
      return createVNode("div", {
        "id": editorId,
        "class": [prefix, props8.class, props8.theme === "dark" && `${prefix}-dark`, `${prefix}-previewOnly`],
        "style": props8.style,
        "ref": rootRef
      }, [createVNode(ContentPreview, {
        "modelValue": props8.modelValue,
        "onChange": (value) => {
          if (props8.onChange) {
            props8.onChange(value);
          }
          ctx.emit("onChange", value);
          ctx.emit("update:modelValue", value);
        },
        "onHtmlChanged": (html) => {
          if (props8.onHtmlChanged) {
            props8.onHtmlChanged(html);
          } else {
            ctx.emit("onHtmlChanged", html);
          }
        },
        "onGetCatalog": (list) => {
          if (props8.onGetCatalog) {
            props8.onGetCatalog(list);
          } else {
            ctx.emit("onGetCatalog", list);
          }
        },
        "mdHeadingId": props8.mdHeadingId,
        "noMermaid": noMermaid,
        "sanitize": props8.sanitize,
        "noKatex": noKatex,
        "formatCopiedText": props8.formatCopiedText,
        "noHighlight": noHighlight,
        "noImgZoomIn": props8.noImgZoomIn,
        "previewOnly": true,
        "sanitizeMermaid": props8.sanitizeMermaid,
        "codeFoldable": props8.codeFoldable,
        "autoFoldThreshold": props8.autoFoldThreshold
      }, null)]);
    };
  }
});
MdPreview.install = (app) => {
  app.component(MdPreview.name, MdPreview);
  return app;
};

// node_modules/md-editor-v3/lib/es/NormalToolbar.mjs
var props4 = {
  title: {
    type: String,
    default: ""
  },
  // 展示在工具栏的内容，通常是个图标
  trigger: {
    type: [String, Object],
    default: void 0
  },
  onClick: {
    type: Function,
    default: void 0
  },
  /**
   * ==没有意义，仅用于规避克隆组件自动嵌入insert方法时，传入的是该组件而产生的waring
   */
  insert: {
    type: Function,
    default: void 0
  },
  language: {
    type: String,
    default: void 0
  },
  theme: {
    type: String,
    default: void 0
  },
  previewTheme: {
    type: String,
    default: void 0
  },
  codeTheme: {
    type: String,
    default: void 0
  }
  /**
   * ==结束
   */
};
var NormalToolbar = defineComponent({
  name: "NormalToolbar",
  props: props4,
  emits: ["onClick"],
  setup(props22, ctx) {
    return () => {
      const Trigger = getSlot({
        props: props22,
        ctx
      }, "trigger");
      return createVNode("div", {
        "class": `${prefix}-toolbar-item`,
        "title": props22.title,
        "onClick": (e2) => {
          if (props22.onClick instanceof Function) {
            props22.onClick(e2);
          } else {
            ctx.emit("onClick", e2);
          }
        }
      }, [Trigger]);
    };
  }
});
NormalToolbar.install = (app) => {
  app.component(NormalToolbar.name, NormalToolbar);
  return app;
};

// node_modules/md-editor-v3/lib/es/ModalToolbar.mjs
function _isSlot(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var props5 = {
  title: {
    type: String,
    default: ""
  },
  modalTitle: {
    type: String,
    default: ""
  },
  visible: {
    type: Boolean,
    default: void 0
  },
  width: {
    type: String,
    default: "auto"
  },
  height: {
    type: String,
    default: "auto"
  },
  // 展示在工具栏的内容，通常是个图标
  trigger: {
    type: [String, Object],
    default: void 0
  },
  onClick: {
    type: Function,
    default: void 0
  },
  onClose: {
    type: Function,
    default: void 0
  },
  /**
   * 显示全屏按钮
   */
  showAdjust: {
    type: Boolean,
    default: false
  },
  isFullscreen: {
    type: Boolean,
    default: false
  },
  onAdjust: {
    type: Function,
    default: void 0
  },
  class: {
    type: String,
    default: void 0
  },
  style: {
    type: [Object, String],
    default: void 0
  },
  showMask: {
    type: Boolean,
    default: true
  },
  /**
   * ==没有意义，仅用于规避克隆组件自动嵌入insert方法时，传入的是该组件而产生的waring
   */
  insert: {
    type: Function,
    default: void 0
  },
  language: {
    type: String,
    default: void 0
  },
  theme: {
    type: String,
    default: void 0
  },
  previewTheme: {
    type: String,
    default: void 0
  },
  codeTheme: {
    type: String,
    default: void 0
  }
  /**
   * ==结束
   */
};
var ModalToolbar = defineComponent({
  name: "ModalToolbar",
  props: props5,
  emits: ["onClick", "onClose", "onAdjust"],
  setup(props22, ctx) {
    return () => {
      const Trigger = getSlot({
        props: props22,
        ctx
      }, "trigger");
      const Default = getSlot({
        props: props22,
        ctx
      }, "default");
      return createVNode(Fragment, null, [createVNode("div", {
        "class": `${prefix}-toolbar-item`,
        "title": props22.title,
        "onClick": () => {
          if (props22.onClick instanceof Function) {
            props22.onClick();
          } else {
            ctx.emit("onClick");
          }
        }
      }, [Trigger]), createVNode(MdModal, {
        "style": props22.style,
        "class": props22.class,
        "width": props22.width,
        "height": props22.height,
        "title": props22.modalTitle,
        "visible": props22.visible,
        "showMask": props22.showMask,
        "onClose": () => {
          if (props22.onClose instanceof Function) {
            props22.onClose();
          } else {
            ctx.emit("onClose");
          }
        },
        "showAdjust": props22.showAdjust,
        "isFullscreen": props22.isFullscreen,
        "onAdjust": (v) => {
          if (props22.onAdjust instanceof Function) {
            props22.onAdjust(v);
          } else {
            ctx.emit("onAdjust", v);
          }
        }
      }, _isSlot(Default) ? Default : {
        default: () => [Default]
      })]);
    };
  }
});
ModalToolbar.install = (app) => {
  app.component(ModalToolbar.name, ModalToolbar);
  return app;
};

// node_modules/md-editor-v3/lib/es/MdEditor.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var Divider = defineComponent({
  setup() {
    return () => createVNode("div", {
      "class": `${prefix}-divider`
    }, null);
  }
});
var toolbarProps = {
  noPrettier: {
    type: Boolean
  },
  // 工具栏选择显示
  toolbars: {
    type: Array,
    default: () => []
  },
  // 工具栏选择不显示
  toolbarsExclude: {
    type: Array,
    default: () => []
  },
  setting: {
    type: Object,
    default: () => ({})
  },
  screenfull: {
    type: Object,
    default: null
  },
  screenfullJs: {
    type: String,
    default: ""
  },
  updateSetting: {
    type: Function,
    default: () => {
    }
  },
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  defToolbars: {
    type: Object
  },
  noUploadImg: {
    type: Boolean
  },
  /**
   * 是否在工具栏下面显示对应的文字名称
   *
   * @default false
   */
  showToolbarName: {
    type: Boolean
  },
  catalogVisible: {
    type: Boolean
  },
  codeTheme: {
    type: String
  }
};
var useSreenfull = (props22) => {
  const editorId = inject("editorId");
  const { editorExtensions, editorExtensionsAttrs: editorExtensionsAttrs2 } = configOption;
  let screenfull = editorExtensions.screenfull.instance;
  const screenfullMe = ref(false);
  const fullscreenHandler = (status) => {
    if (!screenfull) {
      bus.emit(editorId, ERROR_CATCHER, {
        name: "fullscreen",
        message: "fullscreen is undefined"
      });
      return;
    }
    if (screenfull.isEnabled) {
      screenfullMe.value = true;
      const targetStatus = status === void 0 ? !screenfull.isFullscreen : status;
      if (targetStatus) {
        screenfull.request();
      } else {
        screenfull.exit();
      }
    } else {
      console.error("browser does not support screenfull!");
    }
  };
  const onScreenfullEvent = () => {
    if (screenfull && screenfull.isEnabled) {
      screenfull.on("change", () => {
        if (screenfullMe.value || props22.setting.fullscreen) {
          screenfullMe.value = false;
          props22.updateSetting("fullscreen");
        }
      });
    }
  };
  const screenfullLoad = () => {
    screenfull = window.screenfull;
    onScreenfullEvent();
  };
  onMounted(() => {
    var _a3;
    onScreenfullEvent();
    if (!screenfull) {
      appendHandler(
        "script",
        {
          ...(_a3 = editorExtensionsAttrs2.screenfull) == null ? void 0 : _a3.js,
          src: editorExtensions.screenfull.js,
          id: `${prefix}-screenfull`,
          onload: screenfullLoad
        },
        "screenfull"
      );
    }
  });
  onMounted(() => {
    bus.on(editorId, {
      name: CHANGE_FULL_SCREEN,
      callback: fullscreenHandler
    });
  });
  return { fullscreenHandler };
};
var props$6 = {
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  onSelected: {
    type: Function,
    default: () => {
    }
  }
};
var TableShape = defineComponent({
  name: "TableShape",
  props: props$6,
  setup(props22) {
    const hoverPosition = reactive({
      x: -1,
      y: -1
    });
    const tableShapeStr = computed(() => {
      return JSON.stringify(props22.tableShape);
    });
    const initShape = () => {
      const shape = [...JSON.parse(tableShapeStr.value)];
      if (!shape[2] || shape[2] < shape[0]) {
        shape[2] = shape[0];
      }
      if (!shape[3] || shape[3] < shape[3]) {
        shape[3] = shape[1];
      }
      return shape;
    };
    const tableShape = ref(initShape());
    watch([tableShapeStr], () => {
      tableShape.value = initShape();
    });
    return () => createVNode("div", {
      "class": `${prefix}-table-shape`,
      "onMouseleave": () => {
        tableShape.value = initShape();
        hoverPosition.x = -1;
        hoverPosition.y = -1;
      }
    }, [new Array(tableShape.value[1]).fill("").map((_2, rowIndex) => createVNode("div", {
      "class": `${prefix}-table-shape-row`,
      "key": `table-shape-row-${rowIndex}`
    }, [new Array(tableShape.value[0]).fill("").map((_22, colIndex) => createVNode("div", {
      "class": `${prefix}-table-shape-col`,
      "key": `table-shape-col-${colIndex}`,
      "onMouseenter": () => {
        hoverPosition.x = rowIndex;
        hoverPosition.y = colIndex;
        if (colIndex + 1 === tableShape.value[0] && colIndex + 1 < tableShape.value[2]) {
          tableShape.value[0]++;
        } else if (colIndex + 2 < tableShape.value[0] && tableShape.value[0] > props22.tableShape[0]) {
          tableShape.value[0]--;
        }
        if (rowIndex + 1 === tableShape.value[1] && rowIndex + 1 < tableShape.value[3]) {
          tableShape.value[1]++;
        } else if (rowIndex + 2 < tableShape.value[1] && tableShape.value[1] > props22.tableShape[1]) {
          tableShape.value[1]--;
        }
      },
      "onClick": () => {
        props22.onSelected(hoverPosition);
      }
    }, [createVNode("div", {
      "class": [`${prefix}-table-shape-col-default`, rowIndex <= hoverPosition.x && colIndex <= hoverPosition.y && `${prefix}-table-shape-col-include`]
    }, null)]))]))]);
  }
});
var props$5 = {
  type: {
    type: String,
    default: "link"
  },
  visible: {
    type: Boolean,
    default: false
  },
  onCancel: {
    type: Function,
    default: () => {
    }
  },
  onOk: {
    type: Function,
    default: () => {
    }
  }
};
var LinkModal = defineComponent({
  props: props$5,
  setup(props22) {
    const ult = inject("usedLanguageText");
    const editorId = inject("editorId");
    const title = computed(() => {
      var _a3, _b2;
      switch (props22.type) {
        case "link": {
          return (_a3 = ult.value.linkModalTips) == null ? void 0 : _a3.linkTitle;
        }
        case "image": {
          return (_b2 = ult.value.linkModalTips) == null ? void 0 : _b2.imageTitle;
        }
        default: {
          return "";
        }
      }
    });
    const linkData = reactive({
      desc: "",
      url: ""
    });
    watch(() => props22.visible, (nVal) => {
      if (!nVal) {
        setTimeout(() => {
          linkData.desc = "";
          linkData.url = "";
        }, 200);
      }
    });
    return () => createVNode(MdModal, {
      "title": title.value,
      "visible": props22.visible,
      "onClose": props22.onCancel
    }, {
      default: () => {
        var _a3, _b2, _c, _d, _e;
        return [createVNode("div", {
          "class": `${prefix}-form-item`
        }, [createVNode("label", {
          "class": `${prefix}-label`,
          "for": `link-desc-${editorId}`
        }, [(_a3 = ult.value.linkModalTips) == null ? void 0 : _a3.descLabel]), createVNode("input", {
          "placeholder": (_b2 = ult.value.linkModalTips) == null ? void 0 : _b2.descLabelPlaceHolder,
          "class": `${prefix}-input`,
          "id": `link-desc-${editorId}`,
          "type": "text",
          "value": linkData.desc,
          "onChange": (e2) => {
            linkData.desc = e2.target.value;
          },
          "autocomplete": "off"
        }, null)]), createVNode("div", {
          "class": `${prefix}-form-item`
        }, [createVNode("label", {
          "class": `${prefix}-label`,
          "for": `link-url-${editorId}`
        }, [(_c = ult.value.linkModalTips) == null ? void 0 : _c.urlLabel]), createVNode("input", {
          "placeholder": (_d = ult.value.linkModalTips) == null ? void 0 : _d.urlLabelPlaceHolder,
          "class": `${prefix}-input`,
          "id": `link-url-${editorId}`,
          "type": "text",
          "value": linkData.url,
          "onChange": (e2) => {
            linkData.url = e2.target.value;
          },
          "autocomplete": "off"
        }, null)]), createVNode("div", {
          "class": `${prefix}-form-item`
        }, [createVNode("button", {
          "class": [`${prefix}-btn`, `${prefix}-btn-row`],
          "type": "button",
          "onClick": () => {
            props22.onOk(linkData);
            linkData.desc = "";
            linkData.url = "";
          }
        }, [(_e = ult.value.linkModalTips) == null ? void 0 : _e.buttonOK])])];
      }
    });
  }
});
var props$4 = {
  visible: {
    type: Boolean,
    default: false
  },
  onCancel: {
    type: Function,
    default: () => {
    }
  },
  onOk: {
    type: Function,
    default: () => {
    }
  }
};
var ClipModal = defineComponent({
  props: props$4,
  setup(props22) {
    const ult = inject("usedLanguageText");
    const editorId = inject("editorId");
    const rootRef = inject("rootRef");
    let Cropper = configOption.editorExtensions.cropper.instance;
    const uploadRef = ref();
    const uploadImgRef = ref();
    const previewTargetRef = ref();
    const data = reactive({
      cropperInited: false,
      imgSelected: false,
      imgSrc: "",
      // 是否全屏
      isFullscreen: false
    });
    let cropper = null;
    watch(() => props22.visible, () => {
      if (props22.visible && !data.cropperInited) {
        Cropper = Cropper || window.Cropper;
        uploadRef.value.onchange = () => {
          if (!Cropper) {
            bus.emit(editorId, ERROR_CATCHER, {
              name: "Cropper",
              message: "Cropper is undefined"
            });
            return;
          }
          const fileList = uploadRef.value.files || [];
          data.imgSelected = true;
          if ((fileList == null ? void 0 : fileList.length) > 0) {
            const fileReader = new FileReader();
            fileReader.onload = (e2) => {
              data.imgSrc = e2.target.result;
            };
            fileReader.readAsDataURL(fileList[0]);
          }
        };
      }
    });
    watch(() => [data.imgSelected], () => {
      previewTargetRef.value.style = "";
    });
    watch([toRef(() => data.isFullscreen), toRef(() => data.imgSrc)], () => {
      if (data.imgSrc) {
        nextTick(() => {
          cropper == null ? void 0 : cropper.destroy();
          previewTargetRef.value.style = "";
          if (uploadImgRef.value) {
            cropper = new Cropper(uploadImgRef.value, {
              viewMode: 2,
              preview: rootRef.value.getRootNode().querySelector(`.${prefix}-clip-preview-target`)
              // aspectRatio: 16 / 9,
            });
          }
        });
      }
    });
    const reset = () => {
      cropper.clear();
      cropper.destroy();
      cropper = null;
      uploadRef.value.value = "";
      data.imgSelected = false;
    };
    return () => {
      var _a3;
      return createVNode(MdModal, {
        "class": `${prefix}-modal-clip`,
        "title": (_a3 = ult.value.clipModalTips) == null ? void 0 : _a3.title,
        "visible": props22.visible,
        "onClose": props22.onCancel,
        "showAdjust": true,
        "isFullscreen": data.isFullscreen,
        "onAdjust": (val) => {
          data.isFullscreen = val;
        },
        "width": "668px",
        "height": "421px"
      }, {
        default: () => {
          var _a22, _b2, _c;
          return [createVNode("div", {
            "class": `${prefix}-form-item ${prefix}-clip`
          }, [createVNode("div", {
            "class": `${prefix}-clip-main`
          }, [data.imgSelected ? createVNode("div", {
            "class": `${prefix}-clip-cropper`
          }, [createVNode("img", {
            "src": data.imgSrc,
            "ref": uploadImgRef,
            "style": {
              display: "none"
            },
            "alt": ""
          }, null), createVNode("div", {
            "class": `${prefix}-clip-delete`,
            "onClick": reset
          }, [createVNode(Icon, {
            "name": "delete"
          }, null)])]) : createVNode("div", {
            "class": `${prefix}-clip-upload`,
            "onClick": () => {
              uploadRef.value.click();
            },
            "role": "button",
            "tabindex": "0",
            "aria-label": (_a22 = ult.value.imgTitleItem) == null ? void 0 : _a22.upload
          }, [createVNode(Icon, {
            "name": "upload"
          }, null)])]), createVNode("div", {
            "class": `${prefix}-clip-preview`
          }, [createVNode("div", {
            "class": `${prefix}-clip-preview-target`,
            "ref": previewTargetRef
          }, null)])]), createVNode("div", {
            "class": `${prefix}-form-item`
          }, [createVNode("button", {
            "class": `${prefix}-btn`,
            "type": "button",
            "onClick": () => {
              if (cropper) {
                const cvs = cropper.getCroppedCanvas();
                bus.emit(editorId, UPLOAD_IMAGE, [base642File(cvs.toDataURL("image/png"))], props22.onOk);
                reset();
              }
            }
          }, [((_b2 = ult.value.clipModalTips) == null ? void 0 : _b2.buttonUpload) || ((_c = ult.value.linkModalTips) == null ? void 0 : _c.buttonOK)])]), createVNode("input", {
            "ref": uploadRef,
            "accept": "image/*",
            "type": "file",
            "multiple": false,
            "style": {
              display: "none"
            },
            "aria-hidden": "true"
          }, null)];
        }
      });
    };
  }
});
var props$3 = {
  type: {
    type: String,
    default: "link"
  },
  linkVisible: {
    type: Boolean,
    default: false
  },
  clipVisible: {
    type: Boolean,
    default: false
  },
  onCancel: {
    type: Function,
    default: () => {
    }
  },
  onOk: {
    type: Function,
    default: () => {
    }
  }
};
var Modals = defineComponent({
  props: props$3,
  setup(props22) {
    return () => createVNode(Fragment, null, [createVNode(LinkModal, {
      "type": props22.type,
      "visible": props22.linkVisible,
      "onOk": props22.onOk,
      "onCancel": props22.onCancel
    }, null), createVNode(ClipModal, {
      "visible": props22.clipVisible,
      "onOk": props22.onOk,
      "onCancel": props22.onCancel
    }, null)]);
  }
});
var ToolBar = defineComponent({
  name: "MDEditorToolbar",
  props: toolbarProps,
  setup(props22) {
    const editorId = inject("editorId");
    const ult = inject("usedLanguageText");
    const theme = inject("theme");
    const previewTheme = inject("previewTheme");
    const language = inject("language");
    const {
      fullscreenHandler
    } = useSreenfull(props22);
    const wrapperId = `${editorId}-toolbar-wrapper`;
    const wrapperRef = ref();
    const visible = reactive({
      title: false,
      catalog: false,
      // 图片上传下拉
      image: false,
      // 表格预选
      table: false,
      // mermaid
      mermaid: false,
      katex: false
    });
    const emitHandler = (direct, params) => {
      bus.emit(editorId, REPLACE, direct, params);
    };
    const modalData = reactive({
      type: "link",
      linkVisible: false,
      clipVisible: false
    });
    const toolbarLeftRef = ref();
    onMounted(() => {
      bus.on(editorId, {
        name: OPEN_MODALS,
        callback(type) {
          modalData.type = type;
          modalData.linkVisible = true;
        }
      });
    });
    const splitedbar = computed(() => {
      const excluedBars = props22.toolbars.filter((barItem) => !props22.toolbarsExclude.includes(barItem));
      const moduleSplitIndex = excluedBars.indexOf("=");
      const barLeft = moduleSplitIndex === -1 ? excluedBars : excluedBars.slice(0, moduleSplitIndex + 1);
      const barRight = moduleSplitIndex === -1 ? [] : excluedBars.slice(moduleSplitIndex, Number.MAX_SAFE_INTEGER);
      return [barLeft, barRight];
    });
    const uploadRef = ref();
    const uploadHandler = () => {
      bus.emit(editorId, UPLOAD_IMAGE, Array.from(uploadRef.value.files || []));
      uploadRef.value.value = "";
    };
    onMounted(() => {
      uploadRef.value.addEventListener("change", uploadHandler);
    });
    const barRender = (barItem) => {
      var _a3, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa, _ba, _ca, _da, _ea, _fa, _ga, _ha, _ia, _ja, _ka, _la, _ma, _na, _oa, _pa, _qa, _ra, _sa, _ta, _ua, _va, _wa;
      if (allToolbar.includes(barItem)) {
        switch (barItem) {
          case "-": {
            return createVNode(Divider, null, null);
          }
          case "bold": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_a3 = ult.value.toolbarTips) == null ? void 0 : _a3.bold,
              "onClick": () => {
                emitHandler("bold");
              }
            }, [createVNode(Icon, {
              "name": "bold"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_b2 = ult.value.toolbarTips) == null ? void 0 : _b2.bold])]);
          }
          case "underline": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_c = ult.value.toolbarTips) == null ? void 0 : _c.underline,
              "onClick": () => {
                emitHandler("underline");
              }
            }, [createVNode(Icon, {
              "name": "underline"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_d = ult.value.toolbarTips) == null ? void 0 : _d.underline])]);
          }
          case "italic": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_e = ult.value.toolbarTips) == null ? void 0 : _e.italic,
              "onClick": () => {
                emitHandler("italic");
              }
            }, [createVNode(Icon, {
              "name": "italic"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_f = ult.value.toolbarTips) == null ? void 0 : _f.italic])]);
          }
          case "strikeThrough": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_g = ult.value.toolbarTips) == null ? void 0 : _g.strikeThrough,
              "onClick": () => {
                emitHandler("strikeThrough");
              }
            }, [createVNode(Icon, {
              "name": "strike-through"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_h = ult.value.toolbarTips) == null ? void 0 : _h.strikeThrough])]);
          }
          case "title": {
            return createVNode(Dropdown, {
              "relative": `#${wrapperId}`,
              "visible": visible.title,
              "onChange": (v) => {
                visible.title = v;
              },
              "overlay": createVNode("ul", {
                "class": `${prefix}-menu`,
                "onClick": () => {
                  visible.title = false;
                },
                "role": "menu"
              }, [createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-title`,
                "onClick": () => {
                  emitHandler("h1");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_i = ult.value.titleItem) == null ? void 0 : _i.h1]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-title`,
                "onClick": () => {
                  emitHandler("h2");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_j = ult.value.titleItem) == null ? void 0 : _j.h2]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-title`,
                "onClick": () => {
                  emitHandler("h3");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_k = ult.value.titleItem) == null ? void 0 : _k.h3]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-title`,
                "onClick": () => {
                  emitHandler("h4");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_l = ult.value.titleItem) == null ? void 0 : _l.h4]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-title`,
                "onClick": () => {
                  emitHandler("h5");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_m = ult.value.titleItem) == null ? void 0 : _m.h5]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-title`,
                "onClick": () => {
                  emitHandler("h6");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_n = ult.value.titleItem) == null ? void 0 : _n.h6])])
            }, {
              default: () => {
                var _a22, _b22;
                return [createVNode("div", {
                  "class": `${prefix}-toolbar-item`,
                  "title": (_a22 = ult.value.toolbarTips) == null ? void 0 : _a22.title
                }, [createVNode(Icon, {
                  "name": "title"
                }, null), props22.showToolbarName && createVNode("div", {
                  "class": `${prefix}-toolbar-item-name`
                }, [(_b22 = ult.value.toolbarTips) == null ? void 0 : _b22.title])])];
              }
            });
          }
          case "sub": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_o = ult.value.toolbarTips) == null ? void 0 : _o.sub,
              "onClick": () => {
                emitHandler("sub");
              }
            }, [createVNode(Icon, {
              "name": "sub"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_p = ult.value.toolbarTips) == null ? void 0 : _p.sub])]);
          }
          case "sup": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_q = ult.value.toolbarTips) == null ? void 0 : _q.sup,
              "onClick": () => {
                emitHandler("sup");
              }
            }, [createVNode(Icon, {
              "name": "sup"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_r = ult.value.toolbarTips) == null ? void 0 : _r.sup])]);
          }
          case "quote": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_s = ult.value.toolbarTips) == null ? void 0 : _s.quote,
              "onClick": () => {
                emitHandler("quote");
              }
            }, [createVNode(Icon, {
              "name": "quote"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_t = ult.value.toolbarTips) == null ? void 0 : _t.quote])]);
          }
          case "unorderedList": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_u = ult.value.toolbarTips) == null ? void 0 : _u.unorderedList,
              "onClick": () => {
                emitHandler("unorderedList");
              }
            }, [createVNode(Icon, {
              "name": "unordered-list"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_v = ult.value.toolbarTips) == null ? void 0 : _v.unorderedList])]);
          }
          case "orderedList": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_w = ult.value.toolbarTips) == null ? void 0 : _w.orderedList,
              "onClick": () => {
                emitHandler("orderedList");
              }
            }, [createVNode(Icon, {
              "name": "ordered-list"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_x = ult.value.toolbarTips) == null ? void 0 : _x.orderedList])]);
          }
          case "task": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_y = ult.value.toolbarTips) == null ? void 0 : _y.task,
              "onClick": () => {
                emitHandler("task");
              }
            }, [createVNode(Icon, {
              "name": "task"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_z = ult.value.toolbarTips) == null ? void 0 : _z.task])]);
          }
          case "codeRow": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_A = ult.value.toolbarTips) == null ? void 0 : _A.codeRow,
              "onClick": () => {
                emitHandler("codeRow");
              }
            }, [createVNode(Icon, {
              "name": "code-row"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_B = ult.value.toolbarTips) == null ? void 0 : _B.codeRow])]);
          }
          case "code": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_C = ult.value.toolbarTips) == null ? void 0 : _C.code,
              "onClick": () => {
                emitHandler("code");
              }
            }, [createVNode(Icon, {
              "name": "code"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_D = ult.value.toolbarTips) == null ? void 0 : _D.code])]);
          }
          case "link": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_E = ult.value.toolbarTips) == null ? void 0 : _E.link,
              "onClick": () => {
                modalData.type = "link";
                modalData.linkVisible = true;
              }
            }, [createVNode(Icon, {
              "name": "link"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_F = ult.value.toolbarTips) == null ? void 0 : _F.link])]);
          }
          case "image": {
            return props22.noUploadImg ? createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_G = ult.value.toolbarTips) == null ? void 0 : _G.image,
              "onClick": () => {
                modalData.type = "image";
                modalData.linkVisible = true;
              }
            }, [createVNode(Icon, {
              "name": "image"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_H = ult.value.toolbarTips) == null ? void 0 : _H.image])]) : createVNode(Dropdown, {
              "relative": `#${wrapperId}`,
              "visible": visible.image,
              "onChange": (v) => {
                visible.image = v;
              },
              "overlay": createVNode("ul", {
                "class": `${prefix}-menu`,
                "onClick": () => {
                  visible.title = false;
                },
                "role": "menu"
              }, [createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-image`,
                "onClick": () => {
                  modalData.type = "image";
                  modalData.linkVisible = true;
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_I = ult.value.imgTitleItem) == null ? void 0 : _I.link]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-image`,
                "onClick": () => {
                  uploadRef.value.click();
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_J = ult.value.imgTitleItem) == null ? void 0 : _J.upload]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-image`,
                "onClick": () => {
                  modalData.clipVisible = true;
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_K = ult.value.imgTitleItem) == null ? void 0 : _K.clip2upload])])
            }, {
              default: () => {
                var _a22, _b22;
                return [createVNode("div", {
                  "class": `${prefix}-toolbar-item`,
                  "title": (_a22 = ult.value.toolbarTips) == null ? void 0 : _a22.image
                }, [createVNode(Icon, {
                  "name": "image"
                }, null), props22.showToolbarName && createVNode("div", {
                  "class": `${prefix}-toolbar-item-name`
                }, [(_b22 = ult.value.toolbarTips) == null ? void 0 : _b22.image])])];
              }
            });
          }
          case "table": {
            return createVNode(Dropdown, {
              "relative": `#${wrapperId}`,
              "visible": visible.table,
              "onChange": (v) => {
                visible.table = v;
              },
              "key": "bar-table",
              "overlay": createVNode(TableShape, {
                "tableShape": props22.tableShape,
                "onSelected": (selectedShape) => {
                  emitHandler("table", {
                    selectedShape
                  });
                }
              }, null)
            }, {
              default: () => {
                var _a22, _b22;
                return [createVNode("div", {
                  "class": `${prefix}-toolbar-item`,
                  "title": (_a22 = ult.value.toolbarTips) == null ? void 0 : _a22.table
                }, [createVNode(Icon, {
                  "name": "table"
                }, null), props22.showToolbarName && createVNode("div", {
                  "class": `${prefix}-toolbar-item-name`
                }, [(_b22 = ult.value.toolbarTips) == null ? void 0 : _b22.table])])];
              }
            });
          }
          case "revoke": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_L = ult.value.toolbarTips) == null ? void 0 : _L.revoke,
              "onClick": () => {
                bus.emit(editorId, CTRL_Z);
              }
            }, [createVNode(Icon, {
              "name": "revoke"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_M = ult.value.toolbarTips) == null ? void 0 : _M.revoke])]);
          }
          case "next": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_N = ult.value.toolbarTips) == null ? void 0 : _N.next,
              "onClick": () => {
                bus.emit(editorId, CTRL_SHIFT_Z);
              }
            }, [createVNode(Icon, {
              "name": "next"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_O = ult.value.toolbarTips) == null ? void 0 : _O.next])]);
          }
          case "save": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_P = ult.value.toolbarTips) == null ? void 0 : _P.save,
              "onClick": () => {
                bus.emit(editorId, ON_SAVE);
              }
            }, [createVNode(Icon, {
              "name": "baocun"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_Q = ult.value.toolbarTips) == null ? void 0 : _Q.save])]);
          }
          case "prettier": {
            return !props22.noPrettier ? createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_R = ult.value.toolbarTips) == null ? void 0 : _R.prettier,
              "onClick": () => {
                emitHandler("prettier");
              }
            }, [createVNode(Icon, {
              "name": "prettier"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_S = ult.value.toolbarTips) == null ? void 0 : _S.prettier])]) : "";
          }
          case "pageFullscreen": {
            return !props22.setting.fullscreen && createVNode("div", {
              "class": [`${prefix}-toolbar-item`, props22.setting.pageFullscreen && `${prefix}-toolbar-active`],
              "title": (_T = ult.value.toolbarTips) == null ? void 0 : _T.pageFullscreen,
              "onClick": () => {
                props22.updateSetting("pageFullscreen");
              }
            }, [createVNode(Icon, {
              "name": props22.setting.pageFullscreen ? "suoxiao" : "fangda"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_U = ult.value.toolbarTips) == null ? void 0 : _U.pageFullscreen])]);
          }
          case "fullscreen": {
            return createVNode("div", {
              "class": [`${prefix}-toolbar-item`, props22.setting.fullscreen && `${prefix}-toolbar-active`],
              "title": (_V = ult.value.toolbarTips) == null ? void 0 : _V.fullscreen,
              "onClick": () => {
                fullscreenHandler();
              }
            }, [createVNode(Icon, {
              "name": props22.setting.fullscreen ? "fullscreen-exit" : "fullscreen"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_W = ult.value.toolbarTips) == null ? void 0 : _W.fullscreen])]);
          }
          case "preview": {
            return createVNode("div", {
              "class": [`${prefix}-toolbar-item`, props22.setting.preview && `${prefix}-toolbar-active`],
              "title": (_X = ult.value.toolbarTips) == null ? void 0 : _X.preview,
              "onClick": () => {
                props22.updateSetting("preview");
              }
            }, [createVNode(Icon, {
              "name": "preview"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_Y = ult.value.toolbarTips) == null ? void 0 : _Y.preview])]);
          }
          case "previewOnly": {
            return createVNode("div", {
              "class": [`${prefix}-toolbar-item`, props22.setting.previewOnly && `${prefix}-toolbar-active`],
              "title": (_Z = ult.value.toolbarTips) == null ? void 0 : _Z.previewOnly,
              "onClick": () => {
                props22.updateSetting("previewOnly");
              }
            }, [createVNode(Icon, {
              "name": "preview-only"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(__ = ult.value.toolbarTips) == null ? void 0 : __.previewOnly])]);
          }
          case "htmlPreview": {
            return createVNode("div", {
              "class": [`${prefix}-toolbar-item`, props22.setting.htmlPreview && `${prefix}-toolbar-active`],
              "title": (_$ = ult.value.toolbarTips) == null ? void 0 : _$.htmlPreview,
              "onClick": () => {
                props22.updateSetting("htmlPreview");
              }
            }, [createVNode(Icon, {
              "name": "coding"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_aa = ult.value.toolbarTips) == null ? void 0 : _aa.htmlPreview])]);
          }
          case "catalog": {
            return createVNode("div", {
              "class": [`${prefix}-toolbar-item`, props22.catalogVisible && `${prefix}-toolbar-active`],
              "title": (_ba = ult.value.toolbarTips) == null ? void 0 : _ba.catalog,
              "onClick": () => {
                bus.emit(editorId, CHANGE_CATALOG_VISIBLE);
              },
              "key": "bar-catalog"
            }, [createVNode(Icon, {
              "name": "catalog"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_ca = ult.value.toolbarTips) == null ? void 0 : _ca.catalog])]);
          }
          case "github": {
            return createVNode("div", {
              "class": `${prefix}-toolbar-item`,
              "title": (_da = ult.value.toolbarTips) == null ? void 0 : _da.github,
              "onClick": () => C("https://github.com/imzbf/md-editor-v3")
            }, [createVNode(Icon, {
              "name": "github"
            }, null), props22.showToolbarName && createVNode("div", {
              "class": `${prefix}-toolbar-item-name`
            }, [(_ea = ult.value.toolbarTips) == null ? void 0 : _ea.github])]);
          }
          case "mermaid": {
            return createVNode(Dropdown, {
              "relative": `#${wrapperId}`,
              "visible": visible.mermaid,
              "onChange": (v) => {
                visible.mermaid = v;
              },
              "overlay": createVNode("ul", {
                "class": `${prefix}-menu`,
                "onClick": () => {
                  visible.mermaid = false;
                },
                "role": "menu"
              }, [createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                "onClick": () => {
                  emitHandler("flow");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_fa = ult.value.mermaid) == null ? void 0 : _fa.flow]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                "onClick": () => {
                  emitHandler("sequence");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_ga = ult.value.mermaid) == null ? void 0 : _ga.sequence]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                "onClick": () => {
                  emitHandler("gantt");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_ha = ult.value.mermaid) == null ? void 0 : _ha.gantt]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                "onClick": () => {
                  emitHandler("class");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_ia = ult.value.mermaid) == null ? void 0 : _ia.class]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                "onClick": () => {
                  emitHandler("state");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_ja = ult.value.mermaid) == null ? void 0 : _ja.state]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                "onClick": () => {
                  emitHandler("pie");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_ka = ult.value.mermaid) == null ? void 0 : _ka.pie]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                "onClick": () => {
                  emitHandler("relationship");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_la = ult.value.mermaid) == null ? void 0 : _la.relationship]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-mermaid`,
                "onClick": () => {
                  emitHandler("journey");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_ma = ult.value.mermaid) == null ? void 0 : _ma.journey])]),
              "key": "bar-mermaid"
            }, {
              default: () => {
                var _a22, _b22;
                return [createVNode("div", {
                  "class": `${prefix}-toolbar-item`,
                  "title": (_a22 = ult.value.toolbarTips) == null ? void 0 : _a22.mermaid
                }, [createVNode(Icon, {
                  "name": "mermaid"
                }, null), props22.showToolbarName && createVNode("div", {
                  "class": `${prefix}-toolbar-item-name`
                }, [(_b22 = ult.value.toolbarTips) == null ? void 0 : _b22.mermaid])])];
              }
            });
          }
          case "katex": {
            return createVNode(Dropdown, {
              "relative": `#${wrapperId}`,
              "visible": visible.katex,
              "onChange": (v) => {
                visible.katex = v;
              },
              "overlay": createVNode("ul", {
                "class": `${prefix}-menu`,
                "onClick": () => {
                  visible.katex = false;
                },
                "role": "menu"
              }, [createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-katex`,
                "onClick": () => {
                  emitHandler("katexInline");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_na = ult.value.katex) == null ? void 0 : _na.inline]), createVNode("li", {
                "class": `${prefix}-menu-item ${prefix}-menu-item-katex`,
                "onClick": () => {
                  emitHandler("katexBlock");
                },
                "role": "menuitem",
                "tabindex": "0"
              }, [(_oa = ult.value.katex) == null ? void 0 : _oa.block])]),
              "key": "bar-katex"
            }, {
              default: () => {
                var _a22, _b22;
                return [createVNode("div", {
                  "class": `${prefix}-toolbar-item`,
                  "title": (_a22 = ult.value.toolbarTips) == null ? void 0 : _a22.katex
                }, [createVNode(Icon, {
                  "name": "formula"
                }, null), props22.showToolbarName && createVNode("div", {
                  "class": `${prefix}-toolbar-item-name`
                }, [(_b22 = ult.value.toolbarTips) == null ? void 0 : _b22.katex])])];
              }
            });
          }
        }
      } else if (props22.defToolbars instanceof Array) {
        const defItem = props22.defToolbars[barItem];
        if (defItem) {
          const defItemCloned = cloneVNode(defItem, {
            theme: ((_pa = defItem.props) == null ? void 0 : _pa.theme) || theme.value,
            previewTheme: ((_qa = defItem.props) == null ? void 0 : _qa.theme) || previewTheme.value,
            language: ((_ra = defItem.props) == null ? void 0 : _ra.theme) || language.value,
            codeTheme: ((_sa = defItem.props) == null ? void 0 : _sa.codeTheme) || props22.codeTheme,
            insert(generate) {
              bus.emit(editorId, REPLACE, "universal", {
                generate
              });
            }
          });
          return defItemCloned;
        }
        return "";
      } else if (props22.defToolbars && props22.defToolbars.children instanceof Array) {
        const defItem = props22.defToolbars.children[barItem];
        if (defItem) {
          const defItemCloned = cloneVNode(defItem, {
            theme: ((_ta = defItem.props) == null ? void 0 : _ta.theme) || theme.value,
            previewTheme: ((_ua = defItem.props) == null ? void 0 : _ua.theme) || previewTheme.value,
            language: ((_va = defItem.props) == null ? void 0 : _va.theme) || language.value,
            codeTheme: ((_wa = defItem.props) == null ? void 0 : _wa.codeTheme) || props22.codeTheme,
            insert(generate) {
              bus.emit(editorId, REPLACE, "universal", {
                generate
              });
            }
          });
          return defItemCloned;
        }
        return "";
      } else {
        return "";
      }
    };
    watch(() => props22.toolbars, () => {
      nextTick(() => {
        if (wrapperRef.value) {
          I(wrapperRef.value);
        }
      });
    }, {
      immediate: true
    });
    return () => {
      var _a3;
      const LeftBar = splitedbar.value[0].map((barItem) => barRender(barItem));
      const RightBar = splitedbar.value[1].map((barItem) => barRender(barItem));
      return createVNode(Fragment, null, [props22.toolbars.length > 0 && createVNode("div", {
        "class": `${prefix}-toolbar-wrapper`,
        "ref": wrapperRef,
        "id": wrapperId
      }, [createVNode("div", {
        "class": [`${prefix}-toolbar`, props22.showToolbarName && `${prefix}-stn`]
      }, [createVNode("div", {
        "class": `${prefix}-toolbar-left`,
        "ref": toolbarLeftRef
      }, [LeftBar]), createVNode("div", {
        "class": `${prefix}-toolbar-right`
      }, [RightBar])])]), createVNode("label", {
        "for": `${wrapperId}_label`,
        "style": {
          display: "none"
        },
        "aria-label": (_a3 = ult.value.imgTitleItem) == null ? void 0 : _a3.upload
      }, null), createVNode("input", {
        "id": `${wrapperId}_label`,
        "ref": uploadRef,
        "accept": "image/*",
        "type": "file",
        "multiple": true,
        "style": {
          display: "none"
        }
      }, null), createVNode(Modals, {
        "linkVisible": modalData.linkVisible,
        "clipVisible": modalData.clipVisible,
        "type": modalData.type,
        "onCancel": () => {
          modalData.linkVisible = false;
          modalData.clipVisible = false;
        },
        "onOk": (data) => {
          if (data) {
            emitHandler(modalData.type, {
              desc: data.desc,
              url: data.url,
              transform: modalData.type === "image"
            });
          }
          modalData.linkVisible = false;
          modalData.clipVisible = false;
        }
      }, null)]);
    };
  }
});
var useAutoScroll = (props22, html, codeMirrorUt) => {
  const editorId = inject("editorId");
  let clearScrollAuto = () => {
  };
  let initScrollAuto = () => {
  };
  const rebindEvent = () => {
    var _a3;
    clearScrollAuto();
    const rootNode = (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.view.contentDOM.getRootNode();
    const cmScroller = rootNode.querySelector(
      `#${editorId} .cm-scroller`
    );
    const previewEle = rootNode.querySelector(
      `[id="${editorId}-preview-wrapper"]`
    );
    const htmlEle = rootNode.querySelector(
      `[id="${editorId}-html-wrapper"]`
    );
    if (previewEle || htmlEle) {
      const scrollHandler = previewEle ? scrollAuto : scrollAutoWithScale;
      const cEle = previewEle || htmlEle;
      [initScrollAuto, clearScrollAuto] = scrollHandler(
        cmScroller,
        cEle,
        codeMirrorUt.value
      );
      if (props22.scrollAuto) {
        initScrollAuto();
      }
    }
  };
  watch(
    [
      html,
      toRef(props22.setting, "preview"),
      toRef(props22.setting, "htmlPreview"),
      toRef(props22.setting, "fullscreen"),
      toRef(props22.setting, "pageFullscreen")
    ],
    () => {
      nextTick(rebindEvent);
    }
  );
  watch(
    () => props22.scrollAuto,
    (sa) => {
      if (sa) {
        initScrollAuto();
      } else {
        clearScrollAuto();
      }
    }
  );
  watch(
    () => props22.setting.previewOnly,
    (po) => {
      if (po) {
        clearScrollAuto();
      } else {
        initScrollAuto();
      }
    }
  );
  onMounted(rebindEvent);
};
var directive2flag = async (direct, codeMirrorUt, params) => {
  var _a3;
  let targetValue = "";
  let deviationStart = 0;
  let deviationEnd = 0;
  let select = true;
  let replaceAll2 = false;
  const selectedText = codeMirrorUt.getSelectedText();
  const mermaidTemplate = configOption.editorConfig.mermaidTemplate;
  if (/^h[1-6]{1}$/.test(direct)) {
    const pix = direct.replace(/^h(\d)/, (_2, num) => {
      return new Array(Number(num)).fill("#", 0, num).join("");
    });
    targetValue = `${pix} ${selectedText}`;
    deviationStart = pix.length + 1;
  } else if (direct === "prettier") {
    const prettier = window.prettier || configOption.editorExtensions.prettier.prettierInstance;
    const prettierPlugins = [
      ((_a3 = window.prettierPlugins) == null ? void 0 : _a3.markdown) || configOption.editorExtensions.prettier.parserMarkdownInstance
    ];
    if (!prettier || prettierPlugins[0] === void 0) {
      bus.emit(params.editorId, ERROR_CATCHER, {
        name: "prettier",
        message: "prettier is undefined"
      });
      targetValue = codeMirrorUt.getValue();
    } else {
      targetValue = await prettier.format(codeMirrorUt.getValue(), {
        parser: "markdown",
        plugins: prettierPlugins
      });
    }
    select = false;
    replaceAll2 = true;
  } else {
    switch (direct) {
      case "bold": {
        targetValue = `**${selectedText}**`;
        deviationStart = 2;
        deviationEnd = -2;
        break;
      }
      case "underline": {
        targetValue = `<u>${selectedText}</u>`;
        deviationStart = 3;
        deviationEnd = -4;
        break;
      }
      case "italic": {
        targetValue = `*${selectedText}*`;
        deviationStart = 1;
        deviationEnd = -1;
        break;
      }
      case "strikeThrough": {
        targetValue = `~~${selectedText}~~`;
        deviationStart = 2;
        deviationEnd = -2;
        break;
      }
      case "sub": {
        targetValue = `~${selectedText}~`;
        deviationStart = 1;
        deviationEnd = -1;
        break;
      }
      case "sup": {
        targetValue = `^${selectedText}^`;
        deviationStart = 1;
        deviationEnd = -1;
        break;
      }
      case "codeRow": {
        targetValue = "`" + selectedText + "`";
        deviationStart = 1;
        deviationEnd = -1;
        break;
      }
      case "quote": {
        targetValue = `> ${selectedText}`;
        deviationStart = 2;
        break;
      }
      case "orderedList": {
        targetValue = `1. ${selectedText}`;
        deviationStart = 3;
        break;
      }
      case "unorderedList": {
        targetValue = `- ${selectedText}`;
        deviationStart = 2;
        break;
      }
      case "task": {
        targetValue = `- [ ] ${selectedText}`;
        deviationStart = 6;
        break;
      }
      case "code": {
        const text = params.text || selectedText || "";
        const mode = params.mode || "language";
        targetValue = `\`\`\`${mode}
${text}
\`\`\`
`;
        deviationStart = 3;
        deviationEnd = 3 + mode.length - targetValue.length;
        break;
      }
      case "table": {
        targetValue = "|";
        const { selectedShape = { x: 1, y: 1 } } = params;
        const { x: x2, y: y2 } = selectedShape;
        for (let i2 = 0; i2 <= y2; i2++) {
          targetValue += " col |";
        }
        targetValue += "\n|";
        for (let i2 = 0; i2 <= y2; i2++) {
          targetValue += " - |";
        }
        for (let row = 0; row <= x2; row++) {
          targetValue += "\n|";
          for (let col = 0; col <= y2; col++) {
            targetValue += " content |";
          }
        }
        deviationStart = 2;
        deviationEnd = 5 - targetValue.length;
        break;
      }
      case "link": {
        const { desc, url } = params;
        targetValue = `[${desc}](${url})`;
        select = false;
        break;
      }
      case "image": {
        const { desc, url, urls } = params;
        if (urls instanceof Array) {
          targetValue = urls.reduce((pVal, _url) => {
            const {
              url: url2 = "",
              alt = "",
              title = ""
            } = typeof _url === "object" ? _url : { url: _url };
            return pVal + `![${alt}](${url2}${title ? " '" + title + "'" : ""})
`;
          }, "");
        } else {
          targetValue = `![${desc}](${url})
`;
        }
        select = false;
        break;
      }
      case "flow": {
        targetValue = `\`\`\`mermaid
${(mermaidTemplate == null ? void 0 : mermaidTemplate.flow) || "flowchart TD \n  Start --> Stop"}
\`\`\`
`;
        deviationStart = 11;
        deviationEnd = -5;
        break;
      }
      case "sequence": {
        targetValue = `\`\`\`mermaid
${(mermaidTemplate == null ? void 0 : mermaidTemplate.sequence) || "sequenceDiagram\n  A->>B: hello!\n  B-->>A: hi!\n  A-)B: bye!"}
\`\`\`
`;
        deviationStart = 11;
        deviationEnd = -5;
        break;
      }
      case "gantt": {
        targetValue = `\`\`\`mermaid
${(mermaidTemplate == null ? void 0 : mermaidTemplate.gantt) || "gantt\ntitle A Gantt Diagram\ndateFormat  YYYY-MM-DD\nsection Section\nA task  :a1, 2014-01-01, 30d\nAnother task  :after a1, 20d"}
\`\`\`
`;
        deviationStart = 11;
        deviationEnd = -5;
        break;
      }
      case "class": {
        targetValue = `\`\`\`mermaid
${(mermaidTemplate == null ? void 0 : mermaidTemplate.class) || "classDiagram\n  class Animal\n  Vehicle <|-- Car"}
\`\`\`
`;
        deviationStart = 11;
        deviationEnd = -5;
        break;
      }
      case "state": {
        targetValue = `\`\`\`mermaid
${(mermaidTemplate == null ? void 0 : mermaidTemplate.state) || "stateDiagram-v2\n  s1 --> s2"}
\`\`\`
`;
        deviationStart = 11;
        deviationEnd = -5;
        break;
      }
      case "pie": {
        targetValue = `\`\`\`mermaid
${(mermaidTemplate == null ? void 0 : mermaidTemplate.pie) || 'pie title Pets adopted by volunteers\n  "Dogs" : 386\n  "Cats" : 85\n  "Rats" : 15'}
\`\`\`
`;
        deviationStart = 11;
        deviationEnd = -5;
        break;
      }
      case "relationship": {
        targetValue = `\`\`\`mermaid
${(mermaidTemplate == null ? void 0 : mermaidTemplate.relationship) || "erDiagram\n  CAR ||--o{ NAMED-DRIVER : allows\n  PERSON ||--o{ NAMED-DRIVER : is"}
\`\`\`
`;
        deviationStart = 11;
        deviationEnd = -5;
        break;
      }
      case "journey": {
        targetValue = `\`\`\`mermaid
${(mermaidTemplate == null ? void 0 : mermaidTemplate.journey) || "journey\n  title My working day\n  section Go to work\n    Make tea: 5: Me\n    Go upstairs: 3: Me\n    Do work: 1: Me, Cat\n  section Go home\n    Go downstairs: 5: Me\n    Sit down: 5: Me"}
\`\`\`
`;
        deviationStart = 11;
        deviationEnd = -5;
        break;
      }
      case "katexInline": {
        targetValue = "$$";
        deviationStart = 1;
        deviationEnd = -1;
        break;
      }
      case "katexBlock": {
        targetValue = "$$\n\n$$\n";
        deviationStart = 3;
        deviationEnd = -4;
        break;
      }
      case "universal": {
        const { generate } = params;
        const insertOptions = generate(selectedText);
        targetValue = insertOptions.targetValue;
        select = insertOptions.select ?? true;
        deviationStart = insertOptions.deviationStart || 0;
        deviationEnd = insertOptions.deviationEnd || 0;
      }
    }
  }
  return {
    text: targetValue,
    options: {
      // 是否选中
      select,
      // 选中时，开始位置的偏移量
      deviationStart,
      // 结束的偏移量
      deviationEnd,
      // 是否整个替换
      replaceAll: replaceAll2
    }
  };
};
var chalky$1 = "#e5c07b";
var coral$1 = "var(--md-color)";
var cyan$1 = "#56b6c2";
var invalid$1 = "#ffffff";
var ivory$1 = "var(--md-color)";
var stone$1 = "#e5c07b";
var malibu$1 = "#e5c07b";
var sage$1 = "var(--md-color)";
var whiskey$1 = "#d19a66";
var violet$1 = "#c678dd";
var darkBackground$1 = "#21252b";
var highlightBackground$1 = "#2c313a";
var background$1 = "var(--md-bk-color)";
var tooltipBackground$1 = "var(--md-bk-color)";
var selection$1 = "#ceedfa33";
var cursor$1 = "#528bff";
var oneDarkTheme = EditorView.theme(
  {
    "&": {
      color: ivory$1,
      backgroundColor: background$1
    },
    ".cm-content": {
      caretColor: cursor$1
    },
    ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor$1 },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection$1 },
    ".cm-panels": { backgroundColor: darkBackground$1, color: ivory$1 },
    ".cm-panels.cm-panels-top": { borderBottom: "1px solid var(--md-border-color)" },
    ".cm-panels.cm-panels-bottom": { borderTop: "1px solid var(--md-border-color)" },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": { backgroundColor: "#ceedfa33" },
    ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bad0f847"
    },
    ".cm-gutters": {
      backgroundColor: background$1,
      color: ivory$1,
      borderRight: "1px solid",
      borderColor: "var(--md-border-color)"
    },
    ".cm-activeLineGutter": {
      backgroundColor: highlightBackground$1
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "1px solid var(--md-border-color)",
      backgroundColor: tooltipBackground$1
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: tooltipBackground$1,
      borderBottomColor: tooltipBackground$1
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        color: ivory$1
      }
    }
  },
  { dark: true }
);
var oneDarkHighlightStyle = HighlightStyle.define([
  { tag: tags.keyword, color: violet$1 },
  { tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName], color: coral$1 },
  { tag: [tags.function(tags.variableName), tags.labelName], color: malibu$1 },
  { tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)], color: whiskey$1 },
  { tag: [tags.definition(tags.name), tags.separator], color: ivory$1 },
  {
    tag: [
      tags.typeName,
      tags.className,
      tags.number,
      tags.changed,
      tags.annotation,
      tags.modifier,
      tags.self,
      tags.namespace
    ],
    color: chalky$1
  },
  {
    tag: [
      tags.operator,
      tags.operatorKeyword,
      tags.url,
      tags.escape,
      tags.regexp,
      tags.link,
      tags.special(tags.string)
    ],
    color: cyan$1
  },
  { tag: [tags.meta, tags.comment], color: stone$1 },
  { tag: tags.strong, fontWeight: "bold" },
  { tag: tags.emphasis, fontStyle: "italic" },
  { tag: tags.strikethrough, textDecoration: "line-through" },
  { tag: tags.link, color: stone$1, textDecoration: "underline" },
  { tag: tags.heading, fontWeight: "bold", color: coral$1 },
  { tag: [tags.atom, tags.bool, tags.special(tags.variableName)], color: whiskey$1 },
  { tag: [tags.processingInstruction, tags.string, tags.inserted], color: sage$1 },
  { tag: tags.invalid, color: invalid$1 }
]);
var oneDark = [
  oneDarkTheme,
  syntaxHighlighting(oneDarkHighlightStyle)
];
var chalky = "#e5c07b";
var coral = "#3f4a54";
var cyan = "#56b6c2";
var invalid = "#fff";
var ivory = "#3f4a54";
var stone = "#2d8cf0";
var malibu = "#2d8cf0";
var sage = "#3f4a54";
var whiskey = "#d19a66";
var violet = "#c678dd";
var darkBackground = "#f6f6f6";
var highlightBackground = "#ceedfa33";
var background = "var(--md-bk-color)";
var tooltipBackground = "var(--md-bk-color)";
var selection = "#bad5fa";
var cursor = "#3f4a54";
var oneLightTheme = EditorView.theme(
  {
    "&": {
      color: ivory,
      backgroundColor: background
    },
    ".cm-content": {
      caretColor: cursor
    },
    ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
    ".cm-panels": { backgroundColor: darkBackground, color: ivory },
    ".cm-panels.cm-panels-top": { borderBottom: "1px solid var(--md-border-color)" },
    ".cm-panels.cm-panels-bottom": { borderTop: "1px solid var(--md-border-color)" },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": { backgroundColor: "#ceedfa33" },
    ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bad0f847"
    },
    ".cm-gutters": {
      backgroundColor: background,
      color: ivory,
      borderRight: "1px solid",
      borderColor: "var(--md-border-color)"
    },
    ".cm-activeLineGutter": {
      backgroundColor: highlightBackground
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "1px solid var(--md-border-color)",
      backgroundColor: tooltipBackground
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: tooltipBackground,
      borderBottomColor: tooltipBackground
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        color: ivory
      }
    }
  }
  // { dark: true }
);
var oneLightHighlightStyle = HighlightStyle.define([
  { tag: tags.keyword, color: violet },
  { tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName], color: coral },
  { tag: [tags.function(tags.variableName), tags.labelName], color: malibu },
  { tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)], color: whiskey },
  { tag: [tags.definition(tags.name), tags.separator], color: ivory },
  {
    tag: [
      tags.typeName,
      tags.className,
      tags.number,
      tags.changed,
      tags.annotation,
      tags.modifier,
      tags.self,
      tags.namespace
    ],
    color: chalky
  },
  {
    tag: [
      tags.operator,
      tags.operatorKeyword,
      tags.url,
      tags.escape,
      tags.regexp,
      tags.link,
      tags.special(tags.string)
    ],
    color: cyan
  },
  { tag: [tags.meta, tags.comment], color: stone },
  { tag: tags.strong, fontWeight: "bold" },
  { tag: tags.emphasis, fontStyle: "italic" },
  { tag: tags.strikethrough, textDecoration: "line-through" },
  { tag: tags.link, color: stone, textDecoration: "underline" },
  { tag: tags.heading, fontWeight: "bold", color: coral },
  { tag: [tags.atom, tags.bool, tags.special(tags.variableName)], color: whiskey },
  { tag: [tags.processingInstruction, tags.string, tags.inserted], color: sage },
  { tag: tags.invalid, color: invalid }
]);
var oneLight = [
  oneLightTheme,
  syntaxHighlighting(oneLightHighlightStyle)
];
var getPairApply = (flag, type, title, suffix, selectType) => {
  return (view, _completion, from, to) => {
    const label = `${flag}${type}`.slice(to - from);
    view.dispatch(view.state.replaceSelection(`${label}${title}${suffix}`));
    const newTo = from + _completion.label.length + (selectType === "title" ? title.length : 0);
    view.dispatch({
      selection: EditorSelection.create(
        [
          EditorSelection.range(
            from + _completion.label.length + (selectType === "title" ? 1 : -type.length),
            newTo
          ),
          EditorSelection.cursor(newTo)
        ],
        1
      )
    });
    view.focus();
  };
};
var getApply = (_label) => {
  return (view, _completion, from, to) => {
    const label = _label.slice(to - from);
    view.dispatch(view.state.replaceSelection(`${label} `));
  };
};
var createAutocompletion = (completions) => {
  const defaultCompletion = (context) => {
    const word = context.matchBefore(
      /^#+|^-\s*\[*\s*\]*|`+|\[|!\[*|^\|\s?\|?|\$\$?|!+\s*\w*/
    );
    if (word === null || word.from == word.to && context.explicit) {
      return null;
    }
    return {
      from: word.from,
      options: [
        // 标题
        ...["h2", "h3", "h4", "h5", "h6"].map((key, index2) => {
          const label = new Array(index2 + 2).fill("#").join("");
          return {
            label,
            type: "text",
            apply: getApply(label)
          };
        }),
        // 任务列表
        ...["unchecked", "checked"].map((key) => {
          const label = key === "checked" ? "- [x]" : "- [ ]";
          return {
            label,
            type: "text",
            apply: getApply(label)
          };
        }),
        // 代码
        ...[
          ["`", ""],
          ["```", "language"],
          ["```mermaid\n", ""]
        ].map((c) => {
          return {
            label: `${c[0]}${c[1]}`,
            type: "text",
            apply: getPairApply(c[0], c[1], "", c[0] === "`" ? "`" : "\n```", "type")
          };
        }),
        // 链接
        {
          label: "[]()",
          type: "text"
        },
        {
          label: "![]()",
          type: "text"
        },
        // 表格
        {
          label: "| |",
          type: "text",
          detail: "table",
          apply: "| col | col | col |\n| - | - | - |\n| content | content | content |\n| content | content | content |"
        },
        // 公式
        {
          label: "$",
          type: "text",
          apply: getPairApply("$", "", "", "$", "type")
        },
        {
          label: "$$",
          type: "text",
          apply: getPairApply("$$", "", "\n", "\n$$", "title")
        },
        // 那啥？
        ...[
          "note",
          "abstract",
          "info",
          "tip",
          "success",
          "question",
          "warning",
          "failure",
          "danger",
          "bug",
          "example",
          "quote",
          "hint",
          "caution",
          "error",
          "attention"
        ].map((key) => {
          const label = `!!! ${key}`;
          return {
            label,
            type: "text",
            apply: getPairApply("!!!", ` ${key}`, " Title", "\n\n!!!", "title")
          };
        })
      ]
    };
  };
  return autocompletion({
    override: completions ? [defaultCompletion, ...completions] : [defaultCompletion]
  });
};
var toggleWith = (view) => {
  const mc = new Compartment();
  const toggle = (extension) => {
    mc.get(view.state) ? view.dispatch({ effects: mc.reconfigure(extension) }) : view.dispatch({
      effects: StateEffect.appendConfig.of(mc.of(extension))
    });
    return true;
  };
  return toggle;
};
var CodeMirrorUt = class {
  constructor(view) {
    __publicField3(this, "view");
    __publicField3(this, "maxLength", Number.MAX_SAFE_INTEGER);
    __publicField3(this, "toggleTabSize");
    __publicField3(this, "togglePlaceholder");
    __publicField3(this, "setExtensions");
    __publicField3(this, "toggleDisabled");
    __publicField3(this, "toggleReadOnly");
    __publicField3(this, "toggleMaxlength");
    this.view = view;
    this.toggleTabSize = toggleWith(this.view);
    this.togglePlaceholder = toggleWith(this.view);
    this.setExtensions = toggleWith(this.view);
    this.toggleDisabled = toggleWith(this.view);
    this.toggleReadOnly = toggleWith(this.view);
    this.toggleMaxlength = toggleWith(this.view);
  }
  getValue() {
    return this.view.state.doc.toString();
  }
  /**
   * 设置内容
   *
   * @param insert 待插入内容
   * @param from 插入开始位置
   * @param to 插入结束位置
   */
  setValue(insert, from = 0, to = this.view.state.doc.length) {
    this.view.dispatch({
      changes: {
        from,
        to,
        insert
      }
    });
  }
  /**
   * 获取选中的文本
   */
  getSelectedText() {
    const { from, to } = this.view.state.selection.main;
    return this.view.state.sliceDoc(from, to);
  }
  /**
   * 使用新的内容替换选中的内容
   *
   * @param text 待替换内容
   * @param options 替换后是否选中
   */
  replaceSelectedText(text, options = {
    // 是否选中
    select: true,
    // 选中时，开始位置的偏移量
    deviationStart: 0,
    // 结束的偏移量
    deviationEnd: 0,
    // 直接替换所有文本
    replaceAll: false
  }, editorId) {
    try {
      if (options.replaceAll) {
        this.setValue(text);
        if (text.length > this.maxLength) {
          throw new Error("The input text is too long");
        }
        return;
      }
      if (this.view.state.doc.length - this.getSelectedText().length + text.length > this.maxLength) {
        throw new Error("The input text is too long");
      }
      const { from } = this.view.state.selection.main;
      this.view.dispatch(this.view.state.replaceSelection(text));
      if (options.select) {
        const to = from + text.length + options.deviationEnd;
        this.view.dispatch({
          selection: {
            anchor: from + options.deviationStart,
            head: to
          }
        });
      }
      this.view.focus();
    } catch (e2) {
      if (e2.message === "The input text is too long") {
        bus.emit(editorId, ERROR_CATCHER, {
          name: "overlength",
          message: e2.message,
          data: text
        });
      } else {
        throw e2;
      }
    }
  }
  /**
   * 设置tabSize
   *
   * @param tabSize 需要切换的大小
   */
  setTabSize(tabSize) {
    this.toggleTabSize([
      EditorState.tabSize.of(tabSize),
      indentUnit.of(" ".repeat(tabSize))
    ]);
  }
  /**
   * 设置placeholder
   *
   * @param t 目标内容
   */
  setPlaceholder(t2) {
    this.togglePlaceholder(placeholder(t2));
  }
  focus(options) {
    this.view.focus();
    if (!options) {
      return;
    }
    let anchor = 0;
    let head = 0;
    let pos = 0;
    switch (options) {
      case "start": {
        break;
      }
      case "end": {
        const length = this.getValue().length;
        anchor = head = pos = length;
        break;
      }
      default: {
        anchor = options.rangeAnchor || options.cursorPos;
        head = options.rangeHead || options.cursorPos;
        pos = options.cursorPos;
      }
    }
    this.view.dispatch({
      scrollIntoView: true,
      selection: EditorSelection.create(
        [EditorSelection.range(anchor, head), EditorSelection.cursor(pos)],
        1
      )
    });
  }
  setDisabled(d) {
    this.toggleDisabled([EditorView.editable.of(!d)]);
  }
  setReadOnly(r2) {
    this.toggleReadOnly([EditorState.readOnly.of(r2)]);
  }
  setMaxLength(ml) {
    this.maxLength = ml;
    this.toggleMaxlength([
      EditorState.changeFilter.of((tr) => {
        return tr.newDoc.length <= ml;
      })
    ]);
  }
};
var usePasteUpload = (props22, codeMirrorUt) => {
  const editorId = inject("editorId");
  const imgInsert = (tv) => {
    if (tv instanceof Promise) {
      tv.then((targetValue) => {
        bus.emit(editorId, REPLACE, "universal", {
          generate() {
            return {
              targetValue
            };
          }
        });
      }).catch((err) => {
        console.error(err);
      });
    } else {
      bus.emit(editorId, REPLACE, "universal", {
        generate() {
          return {
            targetValue: tv
          };
        }
      });
    }
  };
  const pasteHandler = (e2) => {
    var _a3, _b2, _c;
    if (!e2.clipboardData) {
      return;
    }
    if (e2.clipboardData.files.length > 0) {
      const { files } = e2.clipboardData;
      bus.emit(
        editorId,
        UPLOAD_IMAGE,
        Array.from(files).filter((file) => {
          return /image\/.*/.test(file.type);
        })
      );
      e2.preventDefault();
      return;
    }
    const targetValue = e2.clipboardData.getData("text/plain");
    const to = ((_a3 = codeMirrorUt.value) == null ? void 0 : _a3.view.state.selection.main.to) || 0;
    const from = ((_b2 = codeMirrorUt.value) == null ? void 0 : _b2.view.state.doc.lineAt(to).from) || 0;
    const lineStart = ((_c = codeMirrorUt.value) == null ? void 0 : _c.view.state.doc.sliceString(from, to)) || "";
    const templateStart = /!\[.*\]\(\s*$/.test(lineStart);
    const templateIn = /!\[.*\]\((.*)\s?.*\)/.test(targetValue);
    if (templateStart) {
      const tv = props22.transformImgUrl(targetValue);
      imgInsert(tv);
      e2.preventDefault();
      return;
    } else if (templateIn) {
      const matchArr = targetValue.match(new RegExp(`(?<=!\\[.*\\]\\()([^)\\s]+)(?=\\s?["']?.*["']?\\))`, "g"));
      if (matchArr) {
        Promise.all(
          matchArr.map((img) => {
            return props22.transformImgUrl(img);
          })
        ).then((newUrls) => {
          imgInsert(
            newUrls.reduce((prev, curr, index2) => {
              return prev.replace(matchArr[index2], curr);
            }, targetValue)
          );
        });
      } else {
        imgInsert(targetValue);
      }
      e2.preventDefault();
      return;
    }
    if (props22.autoDetectCode && e2.clipboardData.types.includes("vscode-editor-data")) {
      const vscCoodInfo = JSON.parse(e2.clipboardData.getData("vscode-editor-data"));
      bus.emit(editorId, REPLACE, "code", {
        mode: vscCoodInfo.mode,
        text: e2.clipboardData.getData("text/plain")
      });
      e2.preventDefault();
      return;
    }
    if (props22.maxlength && targetValue.length + props22.modelValue.length > props22.maxlength) {
      bus.emit(editorId, ERROR_CATCHER, {
        name: "overlength",
        message: "The input text is too long",
        data: targetValue
      });
    }
  };
  return pasteHandler;
};
var createCommands = (id, contentProps2) => {
  const CtrlB = {
    key: "Ctrl-b",
    mac: "Cmd-b",
    run: () => {
      bus.emit(id, REPLACE, "bold");
      return true;
    }
  };
  const CtrlS = {
    key: "Ctrl-s",
    mac: "Cmd-s",
    run: (view) => {
      bus.emit(id, ON_SAVE, view.state.doc.toString());
      return true;
    },
    shift: () => {
      bus.emit(id, REPLACE, "strikeThrough");
      return true;
    }
  };
  const CtrlU = {
    key: "Ctrl-u",
    mac: "Cmd-u",
    preventDefault: true,
    run: () => {
      bus.emit(id, REPLACE, "underline");
      return true;
    },
    shift: () => {
      bus.emit(id, REPLACE, "unorderedList");
      return true;
    }
  };
  const CtrlI = {
    key: "Ctrl-i",
    mac: "Cmd-i",
    preventDefault: true,
    run: () => {
      bus.emit(id, REPLACE, "italic");
      return true;
    },
    shift: () => {
      bus.emit(id, OPEN_MODALS, "image");
      return true;
    }
  };
  const Ctrl1 = {
    key: "Ctrl-1",
    mac: "Cmd-1",
    run: () => {
      bus.emit(id, REPLACE, "h1");
      return true;
    }
  };
  const Ctrl2 = {
    key: "Ctrl-2",
    mac: "Cmd-2",
    run: () => {
      bus.emit(id, REPLACE, "h2");
      return true;
    }
  };
  const Ctrl3 = {
    key: "Ctrl-3",
    mac: "Cmd-3",
    run: () => {
      bus.emit(id, REPLACE, "h3");
      return true;
    }
  };
  const Ctrl4 = {
    key: "Ctrl-4",
    mac: "Cmd-4",
    run: () => {
      bus.emit(id, REPLACE, "h4");
      return true;
    }
  };
  const Ctrl5 = {
    key: "Ctrl-5",
    mac: "Cmd-5",
    run: () => {
      bus.emit(id, REPLACE, "h5");
      return true;
    }
  };
  const Ctrl6 = {
    key: "Ctrl-6",
    mac: "Cmd-6",
    run: () => {
      bus.emit(id, REPLACE, "h6");
      return true;
    }
  };
  const CtrlArrowUp = {
    key: "Ctrl-ArrowUp",
    mac: "Cmd-ArrowUp",
    run: () => {
      bus.emit(id, REPLACE, "sup");
      return true;
    }
  };
  const CtrlArrowDown = {
    key: "Ctrl-ArrowDown",
    mac: "Cmd-ArrowDown",
    run: () => {
      bus.emit(id, REPLACE, "sub");
      return true;
    }
  };
  const CtrlO = {
    key: "Ctrl-o",
    mac: "Cmd-o",
    run: () => {
      bus.emit(id, REPLACE, "orderedList");
      return true;
    }
  };
  const CtrlC = {
    key: "Ctrl-c",
    mac: "Cmd-c",
    shift: () => {
      bus.emit(id, REPLACE, "code");
      return true;
    },
    any(_view, e2) {
      if ((e2.ctrlKey || e2.metaKey) && e2.altKey && e2.code === "KeyC") {
        bus.emit(id, REPLACE, "codeRow");
        return true;
      }
      return false;
    }
  };
  const CtrlL = {
    key: "Ctrl-l",
    mac: "Cmd-l",
    run: () => {
      bus.emit(id, OPEN_MODALS, "link");
      return true;
    }
  };
  const CtrlF = {
    key: "Ctrl-f",
    mac: "Cmd-f",
    shift: () => {
      if (!contentProps2.noPrettier) {
        bus.emit(id, REPLACE, "prettier");
        return true;
      }
      return false;
    }
  };
  const CtrlT = {
    any: (_view, e2) => {
      if ((e2.ctrlKey || e2.metaKey) && e2.altKey && e2.shiftKey && e2.code === "KeyT") {
        bus.emit(id, REPLACE, "table");
        return true;
      }
      return false;
    }
  };
  const CtrlD = {
    key: "Ctrl-d",
    mac: "Cmd-d",
    run: deleteLine,
    preventDefault: true
  };
  return [
    CtrlB,
    CtrlD,
    CtrlS,
    CtrlU,
    CtrlI,
    Ctrl1,
    Ctrl2,
    Ctrl3,
    Ctrl4,
    Ctrl5,
    Ctrl6,
    CtrlArrowUp,
    CtrlArrowDown,
    CtrlO,
    CtrlC,
    CtrlL,
    CtrlF,
    CtrlT,
    ...searchKeymap
  ];
};
EditorView.EDIT_CONTEXT = false;
var useCodeMirror = (props22) => {
  const tabWidth = inject("tabWidth");
  const editorId = inject("editorId");
  const theme = inject("theme");
  const inputWrapperRef = ref();
  const codeMirrorUt = shallowRef();
  const spelling = ref(false);
  const languageComp = new Compartment(), themeComp = new Compartment(), autocompletionComp = new Compartment(), historyComp = new Compartment(), eventComp = new Compartment();
  const mdEditorCommands = createCommands(editorId, props22);
  const getDefaultKeymaps = () => [
    ...mdEditorCommands,
    ...defaultKeymap,
    ...historyKeymap,
    indentWithTab
  ];
  const pasteHandler = usePasteUpload(props22, codeMirrorUt);
  const domEventHandlers = {
    paste: pasteHandler,
    blur: props22.onBlur,
    focus: props22.onFocus,
    drop: props22.onDrop,
    compositionstart: () => {
      spelling.value = true;
    },
    compositionend: (_e, view) => {
      spelling.value = false;
      props22.updateModelValue(view.state.doc.toString());
    },
    input: (e2) => {
      if (props22.onInput) {
        props22.onInput(e2);
      }
      const { data } = e2;
      if (props22.maxlength && props22.modelValue.length + data.length > props22.maxlength) {
        bus.emit(editorId, ERROR_CATCHER, {
          name: "overlength",
          message: "The input text is too long",
          data
        });
      }
    }
  };
  const defaultExtensions = [
    keymap.of(getDefaultKeymaps()),
    historyComp.of(history()),
    languageComp.of(markdown({ codeLanguages: languages })),
    // 横向换行
    EditorView.lineWrapping,
    EditorView.updateListener.of((update) => {
      if (update.docChanged) {
        props22.onChange(update.state.doc.toString());
        if (!spelling.value) {
          props22.updateModelValue(update.state.doc.toString());
        }
      }
    }),
    eventComp.of(EditorView.domEventHandlers(domEventHandlers)),
    // 解决多行placeholder时，光标异常的情况
    drawSelection()
  ];
  const getExtensions = () => {
    const extensions = [
      ...defaultExtensions,
      themeComp.of(theme.value === "light" ? oneLight : oneDark),
      autocompletionComp.of(createAutocompletion(props22.completions))
    ];
    return configOption.codeMirrorExtensions(
      theme.value,
      extensions,
      getDefaultKeymaps(),
      { editorId }
    );
  };
  onMounted(() => {
    const view = new EditorView({
      doc: props22.modelValue,
      parent: inputWrapperRef.value,
      extensions: [getExtensions()]
    });
    const nc = new CodeMirrorUt(view);
    codeMirrorUt.value = nc;
    setTimeout(() => {
      nc.setTabSize(tabWidth);
      nc.setDisabled(props22.disabled);
      nc.setReadOnly(props22.readonly);
      props22.placeholder && nc.setPlaceholder(props22.placeholder);
      typeof props22.maxlength === "number" && nc.setMaxLength(props22.maxlength);
      props22.autofocus && view.focus();
    }, 0);
    bus.on(editorId, {
      name: CTRL_Z,
      callback() {
        undo(view);
      }
    });
    bus.on(editorId, {
      name: CTRL_SHIFT_Z,
      callback() {
        redo(view);
      }
    });
    bus.on(editorId, {
      name: REPLACE,
      async callback(direct, params = {}) {
        var _a3, _b2;
        if (direct === "image" && params.transform) {
          const tv = props22.transformImgUrl(params.url);
          if (tv instanceof Promise) {
            tv.then(async (url) => {
              var _a22;
              const { text, options } = await directive2flag(
                direct,
                codeMirrorUt.value,
                {
                  ...params,
                  url
                }
              );
              (_a22 = codeMirrorUt.value) == null ? void 0 : _a22.replaceSelectedText(text, options, editorId);
            }).catch((err) => {
              console.error(err);
            });
          } else {
            const { text, options } = await directive2flag(direct, codeMirrorUt.value, {
              ...params,
              url: tv
            });
            (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.replaceSelectedText(text, options, editorId);
          }
        } else {
          const { text, options } = await directive2flag(
            direct,
            codeMirrorUt.value,
            params
          );
          (_b2 = codeMirrorUt.value) == null ? void 0 : _b2.replaceSelectedText(text, options, editorId);
        }
      }
    });
    bus.on(editorId, {
      name: EVENT_LISTENER,
      callback: $((handlers) => {
        var _a3;
        const nextDomEventHandlers = {
          ...domEventHandlers
        };
        const defaultEventNames = Object.keys(domEventHandlers);
        for (const eventName in handlers) {
          const en = eventName;
          if (defaultEventNames.includes(en)) {
            nextDomEventHandlers[en] = (e2, v) => {
              handlers[en](e2, v);
              if (!e2.defaultPrevented) {
                domEventHandlers[en](e2, v);
              }
            };
          } else {
            nextDomEventHandlers[en] = handlers[en];
          }
        }
        (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.view.dispatch({
          effects: eventComp.reconfigure(
            EditorView.domEventHandlers(nextDomEventHandlers)
          )
        });
      })
    });
    bus.on(editorId, {
      name: TASK_STATE_CHANGED,
      callback: (lineNumber, value) => {
        const line = view.state.doc.line(lineNumber);
        view.dispatch(
          view.state.update({
            changes: { from: line.from, to: line.to, insert: value }
          })
        );
      }
    });
  });
  watch(
    theme,
    () => {
      var _a3;
      (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.view.dispatch({
        effects: themeComp.reconfigure(theme.value === "light" ? oneLight : oneDark)
      });
    },
    {
      deep: true
    }
  );
  watch(
    () => props22.completions,
    () => {
      var _a3;
      (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.view.dispatch({
        effects: autocompletionComp.reconfigure(createAutocompletion(props22.completions))
      });
    },
    {
      deep: true
    }
  );
  watch(
    () => props22.modelValue,
    () => {
      var _a3, _b2;
      if (((_a3 = codeMirrorUt.value) == null ? void 0 : _a3.getValue()) !== props22.modelValue) {
        (_b2 = codeMirrorUt.value) == null ? void 0 : _b2.setValue(props22.modelValue);
      }
    }
  );
  watch(
    () => props22.placeholder,
    () => {
      var _a3;
      (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.setPlaceholder(props22.placeholder);
    }
  );
  watch(
    () => props22.disabled,
    () => {
      var _a3;
      (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.setDisabled(props22.disabled);
    }
  );
  watch(
    () => props22.readonly,
    () => {
      var _a3;
      (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.setDisabled(props22.readonly);
    }
  );
  watch(
    () => props22.maxlength,
    () => {
      var _a3;
      if (props22.maxlength) {
        (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.setMaxLength(props22.maxlength);
      }
    }
  );
  return {
    inputWrapperRef,
    codeMirrorUt,
    resetHistory() {
      var _a3, _b2;
      (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.view.dispatch({
        effects: historyComp.reconfigure([])
      });
      (_b2 = codeMirrorUt.value) == null ? void 0 : _b2.view.dispatch({
        effects: historyComp.reconfigure(history())
      });
    }
  };
};
var useResize = (props22, contentRef, resizeRef) => {
  const state = reactive({
    resizedWidth: props22.inputBoxWitdh
  });
  const inputWrapperStyle = reactive({
    width: props22.inputBoxWitdh
  });
  const resizeOperateStyle = reactive({
    left: props22.inputBoxWitdh,
    display: "initial"
  });
  const showPreviewWrapper = ref(props22.setting.preview || props22.setting.htmlPreview);
  const resizeMousemove = (e2) => {
    var _a3, _b2, _c;
    const maxWidth = ((_a3 = contentRef.value) == null ? void 0 : _a3.offsetWidth) || 0;
    const contentX = ((_b2 = contentRef.value) == null ? void 0 : _b2.getBoundingClientRect().x) || 0;
    let nextWidth = e2.x - contentX;
    if (nextWidth < MinInputBoxWidth) {
      nextWidth = MinInputBoxWidth;
    } else if (nextWidth > maxWidth - MinInputBoxWidth) {
      nextWidth = maxWidth - MinInputBoxWidth;
    }
    const ibw = `${nextWidth}px`;
    inputWrapperStyle.width = ibw;
    resizeOperateStyle.left = ibw;
    state.resizedWidth = ibw;
    (_c = props22.onInputBoxWitdhChange) == null ? void 0 : _c.call(props22, ibw);
  };
  const resizeMousedown = () => {
    document.addEventListener("mousemove", resizeMousemove);
  };
  const resizeMouseup = () => {
    document.removeEventListener("mousemove", resizeMousemove);
  };
  watch(
    [resizeRef],
    () => {
      var _a3, _b2;
      (_a3 = resizeRef.value) == null ? void 0 : _a3.addEventListener("mousedown", resizeMousedown);
      (_b2 = resizeRef.value) == null ? void 0 : _b2.addEventListener("mouseup", resizeMouseup);
    },
    {
      immediate: true
    }
  );
  onBeforeUnmount(() => {
    var _a3, _b2;
    (_a3 = resizeRef.value) == null ? void 0 : _a3.removeEventListener("mousedown", resizeMousedown);
    (_b2 = resizeRef.value) == null ? void 0 : _b2.removeEventListener("mouseup", resizeMouseup);
  });
  watch(
    () => props22.inputBoxWitdh,
    (nVal) => {
      if (nVal) {
        state.resizedWidth = nVal;
        inputWrapperStyle.width = nVal;
        resizeOperateStyle.left = nVal;
      }
    }
  );
  watch(
    [
      toRef(props22.setting, "htmlPreview"),
      toRef(props22.setting, "preview"),
      toRef(props22.setting, "previewOnly")
    ],
    () => {
      if (props22.setting.previewOnly) {
        inputWrapperStyle.width = "0%";
        resizeOperateStyle.display = "none";
        showPreviewWrapper.value = true;
      } else if (!props22.setting.htmlPreview && !props22.setting.preview) {
        inputWrapperStyle.width = "100%";
        resizeOperateStyle.display = "none";
        showPreviewWrapper.value = false;
      } else {
        inputWrapperStyle.width = state.resizedWidth;
        resizeOperateStyle.display = "initial";
        showPreviewWrapper.value = true;
      }
    },
    {
      immediate: true
    }
  );
  return { inputWrapperStyle, resizeOperateStyle, showPreviewWrapper };
};
var Content = defineComponent({
  name: "MDEditorContent",
  props: contentProps,
  setup(props22, ctx) {
    const editorId = inject("editorId");
    const html = ref("");
    const contentRef = ref();
    const resizeRef = ref();
    const {
      inputWrapperRef,
      codeMirrorUt,
      resetHistory
    } = useCodeMirror(props22);
    const {
      inputWrapperStyle,
      resizeOperateStyle,
      showPreviewWrapper
    } = useResize(props22, contentRef, resizeRef);
    useAutoScroll(props22, html, codeMirrorUt);
    ctx.expose({
      getSelectedText() {
        var _a3;
        return (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.getSelectedText();
      },
      focus(options) {
        var _a3;
        (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.focus(options);
      },
      resetHistory,
      getEditorView() {
        var _a3;
        return (_a3 = codeMirrorUt.value) == null ? void 0 : _a3.view;
      }
    });
    return () => {
      return createVNode("div", {
        "class": `${prefix}-content${showPreviewWrapper.value ? " has-preview" : ""}`,
        "ref": contentRef
      }, [createVNode("div", {
        "class": `${prefix}-input-wrapper`,
        "style": inputWrapperStyle,
        "ref": inputWrapperRef
      }, null), (props22.setting.htmlPreview || props22.setting.preview) && createVNode("div", {
        "class": `${prefix}-resize-operate`,
        "style": resizeOperateStyle,
        "ref": resizeRef
      }, null), showPreviewWrapper.value && createVNode(ContentPreview, {
        "modelValue": props22.modelValue,
        "onChange": props22.onChange,
        "setting": props22.setting,
        "onHtmlChanged": (html_) => {
          html.value = html_;
          props22.onHtmlChanged(html_);
        },
        "onGetCatalog": props22.onGetCatalog,
        "mdHeadingId": props22.mdHeadingId,
        "noMermaid": props22.noMermaid,
        "sanitize": props22.sanitize,
        "noKatex": props22.noKatex,
        "formatCopiedText": props22.formatCopiedText,
        "noHighlight": props22.noHighlight,
        "noImgZoomIn": props22.noImgZoomIn,
        "sanitizeMermaid": props22.sanitizeMermaid,
        "codeFoldable": props22.codeFoldable,
        "autoFoldThreshold": props22.autoFoldThreshold
      }, null), props22.catalogVisible && createVNode(MdCatalog, {
        "theme": props22.theme,
        "class": `${prefix}-catalog-editor`,
        "editorId": editorId,
        "mdHeadingId": props22.mdHeadingId,
        "key": "internal-catalog",
        "scrollElementOffsetTop": 2
      }, null)]);
    };
  }
});
var MarkdownTotal = defineComponent({
  props: {
    modelValue: {
      type: String,
      default: ""
    }
  },
  setup(props22) {
    const ult = inject("usedLanguageText");
    return () => {
      var _a3, _b2;
      return createVNode("div", {
        "class": `${prefix}-footer-item`
      }, [createVNode("label", {
        "class": `${prefix}-footer-label`
      }, [`${(_a3 = ult.value.footer) == null ? void 0 : _a3.markdownTotal}:`]), createVNode("span", null, [((_b2 = props22.modelValue) == null ? void 0 : _b2.length) || 0])]);
    };
  }
});
var props$2 = {
  checked: {
    type: Boolean,
    default: false
  },
  onChange: {
    type: Function,
    default: () => {
    }
  }
};
var Checkbox = defineComponent({
  props: props$2,
  setup(props22) {
    return () => {
      return createVNode("div", {
        "class": [`${prefix}-checkbox`, props22.checked && `${prefix}-checkbox-checked`],
        "onClick": () => {
          props22.onChange(!props22.checked);
        }
      }, null);
    };
  }
});
var props$13 = {
  scrollAuto: {
    type: Boolean
  },
  onScrollAutoChange: {
    type: Function,
    default: () => {
    }
  }
};
var ScrollAuto = defineComponent({
  props: props$13,
  setup(props22) {
    const ult = inject("usedLanguageText");
    return () => {
      var _a3;
      return createVNode("div", {
        "class": `${prefix}-footer-item`
      }, [createVNode("label", {
        "class": `${prefix}-footer-label`,
        "onClick": () => {
          props22.onScrollAutoChange(!props22.scrollAuto);
        }
      }, [(_a3 = ult.value.footer) == null ? void 0 : _a3.scrollAuto]), createVNode(Checkbox, {
        "checked": props22.scrollAuto,
        "onChange": props22.onScrollAutoChange
      }, null)]);
    };
  }
});
var props6 = {
  modelValue: {
    type: String,
    default: ""
  },
  footers: {
    type: Array,
    default: []
  },
  scrollAuto: {
    type: Boolean
  },
  noScrollAuto: {
    type: Boolean
  },
  onScrollAutoChange: {
    type: Function,
    default: () => {
    }
  },
  defFooters: {
    type: Object
  }
};
var Footer = defineComponent({
  name: "MDEditorFooter",
  props: props6,
  setup(props22) {
    const splitedItems = computed(() => {
      const moduleSplitIndex = props22.footers.indexOf("=");
      const barLeft = moduleSplitIndex === -1 ? props22.footers : props22.footers.slice(0, moduleSplitIndex);
      const barRight = moduleSplitIndex === -1 ? [] : props22.footers.slice(moduleSplitIndex, Number.MAX_SAFE_INTEGER);
      return [barLeft, barRight];
    });
    const footerRender = (name) => {
      if (allFooter.includes(name)) {
        switch (name) {
          case "markdownTotal": {
            return createVNode(MarkdownTotal, {
              "modelValue": props22.modelValue
            }, null);
          }
          case "scrollSwitch": {
            return !props22.noScrollAuto && createVNode(ScrollAuto, {
              "scrollAuto": props22.scrollAuto,
              "onScrollAutoChange": props22.onScrollAutoChange
            }, null);
          }
        }
      } else if (props22.defFooters instanceof Array) {
        return props22.defFooters[name] || "";
      } else if (props22.defFooters && props22.defFooters.children instanceof Array) {
        return props22.defFooters.children[name] || "";
      } else {
        return "";
      }
    };
    return () => {
      const LeftFooter = splitedItems.value[0].map((name) => footerRender(name));
      const RightFooter = splitedItems.value[1].map((name) => footerRender(name));
      return createVNode("div", {
        "class": `${prefix}-footer`
      }, [createVNode("div", {
        "class": `${prefix}-footer-left`
      }, [LeftFooter]), createVNode("div", {
        "class": `${prefix}-footer-right`
      }, [RightFooter])]);
    };
  }
});
var Editor = defineComponent({
  name: "MdEditorV3",
  props: editorProps,
  emits: editorEmits,
  setup(props22, ctx) {
    const {
      editorId,
      noKatex,
      noMermaid,
      noPrettier,
      noUploadImg,
      noHighlight
    } = props22;
    const state = reactive({
      scrollAuto: props22.scrollAuto
    });
    const rootRef = ref();
    const codeRef = ref();
    useOnSave(props22, ctx);
    useProvide(props22, rootRef);
    useExpansion(props22);
    useErrorCatcher(props22, ctx);
    const [setting, updateSetting] = useConfig(props22, ctx);
    const catalogVisible = useCatalog(props22);
    onBeforeUnmount(() => {
      bus.clear(editorId);
    });
    useExpose$1(props22, ctx, catalogVisible, setting, updateSetting, codeRef);
    return () => {
      const defToolbars = getSlot({
        props: props22,
        ctx
      }, "defToolbars");
      const defFooters = getSlot({
        props: props22,
        ctx
      }, "defFooters");
      return createVNode("div", {
        "id": editorId,
        "class": [prefix, props22.class, props22.theme === "dark" && `${prefix}-dark`, setting.fullscreen || setting.pageFullscreen ? `${prefix}-fullscreen` : ""],
        "style": props22.style,
        "ref": rootRef
      }, [props22.toolbars.length > 0 && createVNode(ToolBar, {
        "noPrettier": noPrettier,
        "toolbars": props22.toolbars,
        "toolbarsExclude": props22.toolbarsExclude,
        "setting": setting,
        "updateSetting": updateSetting,
        "tableShape": props22.tableShape,
        "defToolbars": defToolbars,
        "noUploadImg": noUploadImg,
        "showToolbarName": props22.showToolbarName,
        "catalogVisible": catalogVisible.value,
        "codeTheme": props22.codeTheme
      }, null), createVNode(Content, {
        "ref": codeRef,
        "modelValue": props22.modelValue,
        "setting": setting,
        "mdHeadingId": props22.mdHeadingId,
        "noMermaid": noMermaid,
        "noPrettier": noPrettier,
        "sanitize": props22.sanitize,
        "placeholder": props22.placeholder,
        "noKatex": noKatex,
        "scrollAuto": state.scrollAuto,
        "formatCopiedText": props22.formatCopiedText,
        "autofocus": props22.autoFocus,
        "disabled": props22.disabled,
        "readonly": props22.readOnly,
        "maxlength": props22.maxLength,
        "autoDetectCode": props22.autoDetectCode,
        "noHighlight": noHighlight,
        "updateModelValue": (value) => {
          ctx.emit("update:modelValue", value);
        },
        "onChange": (value) => {
          if (props22.onChange) {
            props22.onChange(value);
          }
          ctx.emit("onChange", value);
        },
        "onHtmlChanged": (html) => {
          if (props22.onHtmlChanged) {
            props22.onHtmlChanged(html);
          }
          ctx.emit("onHtmlChanged", html);
        },
        "onGetCatalog": (list) => {
          if (props22.onGetCatalog) {
            props22.onGetCatalog(list);
          }
          ctx.emit("onGetCatalog", list);
        },
        "onBlur": (e2) => {
          if (props22.onBlur) {
            props22.onBlur(e2);
          }
          ctx.emit("onBlur", e2);
        },
        "onFocus": (e2) => {
          if (props22.onFocus) {
            props22.onFocus(e2);
          }
          ctx.emit("onFocus", e2);
        },
        "onInput": (e2) => {
          if (props22.onInput) {
            props22.onInput(e2);
          }
          ctx.emit("onInput", e2);
        },
        "completions": props22.completions,
        "catalogVisible": catalogVisible.value,
        "theme": props22.theme,
        "noImgZoomIn": props22.noImgZoomIn,
        "onDrop": (e2) => {
          if (props22.onDrop) {
            props22.onDrop(e2);
          }
          ctx.emit("onDrop", e2);
        },
        "inputBoxWitdh": props22.inputBoxWitdh,
        "onInputBoxWitdhChange": (width) => {
          if (props22.onInputBoxWitdhChange) {
            props22.onInputBoxWitdhChange(width);
          }
          ctx.emit("onInputBoxWitdhChange", width);
        },
        "sanitizeMermaid": props22.sanitizeMermaid,
        "transformImgUrl": props22.transformImgUrl,
        "codeFoldable": props22.codeFoldable,
        "autoFoldThreshold": props22.autoFoldThreshold
      }, null), props22.footers.length > 0 && createVNode(Footer, {
        "modelValue": props22.modelValue,
        "footers": props22.footers,
        "defFooters": defFooters,
        "noScrollAuto": !setting.preview && !setting.htmlPreview || setting.previewOnly,
        "scrollAuto": state.scrollAuto,
        "onScrollAutoChange": (v) => state.scrollAuto = v
      }, null)]);
    };
  }
});
Editor.install = (app) => {
  app.component(Editor.name, Editor);
  app.use(NormalToolbar).use(DropdownToolbar).use(ModalToolbar).use(MdCatalog).use(MdPreview);
  return app;
};

// node_modules/md-editor-v3/lib/es/config.mjs
var zh_CN = staticTextDefault["zh-CN"];
var en_US = staticTextDefault["en-US"];

// node_modules/md-editor-v3/lib/es/index.mjs
var props7 = {
  onClick: {
    type: Function,
    default: void 0
  }
};
var NormalFooterToolbar = defineComponent({
  name: "NormalFooterToolbar",
  props: props7,
  emits: ["onClick"],
  setup(props22, ctx) {
    return () => {
      const Children = getSlot({
        props: props22,
        ctx
      });
      return createVNode("div", {
        "class": `${prefix}-footer-item`,
        "onClick": (e2) => {
          if (props22.onClick instanceof Function) {
            props22.onClick(e2);
          } else {
            ctx.emit("onClick", e2);
          }
        }
      }, [Children]);
    };
  }
});
NormalFooterToolbar.install = (app) => {
  app.component(NormalFooterToolbar.name, NormalFooterToolbar);
  return app;
};
export {
  DropdownToolbar,
  MdCatalog,
  Editor as MdEditor,
  MdModal,
  MdPreview,
  ModalToolbar,
  NormalFooterToolbar,
  NormalToolbar,
  StrIcon$1 as StrIcon,
  allFooter,
  allToolbar,
  config,
  editorExtensionsAttrs,
  en_US,
  iconfontClassUrl,
  iconfontSvgUrl,
  zh_CN
};
/*! Bundled license information:

medium-zoom/dist/medium-zoom.esm.js:
  (*! medium-zoom 1.1.0 | MIT License | https://github.com/francoischalifour/medium-zoom *)
*/
//# sourceMappingURL=md-editor-v3.js.map
