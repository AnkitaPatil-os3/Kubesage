"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compatMomoaCreate = void 0;
const jsonc_eslint_parser_1 = require("jsonc-eslint-parser");
const eslint_1 = require("eslint");
const eslint_compat_utils_1 = require("eslint-compat-utils");
const NODE_CONVERTERS = new WeakMap();
const TOKEN_CONVERTERS = new WeakMap();
const MOMOA_NODES = new Set([
    "Array",
    "Boolean",
    "Document",
    "Element",
    "Identifier",
    "Infinity",
    "Member",
    "NaN",
    "Null",
    "Number",
    "Object",
    "String",
]);
function compatMomoaCreate(create) {
    return ((context, ...args) => {
        const originalSourceCode = (0, eslint_compat_utils_1.getSourceCode)(context);
        if (!isMomoaSourceCode(originalSourceCode)) {
            const compatContext = {
                __proto__: context,
                sourceCode: originalSourceCode,
                get filename() {
                    return (0, eslint_compat_utils_1.getFilename)(context);
                },
                get cwd() {
                    return (0, eslint_compat_utils_1.getCwd)(context);
                },
            };
            return create(compatContext, ...args);
        }
        let sourceCode;
        const compatContext = {
            __proto__: context,
            get sourceCode() {
                return (sourceCode !== null && sourceCode !== void 0 ? sourceCode : (sourceCode = getCompatSourceCode(originalSourceCode)));
            },
            report(descriptor) {
                const momoaDescriptor = Object.assign({}, descriptor);
                if ("loc" in momoaDescriptor) {
                    if ("line" in momoaDescriptor.loc) {
                        momoaDescriptor.loc = convertPositionFromJsoncToMomoa(momoaDescriptor.loc);
                    }
                    else {
                        momoaDescriptor.loc = convertSourceLocationFromJsoncToMomoa(momoaDescriptor.loc);
                    }
                }
                if ("node" in momoaDescriptor) {
                    momoaDescriptor.node = Object.assign(Object.assign({}, momoaDescriptor.node), { loc: convertSourceLocationFromJsoncToMomoa(momoaDescriptor.node.loc) });
                }
                context.report(momoaDescriptor);
            },
        };
        return compatMomoaRuleListener(create(compatContext, ...args), originalSourceCode);
    });
}
exports.compatMomoaCreate = compatMomoaCreate;
function compatMomoaRuleListener(listener, momoaSourceCode) {
    const convert = getNodeConverter(momoaSourceCode);
    const listenerKeysSet = new Set();
    for (const [jsonKey, momoaKeys] of [
        ["Program", ["Document"]],
        ["JSONLiteral", ["Boolean", "String", "Null", "Number"]],
        ["JSONArrayExpression", ["Array"]],
        ["JSONObjectExpression", ["Object"]],
        ["JSONProperty", ["Member"]],
        ["JSONIdentifier", ["Identifier", "Infinity", "NaN"]],
        ["JSONUnaryExpression", ["Number", "Infinity", "NaN"]],
    ]) {
        if (listener[jsonKey]) {
            for (const momoaKey of momoaKeys) {
                listenerKeysSet.add(momoaKey);
            }
        }
        if (listener[`${jsonKey}:exit`]) {
            for (const momoaKey of momoaKeys) {
                listenerKeysSet.add(`${momoaKey}:exit`);
            }
        }
    }
    const result = Object.fromEntries([...listenerKeysSet].map((key) => {
        const listener = key.endsWith(":exit") ? dispatchExit : dispatch;
        return [key, listener];
    }));
    for (const [key, fn] of Object.entries(listener)) {
        if (!fn)
            continue;
        const newFn = (node, ...args) => {
            if (isMomoaNode(node)) {
                if (node.type !== "Element") {
                    const invoke = key.endsWith(":exit")
                        ? invokeWithReverseConvertedNode
                        : invokeWithConvertedNode;
                    invoke(node, (n) => fn(n, ...args));
                }
            }
            else {
                fn(node, ...args);
            }
        };
        const momoaFn = result[key];
        if (momoaFn) {
            result[key] = (...args) => {
                momoaFn(...args);
                newFn(...args);
            };
        }
        else {
            result[key] = newFn;
        }
    }
    return result;
    function dispatch(node) {
        invokeWithConvertedNode(node, (n) => { var _a; return (_a = listener[n.type]) === null || _a === void 0 ? void 0 : _a.call(listener, n); });
    }
    function dispatchExit(node) {
        invokeWithReverseConvertedNode(node, (n) => { var _a; return (_a = listener[`${n.type}:exit`]) === null || _a === void 0 ? void 0 : _a.call(listener, n); });
    }
    function invokeWithConvertedNode(node, cb) {
        const jsonNode = convert(node);
        if (Array.isArray(jsonNode)) {
            for (const n of jsonNode) {
                cb(n);
            }
        }
        else {
            cb(jsonNode);
        }
    }
    function invokeWithReverseConvertedNode(node, cb) {
        const jsonNode = convert(node);
        if (Array.isArray(jsonNode)) {
            for (let index = jsonNode.length - 1; index >= 0; index--) {
                const n = jsonNode[index];
                cb(n);
            }
        }
        else {
            cb(jsonNode);
        }
    }
}
function isMomoaSourceCode(sourceCode) {
    var _a;
    return (sourceCode.ast.type === "Document" &&
        sourceCode.ast.loc.start.column === 1 &&
        [
            "Array",
            "Object",
            "Boolean",
            "String",
            "Number",
            "Null",
            "NaN",
            "Infinity",
        ].includes((_a = sourceCode.ast.body) === null || _a === void 0 ? void 0 : _a.type) &&
        typeof sourceCode.getParent === "function");
}
function isMomoaNode(node) {
    return MOMOA_NODES.has(node.type);
}
function getCompatSourceCode(momoaSourceCode) {
    const convert = getNodeConverter(momoaSourceCode);
    const jsSourceCode = new eslint_1.SourceCode({
        text: momoaSourceCode.text,
        ast: convert(momoaSourceCode.ast),
        parserServices: { isJSON: true },
        visitorKeys: jsonc_eslint_parser_1.VisitorKeys,
    });
    const compatSourceCode = new Proxy(momoaSourceCode, {
        get(_target, prop) {
            const value = Reflect.get(jsSourceCode, prop);
            if (value !== undefined)
                return typeof value === "function" ? value.bind(jsSourceCode) : value;
            const momoaValue = Reflect.get(momoaSourceCode, prop);
            return typeof momoaValue === "function"
                ? momoaValue.bind(momoaSourceCode)
                : momoaValue;
        },
    });
    return compatSourceCode;
}
function getNodeConverter(momoaSourceCode) {
    const converter = NODE_CONVERTERS.get(momoaSourceCode.ast);
    if (converter) {
        return converter;
    }
    const tokenConverter = getTokenConverter(momoaSourceCode);
    const convertedNodes = new Map();
    const nodeConverters = {
        Array(node) {
            let elements;
            return {
                get parent() {
                    return getParent(node);
                },
                type: "JSONArrayExpression",
                get elements() {
                    return (elements !== null && elements !== void 0 ? elements : (elements = node.elements.map((e) => convertNode(e.value))));
                },
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
        Boolean(node) {
            return {
                get parent() {
                    return getParent(node);
                },
                type: "JSONLiteral",
                value: node.value,
                bigint: null,
                regex: null,
                get raw() {
                    return momoaSourceCode.text.slice(...node.range);
                },
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
        Null(node) {
            return {
                get parent() {
                    return getParent(node);
                },
                type: "JSONLiteral",
                value: null,
                bigint: null,
                regex: null,
                get raw() {
                    return momoaSourceCode.text.slice(...node.range);
                },
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
        Number(node) {
            const raw = momoaSourceCode.text.slice(...node.range);
            if (raw.startsWith("-") || raw.startsWith("+")) {
                const argumentRange = [node.range[0] + 1, node.range[1]];
                const rawArgument = momoaSourceCode.text.slice(...argumentRange);
                const literal = {
                    get parent() {
                        return unaryExpression;
                    },
                    type: "JSONLiteral",
                    value: Math.abs(node.value),
                    bigint: null,
                    regex: null,
                    raw: rawArgument,
                    range: argumentRange,
                    loc: convertSourceLocationFromMomoaToJsonc({
                        start: {
                            line: node.loc.start.line,
                            column: node.loc.start.column + 1,
                        },
                        end: node.loc.end,
                    }),
                };
                const unaryExpression = {
                    get parent() {
                        return getParent(node);
                    },
                    type: "JSONUnaryExpression",
                    operator: raw[0],
                    prefix: true,
                    argument: literal,
                    range: node.range,
                    loc: convertSourceLocationFromMomoaToJsonc(node.loc),
                };
                return [unaryExpression, literal];
            }
            return {
                get parent() {
                    return getParent(node);
                },
                type: "JSONLiteral",
                value: node.value,
                bigint: null,
                regex: null,
                get raw() {
                    return momoaSourceCode.text.slice(...node.range);
                },
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
        String(node) {
            return {
                get parent() {
                    return getParent(node);
                },
                type: "JSONLiteral",
                value: node.value,
                bigint: null,
                regex: null,
                get raw() {
                    return momoaSourceCode.text.slice(...node.range);
                },
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
        Document(node) {
            let body;
            let tokens;
            let comments;
            return {
                get parent() {
                    return getParent(node);
                },
                type: "Program",
                get body() {
                    return (body !== null && body !== void 0 ? body : (body = [convertNode(node.body)]));
                },
                get comments() {
                    return (comments !== null && comments !== void 0 ? comments : (comments = node
                        .tokens.filter((token) => token.type === "LineComment" || token.type === "BlockComment")
                        .flatMap(tokenConverter)));
                },
                get tokens() {
                    return (tokens !== null && tokens !== void 0 ? tokens : (tokens = node
                        .tokens.filter((token) => token.type !== "LineComment" && token.type !== "BlockComment")
                        .flatMap(tokenConverter)));
                },
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
        Object(node) {
            let members;
            return {
                get parent() {
                    return getParent(node);
                },
                type: "JSONObjectExpression",
                get properties() {
                    return (members !== null && members !== void 0 ? members : (members = node.members.map(convertNode)));
                },
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
        Member(node) {
            let keyNode;
            let value;
            return {
                get parent() {
                    return getParent(node);
                },
                type: "JSONProperty",
                get key() {
                    return (keyNode !== null && keyNode !== void 0 ? keyNode : (keyNode = convertNode(node.name)));
                },
                get value() {
                    return (value !== null && value !== void 0 ? value : (value = convertNode(node.value)));
                },
                kind: "init",
                method: false,
                shorthand: false,
                computed: false,
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
        Identifier(node) {
            return {
                get parent() {
                    return getParent(node);
                },
                type: "JSONIdentifier",
                name: node.name,
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
        Infinity(node) {
            const raw = momoaSourceCode.text.slice(...node.range);
            if (raw.startsWith("-") || raw.startsWith("+")) {
                const argumentRange = [node.range[0] + 1, node.range[1]];
                const identifier = {
                    get parent() {
                        return unaryExpression;
                    },
                    type: "JSONIdentifier",
                    name: "Infinity",
                    range: argumentRange,
                    loc: convertSourceLocationFromMomoaToJsonc({
                        start: {
                            line: node.loc.start.line,
                            column: node.loc.start.column + 1,
                        },
                        end: node.loc.end,
                    }),
                };
                const unaryExpression = {
                    get parent() {
                        return getParent(node);
                    },
                    type: "JSONUnaryExpression",
                    operator: raw[0],
                    prefix: true,
                    argument: identifier,
                    range: node.range,
                    loc: convertSourceLocationFromMomoaToJsonc(node.loc),
                };
                return [unaryExpression, identifier];
            }
            return {
                get parent() {
                    return getParent(node);
                },
                type: "JSONIdentifier",
                name: "Infinity",
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
        NaN(node) {
            const raw = momoaSourceCode.text.slice(...node.range);
            if (raw.startsWith("-") || raw.startsWith("+")) {
                const argumentRange = [node.range[0] + 1, node.range[1]];
                const identifier = {
                    get parent() {
                        return unaryExpression;
                    },
                    type: "JSONIdentifier",
                    name: "NaN",
                    range: argumentRange,
                    loc: convertSourceLocationFromMomoaToJsonc({
                        start: {
                            line: node.loc.start.line,
                            column: node.loc.start.column + 1,
                        },
                        end: node.loc.end,
                    }),
                };
                const unaryExpression = {
                    get parent() {
                        return getParent(node);
                    },
                    type: "JSONUnaryExpression",
                    operator: raw[0],
                    prefix: true,
                    argument: identifier,
                    range: node.range,
                    loc: convertSourceLocationFromMomoaToJsonc(node.loc),
                };
                return [unaryExpression, identifier];
            }
            return {
                get parent() {
                    return getParent(node);
                },
                type: "JSONIdentifier",
                name: "NaN",
                range: node.range,
                loc: convertSourceLocationFromMomoaToJsonc(node.loc),
            };
        },
    };
    NODE_CONVERTERS.set(momoaSourceCode.ast, convertNode);
    return convertNode;
    function getParent(node) {
        const parent = momoaSourceCode.getParent(node);
        if (!parent)
            return null;
        const parentNode = parent;
        if (parentNode.type === "Element") {
            return getParent(parentNode);
        }
        const convertedParent = convertNode(parentNode);
        if (Array.isArray(convertedParent)) {
            return convertedParent[0];
        }
        return convertedParent;
    }
    function convertNode(node) {
        if (convertedNodes.has(node)) {
            return convertedNodes.get(node);
        }
        const newNode = nodeConverters[node.type](node);
        convertedNodes.set(node, newNode);
        return newNode;
    }
}
function getTokenConverter(momoaSourceCode) {
    const converter = TOKEN_CONVERTERS.get(momoaSourceCode.ast);
    if (converter) {
        return converter;
    }
    const convertedTokens = new Map();
    const tokenConverters = {
        BlockComment(token) {
            return {
                type: "Block",
                get value() {
                    return momoaSourceCode.text.slice(token.range[0] + 2, token.range[1] - 2);
                },
                range: token.range,
                loc: convertSourceLocationFromMomoaToJsonc(token.loc),
            };
        },
        LineComment(token) {
            return {
                type: "Line",
                get value() {
                    return momoaSourceCode.text.slice(token.range[0] + 2, token.range[1]);
                },
                range: token.range,
                loc: convertSourceLocationFromMomoaToJsonc(token.loc),
            };
        },
        Boolean(token) {
            return createStandardToken("Keyword", token);
        },
        Null(token) {
            return createStandardToken("Keyword", token);
        },
        Identifier(token) {
            return createStandardToken("Identifier", token);
        },
        Infinity(token) {
            const raw = momoaSourceCode.text.slice(...token.range);
            if (raw.startsWith("-") || raw.startsWith("+")) {
                return [
                    createPunctuator(raw[0], {
                        range: [token.range[0], token.range[0] + 1],
                        loc: {
                            start: token.loc.start,
                            end: {
                                line: token.loc.start.line,
                                column: token.loc.start.column + 1,
                            },
                        },
                    }),
                    createStandardToken("Identifier", {
                        range: [token.range[0] + 1, token.range[1]],
                        loc: {
                            start: {
                                line: token.loc.start.line,
                                column: token.loc.start.column + 1,
                            },
                            end: token.loc.end,
                        },
                    }),
                ];
            }
            return createStandardToken("Identifier", token);
        },
        NaN(token) {
            const raw = momoaSourceCode.text.slice(...token.range);
            if (raw.startsWith("-") || raw.startsWith("+")) {
                return [
                    createPunctuator(raw[0], {
                        range: [token.range[0], token.range[0] + 1],
                        loc: {
                            start: token.loc.start,
                            end: {
                                line: token.loc.start.line,
                                column: token.loc.start.column + 1,
                            },
                        },
                    }),
                    createStandardToken("Identifier", {
                        range: [token.range[0] + 1, token.range[1]],
                        loc: {
                            start: {
                                line: token.loc.start.line,
                                column: token.loc.start.column + 1,
                            },
                            end: token.loc.end,
                        },
                    }),
                ];
            }
            return createStandardToken("Identifier", token);
        },
        Number(token) {
            const raw = momoaSourceCode.text.slice(...token.range);
            if (raw.startsWith("-") || raw.startsWith("+")) {
                return [
                    createPunctuator(raw[0], {
                        range: [token.range[0], token.range[0] + 1],
                        loc: {
                            start: token.loc.start,
                            end: {
                                line: token.loc.start.line,
                                column: token.loc.start.column + 1,
                            },
                        },
                    }),
                    createStandardToken("Numeric", {
                        range: [token.range[0] + 1, token.range[1]],
                        loc: {
                            start: {
                                line: token.loc.start.line,
                                column: token.loc.start.column + 1,
                            },
                            end: token.loc.end,
                        },
                    }),
                ];
            }
            return createStandardToken("Numeric", token);
        },
        String(token) {
            return createStandardToken("String", token);
        },
        Colon(token) {
            return createPunctuator(":", token);
        },
        Comma(token) {
            return createPunctuator(",", token);
        },
        LBracket(token) {
            return createPunctuator("[", token);
        },
        LBrace(token) {
            return createPunctuator("{", token);
        },
        RBracket(token) {
            return createPunctuator("]", token);
        },
        RBrace(token) {
            return createPunctuator("}", token);
        },
    };
    TOKEN_CONVERTERS.set(momoaSourceCode.ast, convertToken);
    return convertToken;
    function createStandardToken(type, token) {
        return {
            type,
            get value() {
                return momoaSourceCode.text.slice(...token.range);
            },
            range: token.range,
            loc: convertSourceLocationFromMomoaToJsonc(token.loc),
        };
    }
    function createPunctuator(value, token) {
        return {
            type: "Punctuator",
            value,
            range: token.range,
            loc: convertSourceLocationFromMomoaToJsonc(token.loc),
        };
    }
    function convertToken(token) {
        if (convertedTokens.has(token)) {
            return convertedTokens.get(token);
        }
        const newToken = tokenConverters[token.type](token);
        convertedTokens.set(token, newToken);
        return newToken;
    }
}
function convertSourceLocationFromMomoaToJsonc(loc) {
    return {
        start: convertPositionFromMomoaToJsonc(loc.start),
        end: convertPositionFromMomoaToJsonc(loc.end),
    };
}
function convertPositionFromMomoaToJsonc(position) {
    return {
        line: position.line,
        column: position.column - 1,
    };
}
function convertSourceLocationFromJsoncToMomoa(loc) {
    return {
        start: convertPositionFromJsoncToMomoa(loc.start),
        end: convertPositionFromJsoncToMomoa(loc.end),
    };
}
function convertPositionFromJsoncToMomoa(position) {
    return {
        line: position.line,
        column: position.column + 1,
    };
}
